% -*- Mode: BibTeX -*-
% masuhara.bib
% papers of my work
% exception:	Japanes papers (see japanese-e.bib or japanese-j.bib)

% include: strings.bib

@bachelorsthesis{masuhara92bachelors-thesis,
  author =	 "Hidehiko Masuhara",
  title =	 "Study on Implementation of an Object-Oriented
		  Concurrent Reflective Language",
  howpublished = "Bachelor's Thesis, " # ISUTokyo,
  school =  "Department of Information Science, the University of Tokyo",
  year =	 1992,
  keywords = 	 {ABCL/R},
  url = 	 {https://www.is.s.u-tokyo.ac.jp/},
  month = 	 feb,
  note = 	 {Supervisor: Akinori Yonezawa}
}

@InProceedings{masuhara92oopsla,
  author = 	MasMatWatYon,
  title = 	"Object-Oriented Concurrent Reflective Languages can
		 be Implemented Efficiently",
  crossref = 	"oopsla92",
  pages = 	"127--145",
  pdf = 	 {oopsla1992.pdf},
  doi = 	 {10.1145/141937.141948},
  serialNo =	 "16-6",
  acceptanceRatio = "31/250 (12%)",
  keywords = 	 {ABCL/R},
  abstract = 	 {Computational reflection is beneficial in concurrent computing in offering a linguistic mechanism for incorporating user-specific policies . New challenges are (1) how to implement them, and (2) how to do so efficiently. We present efficient implementation schemes for object-oriented concurrent reflective languages using our language ABCL/R2 as an example. The schemes include: efficient lazy creation of metaobjects/meta-groups, partial compilation of scripts (methods), dynamic progression, self-reification, and light-weight objects, all appropriately integrated so that the user-level semantics remain consistent with the meta-circular definition so that the full power of reflection is retained, while achieving practical efficiency. ABCL/R2 exhibits two orders of magnitude speed improvement over its predecessor, ABCL/R, and in fact compares favorably to the ABCL/1 compiler and also C + Sun LWP, neither supporting reflection.}
}

@InProceedings{masuhara93rw,
  author = 	 MasMatYon,
  title = 	 "Designing an {OO} Reflective Language for
		  Massively-Parallel Processors",
  booktitle = OOPSLA93RW,
  year = 	 1993,
  address = 	 WashingtonDC,
  month = 	 oct,
  keywords = 	 {ABCL/R}
}

@MastersThesis{masuhara94master-thesis,
  author = 	 "Hidehiko Masuhara",
  title = 	 "Study on a Reflective Architecture to Provide
		  Efficient Dynamic Resource Management for
		  Highly-Parallel Object-Oriented Applications",
  pdf = 	 {masterthesis.pdf},
  url = 	 {https://www.is.s.u-tokyo.ac.jp/},
  school = 	 ISGSUTokyo,
  year = 	 1994,
  keywords = 	 {ABCL/R},
  note = 	 {Supervisor: Akinori Yonezawa},
  abstract = 	 {Recent progress in implementations of object-oriented concurrent programming languages on highly-parallel processors makes it feasible to construct large-scale parallel applications having complicated structures. Such applications can not exhibit good performance without dynamic resource management (e.g., load-balancing and object scheduling) tailored to the characteristics of the applications and/or machine architectures. Since dynamic resource management systems are usually intertwined with the language implementation, modification/extension of the management systems requires complicated programming in the low-level language. Reflective systems can provide abstractions to modify/extend the implementation-level facilities within the application-level language. This study proposes a reflective architecture of an object-oriented concurrent language for highly-parallel processors to provide resource management systems for parallel applications. To make our architecture practical, much attention is payed on balancing the trade-offs between extensibility and efficiency; we examine the requirements for realistic applications by developing resource management systems for search problems and N -body simulation, and design the architecture based on the requirements. The architecture is evaluated by experiments through a prototype system running on a parallel computer.}
}

@InProceedings{masuhara94wooc,
  author = 	 MasMatYon,
  title = 	 "Distributed Memory Reflective Architecture for High
		  Performance Object-Oriented Computing",
  booktitle = WOOC,
  year = 	 1994,
  organization = JSSST,
  address = 	 Ootu,
  month = 	 mar,
  keywords = 	 {ABCL/R}
}

@Article{masuhara94swopp,
  author = 	 MasMatYon,
  title = 	 "An Object-Oriented Concurrent Reflective Language
		  for Dynamic Resource Management in Highly Parallel
		  Computing",
  OPTjournal = 	 IPSJSIG,
  year = 	 1994,
  journal = 	 {IPSJ Technical Reports SIG-PRG},
  OPTvolume = 	 94,
  pdf = 	 {prg1994.pdf},
  volume = 	 1994,
  url = 	 {http://id.nii.ac.jp/1001/00030453/},
  number = 	 {65(1994-PRO-018)},
  pages = 	 "57--64",
  month = 	 jul,
  OPTnote = "(94-PRG-18)",
  keywords = 	 {ABCL/R}
}


@InProceedings{masuhara95oopsla,
  author = 	 MasMatAsaYon,
  title = 	 "Compiling Away the Meta-Level in Object-Oriented
		  Concurrent Reflective Languages Using Partial
		  Evaluation",
  crossref = 	 "oopsla95",
  doi = 	 {10.1145/217839.217869},
  pdf = 	 {oopsla1995.pdf},
  pages =        "300--315",
  acceptanceRatio = "28/155",
  keywords = 	 {ABCL/R},
  abstract = 	 {Meta-level programmability is beneficial for parallel/distributed object-oriented computing to improve performance, etc. The major problem, however, is interpretation overhead due to meta-circular interpretation. To solve this problem, we propose a compilation framework for object-oriented concurrent reflective languages using partial evaluation. Since traditional partial evaluators do not allow us to directly deal with meta-circular interpreters written with concurrent objects, we devised techniques such as pre-/post-processing, a new proposed preaction extension to partial evaluation in order to handle side-effects, etc. Benchmarks of a prototype compiler for our language ABCL/R3 indicate that (1) the meta-level interpretation is essentially `compiled away,' and (2) meta-level optimizations in a parallel application, running on a Fujitsu MPP AP1000, exhibits only 10--30\% overhead compared to the hand-crafted source-level optimization in a non-reflective language.}
}

@InProceedings{masuhara95imsa,
  author = 	 MasMatAsaYon,
  title = 	 "Efficient Implementation Technique for
		  Object-Oriented Concurrent Reflective Languages
		  Using Partial Evaluation",
  booktitle = 	 IMSA95,
  year = 	 1995,
  note =	 "Digested version of \cite{masuhara95oopsla}.",
  keywords = 	 {ABCL/R}
}

@TechReport{asai95techrep,
  author = 	 "Kenichi Asai and Hidehiko Masuhara and Satoshi
		  Matsuoka and Akinori Yonezawa",
  title = 	 "Partial Evaluator as a Compiler for Reflective
		  Languages",
  pdf = 	 {techrep1995-10.pdf},
  institution =  "Department of Information Science, the University of Tokyo",
  year = 	 1995,
  number =	 "95--10",
  month =	 dec,
  serialNo =	 "2-26",
  annote =	 "Submitted to PEPM'95, but in vain.",
  keywords = 	 {Black, Scheme}
}

@InProceedings{masuhara96reflection,
  author = 	 MasMatYon,
  title = 	 "Implementing Parallel Language Constructs Using
  a Reflective Object-Oriented Language",
  crossref = 	 "reflection96",
  pdf = 	 {reflection1996.pdf},
  pages =	 "79--91",
  keywords = 	 {ABCL/R},
  abstract = 	 {To provide various parallel language constructs, extensible languages based on reflection are attractive for both implementors and users. This paper describes our proposed meta-level architecture of a concurrent object-oriented language ABCL/R3, which has the following characteristics: (1) language customization through meta-interpreters and meta-objects, (2) delegation and inheritance mechanisms facilitating modular and re-usable meta-level programming, and (3) the reflective annotations and meta-level arguments realizing separation of base- and meta-level programs. We also show that several meta-level programs that provide common parallel programming strategies, such as object replication and latency hiding, are easily implemented.}
}

@TechReport{asai96techrep,
  author = 	 "Kenichi Asai and Hidehiko Masuhara and Akinori
		  Yonezawa",
  title = 	 "Partial Evaluation of Call-by-value lambda-calculus
		  with side-effects",
  institution =  "Department of Information Science, the University of Tokyo",
  year = 	 1996,
  number =	 "96--04",
  month =	 nov,
  keywords = 	 {Black, Scheme}
}

@InProceedings{asai97pepm,
  crossref =     "pepm97",
  pdf = 	 {pepm1997.pdf},
  doi = 	 {10.1145/258993.258997},
  url = 	 {https://dl.acm.org/doi/proceedings/10.1145/258993},
  author = 	 "Kenichi Asai and Hidehiko Masuhara and Akinori
		  Yonezawa",
  title = 	 "Partial Evaluation of Call-by-value lambda-calculus
		  with Side-effects",
  pages =	 "12--21",
  serialNo =	 "6-12",
  keywords = 	 {Black, Scheme},
  abstract = 	 {We present a framework of an online partial evaluator for a call-by-vahre A-calculus with destructiveupdatesof data structures. It properly and correctly specializes expressions that contain side-effects, while preserving pointer equality, which is an important property for programs using updates. Our partial evaluator uses a side-effect analysis to extract immutable data structures and then performs an online specialization using preactions. Once mutable and immutable data structures are separated, partial evaluation is done in such a way that accesses to immutable ones are performed at specialization time, while accesses to mutable ones are residualized. For the correct residualization of side-effecting operations, preactions are used to solve various issues, including code elimination, code duplication, and execution order preservation. The preaction mechanism also enables us to reduce expressions that were residualized when the conventional let-expression approach of Similix was used. The resulting partial evaluator is simple enough to prove its correctness. Based on the framework, we have constructed a partial evaluator for Scheme, which is powerful enough to specialize fairly complicated programs with side-effects, such as an interpreter.}
}

@InProceedings{masuhara97imsa,
  author = 	 "Hidehiko Masuhara and Akinori Yonezawa",
  title = 	 "Reasoning-conscious Meta-object Design of a
		  Reflective Concurrent Language",
  booktitle = 	 IMSA97,
  year = 	 1997,
  pages =	 "42--56",
  organization = "ETL/IPA",
  address =	 Tsukuba,
  month =	 oct,
  keywords = 	 {ABCL/R}
}

Misc{masuhara97draft,
  author = 	 "Hidehiko Masuhara and Akinori Yonezawa",
  title = 	 "Design and Partial Evaluation of Meta-objects for a
		  Concurrent Reflective Language",
  howpublished = "submitted for publication",
  year = 	 1997,
  month = 	 dec,
  OPTnote = 	 "",
  OPTaffil = 	 "",
  OPTkeywords =  "",
  OPTserialNo =  "",
  OPTannote = 	 "",
  keywords = 	 {ABCL/R}
}


@InProceedings{masuhara98iwpse,
  author = 	 "Hidehiko Masuhara and Akinori Yonezawa",
  title = 	 "A Reflective Approach to Support Software Evolution",
  crossref =     "iwpse98",
  OPTbooktitle = "International Workshop on the Principles of Software
		  Evolution",
  OPTyear = 	 1998,
  OPTeditor =	 "Takuya Katamaya",
  pages =	 "135--139",
  OPTaddress =	 "Kyoto",
  OPTmonth =	 apr,
  keywords = 	 {ABCL/R}
}

@InProceedings{masuhara98ecoop,
  author = 	 "Hidehiko Masuhara and Akinori Yonezawa",
  title = 	 "Design and Partial Evaluation of Meta-objects for a
		  Concurrent Reflective Language",
  pdf = 	 {ecoop1998.pdf},
  doi = 	 {10.1007/BFb0054102},
  url = 	 {http://ecoop98.vub.ac.be/},
  crossref = 	 "ecoop98",
  pages =	 "418--439",
  acceptanceRatio = "24/124 (19%)",
  keywords = 	 {ABCL/R},
  abstract = 	 {Customizable meta-objects are a powerful abstraction for extending language features and implementation mechanisms, but interpretive execution suffers from severe performance penalty. Some of this penalty can be reduced by applying partial evaluation to meta-interpreters, but partial evaluation of meta-objects in existing concurrent object-oriented languages is ineffective. This paper proposes a new meta-object design for our reflective language ABCL/R3. It yields meta-objects that can be optimized effectively using partial evaluation. The crux of the design is the separation of state-related operations from other operations, and this separation is accomplished by using reader/writer methods in our concurrent object-oriented language called Schematic. Our benchmark trials show that non-trivial programs with partially evaluated meta-objects run more than six times faster than ones that are interpreted by meta-objects. In addition, a partially evaluated program that uses a customized meta-object runs as efficiently as a program that is manually rewritten so as to have the same functionality without using meta-objects.}
}

@InProceedings{sugita98oopsla-rw,
  author = 	 "Yuuya Sugita and Hidehiko Masuhara and Kenichi
		  Harada and Akinori Yonezawa",
  pdf = 	 {oopsla98reflection.pdf},
  title = 	 "On-the-fly Specialization of Reflective Programs
		  Using Dynamic Code Generation Techniques",
  crossref = 	 "oopsla98rw",
  OPTyear = 	 1998,
  OPTeditor =	 "Jean-Charles Fabre and Shigeru Chiba",
  OPTvolume =	 "98--4",
  OPTseries =	 "Technical Report of Center for Computational
		  Physics, University of Tsukuba",
  pages =	 "21--25",
  OPTaddress =	 "Vancouver, B.C., Canada",
  OPTmonth =	 oct,
  OPTannote =	 "ISSN 1344-3135"
}

@PhdThesis{masuhara99phd,
  pdf = 	 {phdthesis.pdf},
  doi = 	 {10.11501/3163477},
  url = 	 {https://www.is.s.u-tokyo.ac.jp/},
  author = 	 "Hidehiko Masuhara",
  title = 	 "Architecture Design and Compilation Techniques Using
		  Partial Evaluation in Reflective Concurrent
		  Object-Oriented Languages",
  school = 	 ISGSUTokyo,
  year = 	 1999,
  OPTaddress = 	 "",
  month = 	 jan,
  OPTtype = 	 "",
  OPTnote = 	 "",
  OPTaffil = 	 "",
  OPTkeywords =  "",
  OPTserialNo =  "",
  OPTannote = 	 "",
  keywords = 	 {ABCL/R},
  note = 	 {Supervisor: Akinori Yonezawa},
  abstract = 	 {Parallel and distributed programs often have hardware/problem specific optimizations for improving quality of the program such as efficiency and robustness. Those optimizations, unfortunately, degrade portability and re-usability as they are intertwined with the original algorithm description. Reflective languages, which provide the application programmer extensible and abstract implementation of the language, can describe such optimizations as extensions to the language. The separation of optimization descriptions gains portability and re-usability of both application programs and optimizations. However, the interpretive execution model of reflective languages imposes a large amount of performance overhead, which sometimes outweighs benefits of optimizations. Previous reflective languages prohibit some of operations being modified via reflection, so as to reduce the amount of interpretation overhead. The imperfection of this approach is that it still leaves a considerable amount of overhead, and it yields less flexible, unclear reflective architecture. 

This dissertation investigates design and compilation framework of meta-interpreters and meta-objects in an object-oriented concurrent language ABCL/R3. By using partial evaluation to compile reflective programs, ABCL/R3 achieves flexible and lucid reflective architecture and efficient execution at the same time. We design full-fledged meta-interpreters by examining several concurrent programming examples. A newly proposed delegation mechanism enables to define modular and scope controlled extensions to meta-interpreters. We design meta-objects by exploiting the notion of reader/writer methods in a concurrent object-oriented language Schematic, so that they can be effectively partially evaluated. The compilation frameworks of meta-interpreters and meta-objects basically translate concurrent object definitions into a sequential program, then apply partial evaluator for a sequential language, and generates a program in a (non-reflective) concurrent object-oriented language, in which base-level and meta-level objects are collapsed to single level objects. The effciency of generated programs is demonstrated by several benchmark programs, in which our compiler exhibits performance close to non-reflective languages.}
}


@InProceedings{sekiguchi99coordination,
  pdf = 	 {coordination1999.pdf},
  author = 	 "Tatsurou Sekiguchi and Hidehiko Masuhara and Akinori 
		  Yonezawa",
  title = 	 "A Simple Extension of {Java} Language for
		  Controllable Transparent Migration and Its Portable
		  Implementation",
  doi = 	 {10.1007/3-540-48919-3_16},
  booktitle = 	 "Proceedings of Third International Conference on
		  Coordination Models and Languages (COORDINATION'99)",
  year = 	 1999,
  editor =	 "Paolo Ciancarini and Alexander L. Wolf",
  number =	 1594,
  series = 	 LNCS,
  pages =	 "211--226",
  publisher = SV,
  address = 	 "Amsterdam, The Netherlands",
  month = 	 apr,
  acceptanceRatio = "26/67 (39%)",
  abstract = 	 {A scheme has been developed that enables a Java program to be migrated across computers while preserving its execution state, such as the values of local variables and the dynamic extents of try-and-catch blocks. This scheme provides the programmer with flexible control of migration, including transparent migration. It is based on source-code-level transformation. The translator takes as input code a Java program written in a Java language extended with language constructs for migration, and outputs pure Java source code that uses JavaRMI. The translated code can run on any Java interpreter and can be compiled by any just-in-time compiler. We have measured some execution performance for several application programs, and found that the translated programs are only about 20\% slower than the original programs. Because migration is completely controlled by using only three language constructs added to the Java language (go , undock and migratory), the programmer can write programs to be migrated easily and succinctly. Our system is available in the public domain.}
}

InProceedings{masuhara99obpdc,
  author = 	 "Hidehiko Masuhara",
  title = 	 "An Overview of {ABCL/R3}: an Object-Oriented
		  Concurrent Reflective Language", 
  booktitle = 	 "Proceedings of Object-Based Parallel and Distributed 
		  Computing (OBPDC'97)",
  year = 	 1999,
  series =	 LNCS,
  note = 	 "since this is published as \cite{masuhara2000oopdp}, 
		  do not use this entry"
}

@InProceedings{masuhara99ptw-e,
  author = 	 "Hidehiko Masuhara and  Yuuya Sugita and  Akinori
		  Yonezawa",
  title = 	 "Optimizing Reflective Languages by Using Partial
		  Evaluation",
  booktitle = 	 "Program Transformation Workshop (PTW'99)",
  year = 	 1999,
  month =	 mar,
  keywords = 	 {ABCL/R}
}

@Misc{masuhara99javagrande,
  author =	 "Hidehiko Masuhara",
  title =	 "ByteCode Specialization ({BCS}): 
	A Run-Time Specialization Technique in {JVM} Bytecode",
  howpublished = "Poster Presentation at ACM Java Grande'99",
  year =	 1999,
  month =	 jun,
  keywords = 	 {Java, partial evaluation}
}

@InProceedings{masuhara99peday,
  pdf = 	 {peday99-generating.pdf},
  author = 	 "Hidehiko Masuhara and Akinori Yonezawa",
  title = 	 "Generating Optimized Residual Code in Run-time
		  Specialization",
  booktitle = 	 "Proceedings of International Colloquium on Partial
		  Evaluation and Program Transformation",
  year = 	 1999,
  OPTeditor = 	 "Robert Gl{\"u}ck and Yoshihiko Futamura",
  pages =	 "83--102",
  address =	 "Waseda University, Tokyo, Japan",
  month =	 nov,
  keywords = 	 {Java, bytecode, partial evaluation},
  abstract = 	 {Run-time specialization (RTS) techniques efficiently generate specialized programs with respect to run-time values. They construct compiled native-code fragments called templates at compile-time, and generate a specialized program by merely copying the templates. The generated programs are less efficient than those generated by static partial evaluation techniques because the RTS techniques prevent many optimizations.

The proposed bytecode specialization (BCS) technique is used to generate programs in a bytecode language and then translate the generated bytecode into native code by using a just-in-time (JIT) compiler. Its advantages are (1) efficient specialization processes that are similar to those of RTS techniques, (2) efficient specialized programs thanks to optimizations by the JIT compilers, and (3) that it is independent of the source-to-bytecode and the bytecode-to-native compilers thanks to a binding-time analysis algorithm that directly handles bytecode programs.

Thus far, a BCS system has been implemented for a Java virtual machine subset. Micro-benchmarking showed that BCS with JIT compilation generates specialized programs that run more than 3-times faster than ones generated by traditional RTS techniques and that this specialization process takes less than one second.}
}

@InProceedings{yamauchi2000rm,
  pdf = 	 {rm2000.pdf},
  author = 	 "Hiroshi Yamauchi and Hidehiko Masuhara and Daisuke
		  Hoshina and Tatsurou Sekiguchi and Akinoni Yonezawa",
  title = 	 "Wrapping Class Libraries  for Migration-Transparent
		  Resource Access  by Using Compile-Time Reflection", 
  booktitle = 	 "Workshop on Reflective Middleware (RM2000)",
  year = 	 2000,
  editor =	 "Gordon Blair and Roy Campbell",
  pages =	 "19--20",
  address =	 "New York, USA",
  month =	 apr
}

@InCollection{masuhara2000oopdp,
  author = 	 "Hidehiko Masuhara and Akinori Yonezawa",
  title = 	 "An Object-Oriented Concurrent Reflective Language
		  {ABCL/R3}: Its Meta-level Design and Efficient
		  Implementation Techniques",
  booktitle = 	 "Object-Oriented Parallel and Distributed Programming",
  isbn = 	 {2-7462-0091-0},
  publisher = 	 "HERMES Science Publications",
  year = 	 2000,
  editor =	 "Jean-Paul Bahsoun and Takanobu Baba and Jean-Pierre
		  Briot and Akinori Yonezawa",
  pages =	 "151--165",
  address =	 "Paris",
  annote =	 "the published version of \cite{masuhara99obpdc},
		  which is planed as a conference record of OBPDC'97."
}


@InProceedings{masuhara2000ispse,
  author = 	 "Hidehiko Masuhara and Yuuya Sugita and Akinori Yonezawa",
  title = 	 "Dynamic Compilation of a Reflective Language Using
		  Run-Time Specialization", 
  booktitle = 	 "International Symposium on Principles of Software
		  Evolution",
  url = 	 {http://www.jaist.ac.jp/ISPSE/},
  editor =       "Takuya Katayama and Tetsuo Tamai and Naoki Yonezaki",
  year = 	 2000,
  publisher =    "IEEE Computer Society",
  pdf = 	 {ispse2000.pdf},
  pages =	 "128--137",
  month = 	 nov,
  abstract = 	 {In reflective languages, application programs can customize a language system that executes the application programs. Our premise is that this customizability of reflective languages can be a basic mechanisms of software evolution. In this paper, we present a simple architecture of a reflective language that can dynamically select meta-interpreters, and a dynamic compilation scheme by using run-time specialization (RTS) techniques, which could also be useful to dynamically optimize systems with mechanisms of dynamic software evolution. Our prototype system showed that dynamically compiled reflective programs run more than four times faster than the interpreted ones, and that compilation processes are fast enough to be invoked at runtime. Compared to statically compiled programs, however, dynamically compiled ones yet have 20-30\% overheads. We also discuss this problem.},
}

@InProceedings{oiwa2001ppl,
  author = 	 "Yutaka Oiwa and Hidehiko Masuhara and Akinori Yonezawa",
  title = 	 "{DynJava}: Type Safe Dynamic Code Generation in {Java}",
  url = 	 {http://ppl.jssst.or.jp/ppl2001/programme.html},
  booktitle = 	 "JSSST Workshop on Programming and Programming
		  Languages (PPL2001)",
  year = 	 2001,
  editor =	 "Kenjiro Taura and Jacuques Garrigue",
  pages =	 "127--138",
  organization = JSSST,
  month =	 mar,
  OPTnote =	 ""
}

@InProceedings{masuhara2001pado2,
  author = 	 "Hidehiko Masuhara and Akinori Yonezawa",
  title = 	 "Run-time Bytecode Specialization: A Portable
		  Approach to Generating Optimized Specialized Code", 
  crossref = 	 "pado2",
  pages =        "138--154",
  acceptanceRatio = "14/30 (47%)",
  note = 	 {An extended version appears as \cite{masuhara2001ngc}.},
  keywords = 	 {Java, bytecode, partial evaluation},
  pdf = 	 {pado2.pdf},
  abstract = 	 {This paper proposes a run-time bytecode specialization (BCS) technique that analyzes programs and generates specialized programs at run-time in an intermediate language. By using an intermediate language for code generation, a back-end system can optimize the specialized programs after specialization. As the intermediate language, the system uses Java virtual machine language (JVML), which allows the system to easily achieve practical portability and to use sophisticated just-in-time compilers as its back-end. The binding-time analysis algorithm, which is based on a type system, covers a non-object-oriented subset of JVML. A specializer, which generates programs on a per-instruction basis, can perform method inlining at run-time. The performance measurement showed that a non-trivial application program specialized at run-time by BCS runs approximately 3--4 times faster than the unspecialized one. Despite the large amount of overheads at JIT compilation of specialized code, we observed that the overall performance of the application can be improved.}
}

@InCollection{masuhara2001fmbook,
  author = 	 "Hidehiko Masuhara and Akinori Yonezawa",
  title = 	 "Reflection in Concurrent Object-Oriented Languages",
  booktitle = 	 "Formal Methods for Distributed Processing: An Object
		  Oriented Approach",
  publisher = 	 "Cambridge University Press",
  year = 	 2001,
  editor =	 "Howard Bowman and John Derrick",
  chapter =	 14,
  pages =	 "305--325",
  month = 	 oct,
  annote =	 "http://www.cs.ukc.ac.uk/people/staff/jd1/tc6book_web_faq",
  keywords = 	 {ABCL/R},
  isbn = 	 {9780521771849},
  url = 	 {https://www.cambridge.org/us/academic/subjects/computer-science/programming-languages-and-applied-logic/formal-methods-distributed-processing-survey-object-oriented-approaches}
}


@Article{masuhara2001ngc,
  author = 	 "Hidehiko Masuhara and Akinori Yonezawa",
  title = 	 "A Portable Approach to Dynamic Optimization in
		  Run-time Specialization", 
  journal = 	 "Journal of New Generation Computing",
  year = 	 2001,
  volume =	 20,
  url = 	 {https://link.springer.com/journal/354/20/1},
  doi = 	 {10.1007/BF03037261},
  number =	 1,
  pages =	 "101--124",
  pdf = 	 {ngc2001.pdf},
  month =	 nov,
  note =	 "Extended from \cite{masuhara2001pado2}.",
  keywords = 	 {Java, Bytecode, Just-in-time, partial evaluation},
  abstract = 	 {This paper proposes a run-time bytecode specialization (BCS) technique that analyzes programs and generates specialized programs at run-time in an intermediate language. By using an intermediate language for code generation, a back-end system can optimize the specialized programs after specialization. The system uses Java virtual machine language (JVML) as the intermediate language, which allows the system to easily achieve practical portability and to use existing sophisticated just-in-time (JIT) compilers as its back-end. The binding-time analysis algorithm is based on a type system, and covers a non-object-oriented subset of JVML. The specializer generates programs on a per-instruction basis, and can perform method inlining at run-time. Our performance measurements show that a non-trivial application program specialized at run-time by BCS runs approximately 3--4 times faster than the unspecialized one. Despite the large overhead of JIT compilation of specialized code, we observed that the overall performance of the application can be improved.}
}

Article{affeldt2001jssst,
  author = 	 "Reynald Affeldt and Hidehiko
		  Masuhara and Eijiro Sumii and Akinori Yonezawa",
  title = 	 "Supporting Objects in Run-time Bytecode Specialization",
  journal = 	 CompSoft,
  year = 	 "",
  OPTvolume = 	 "",
  OPTnumber = 	 "",
  OPTpages = 	 "",
  OPTmonth = 	 "",
  OPTnote = 	 "投稿中; rejected",
  OPTaffil = 	 "",
  OPTkeywords =  "",
  OPTserialNo =  "",
  OPTannote = 	 ""
}



Misc{imai2001oopsla-ptdoomws,
  author =	 "Takeo Imai and Tatsurou Sekiguchi and Hidehiko
		  Masuhara and Akinori Yonezawa",
  title =	 "Dynamic Access Control of Mobile Objects by
		  Switching Name Spaces",
  howpublished = "submitted for publication",
  year =	 2001,
  month =	 sep,
  annote =	 "OOPSLA2001 Workshop on Patterns and Techniques for
		  Designing Object-Oriented Mobile Wireless Systems"
}

@InProceedings{masuhara2002foal,
  note = 	 {revised version in \cite{masuhara2003cc}},
  author = 	 "Hidehiko Masuhara and Gregor Kiczales and Chris Dutchyn",
  title = 	 "Compilation Semantics of Aspect-Oriented Programs",
  booktitle =	 "FOAL 2002 Proceedings: Foundations Of Aspect-Oriented Languages, Workshop at AOSD 2002",
  pages =	 "17--25",
  url = 	 {http://www.eecs.ucf.edu/~leavens/FOAL/index-2002.html},
  year =	 2002,
  editor =	 "Gary T. Leavens and Ron Cytron",
  series =	 "Technical Report TR{\#}02--06, Department of Computer Science, Iowa State University",
  pdf = 	 {foal2002.pdf},
  month =	 apr,
  keywords = 	 {AspectJ, Scheme, Aspect sandbox},
  abstract = 	 {This paper presents a semantics-based compilation framework for an aspect-oriented programming language based on its operational semantics model. Using partial evaluation, the framework can explain several issues in compilation processes, including how to find places in program text to insert aspect code and how to remove unnecessary run-time checks. It also illustrates optimization of calling-context sensitive pointcuts (cflow), implemented in real compilers.}
}

@Misc{kiczales2002aosd-tutorial,
  author =	 "Chirs Dutchyn and Gregor Kiczales and Hidehiko Masuhara",
  title =	 "{AOP} Language Exploration Using the Aspect Sand Box",
  url = 	 {https://modularity.info/conference/2002/sandbox.html},
  howpublished = "Tutorial on 1st International Conference on
		  Aspect-Oriented Software Development (AOSD 2002)",
  year =	 2002,
  month =	 apr,
  keywords = 	 {AspectJ, Scheme}
}

@InProceedings{affeldt2002asiapepm,
  author =	 "Reynald Affeldt and Hidehiko Masuhara and Eijiro Sumii and Akinori Yonezawa",
  OPTurl = 	 {asia-pepm2002.ps.gz},
  pdf = 	 {asia-pepm2002.pdf},
  title =	 "Supporting Objects in Run-time Bytecode Specialization",
  doi = 	 {10.1145/568173.568179},
  booktitle = 	 {ACM SIGPLAN ASIAN Symposium on Partial Evaluation and Semantics-Based Program Manipulation (ASIA-PEPM'02)},
  OPTcrossref =	 {?},
  pages =	 {50--60},
  year =	 2002,
  editor =	 {Wei-Ngan Chin},
  OPTvolume =	 {?},
  OPTnumber =	 {?},
  OPTseries =	 {?},
  publisher =    {ACM Press},
  address =	 {Aizu, Japan},
  month =	 sep,
  keywords = 	 {Java, just-in-time compiler},
  abstract = 	 {This paper describes a run-time specialization system for the Java language. One of the main difficulties of supporting the full Java language resides in a sound yet effective management of references to objects. This is because the specialization process may share references with the running application that executes the residual code, and because side-effects through those references by the specialization process could easily break the semantics of the running application. To cope with these difficulties, we elaborate requirements that ensure sound run-time specialization. Based on them, we design and implement a run-time specialization system for the Java language, which exhibits, for instance, approximately 20-25\% speed-up factor for a ray-tracing application.}
}

@Misc{aspectsandbox,
  author =	 "Chris Dutchyn and Gregor Kiczales and Hidehiko Masuhara",
  title =	 "Aspect SandBox",
  howpublished = "project homepage at http://www.cs.ubc.ca/labs/spl/projects/asb.html",
  year =	 2002,
  month =	 oct,
  keywords = 	 {AspectJ, Scheme}
}

@InProceedings{masuhara2003ecoop,
  pdf = 	 {ecoop2003.pdf},
  slides = 	 {ecoop2003-slides.pdf},
  OPTslides = 	 {ecoop2003-slides.pps},
  author =	 "Hidehiko Masuhara and Gregor Kiczales",
  title =	 "Modeling Crosscutting in Aspect-Oriented Mechanisms",
  booktitle = 	 "Proceedings of European Conference on
		  Object-Oriented Programming (ECOOP2003)",
  url = 	 {https://web.archive.org/web/20080315032348/http://www.st.informatik.tu-darmstadt.de:8080/ecoop/index.phtml},
  doi = 	 {10.1007/978-3-540-45070-2_2},
  year = 	 2003,
  editor =	 "Luca Cardelli",
  volume =	 2743,
  series =	 "Lecture Notes in Computer Science",
  pages =	 "2--28",
  publisher =	 "Springer-Verlag",
  address =	 "Darmstadt, Germany",
  month =	 jul,
  acceptanceRatio = "18/88 (20%)",
  keywords = 	 {AspectJ, Aspect sandbox, Scheme},
  abstract = 	 {Modeling four aspect-oriented programming mechanisms shows the way in which each supports modular crosscutting. Comparing the models produces a clear three part characterization of what is required to support crosscutting structure: a common frame of reference that two (or more) programs can use to connect with each other and each provide their semantic contribution.}
}

Misc{masuhara2002draft2,
  author =	 "Hidehiko Masuhara and Gregor Kiczales and Chris Dutchyn",
  title =	 "A Compilation and Optimization Model for Aspect-Oriented Programs",
  howpublished = "to appear in CC2003",
  keywords = 	 {AspectJ, Aspect sandbox, Scheme}
}

@InProceedings{masuhara2003cc,
  author = 	 {Hidehiko Masuhara and Gregor Kiczales and Chris Dutchyn},
  pdf = 	 {cc2003.pdf},
  title = 	 {A Compilation and Optimization Model for Aspect-Oriented Programs},
  booktitle = 	 {Proceedings of 12th International Conference on Compiler Construction (CC2003)},
  doi = 	 {10.1007/3-540-36579-6_4},
  url = 	 {http://fileadmin.cs.lth.se/cs/Personal/Gorel_Hedin/cc03/},
  pages =	 {46--60},
  year =	 2003,
  volume =	 2622,
  series =	 LNCS,
  annote =	 {http://link.springer.de/link/service/series/0558/tocs/t2622.htm},
  acceptanceRatio = {21/83 (25%)},
  keywords = 	 {AspectJ, Aspect sandbox, Scheme},
  abstract = 	 {This paper presents a semantics-based compilation model for an aspect-oriented programming language based on its operational semantics. Using partial evaluation, the model can explain several issues in compilation processes, including how to find places in program text to insert aspect code and how to remove unnecessary run-time checks. It also illustrates optimization of calling-context sensitive pointcuts (cflow), implemented in real compilers.}
}

Misc{masuhara2003submitted,
  author =	 "Hidehiko Masuhara and Kazunori Kawauchi",
  title =	 "Dataflow Pointcut in Aspect-Oriented Programming",
  howpublished = "submitted for publication; to appear as \cite{masuhara2003aplas}",
  year =	 2003,
  month =	 jul,
  keywords = 	 {AspectJ, dflow}
}

@InProceedings{masuhara2003aplas,
  pdf = 	 {aplas2003.pdf},
  slides = 	 {aplas2003-talk.pdf},
  author = 	 {Hidehiko Masuhara and Kazunori Kawauchi},
  title = 	 {Dataflow Pointcut in Aspect-Oriented Programming},
  doi = 	 {10.1007/978-3-540-40018-9_8},
  booktitle = 	 {Proceedings of The First Asian Symposium on Programming Languages and Systems (APLAS'03)},
  pages =	 {105--121},
  year =	 2003,
  editor =	 {Atsushi Ohori},
  volume =	 {2895},
  series =	 LNCS,
  address =	 {Beijing, China},
  month =	 nov,
  acceptanceRatio = {24/76 (32%)},
  keywords = 	 {AspectJ, dflow},
  abstract = 	 {A dataflow-based pointcut is proposed for aspect-oriented programming (AOP) languages. The pointcut specifies where aspects should be applied based on the origins of values. It is designed to be compatible with the other kinds of pointcuts in existing AOP languages. Primary application fields of the pointcut are the aspects in which flow of information is important, such as security. This paper presents the design of the pointcut with a web-application example, and its prototype implementation.}
}

@InProceedings{sakurai2004aosd,
  author = 	 "Kouhei Sakurai and Hidehiko Masuhara and Naoyasu
		  Ubayashi and Saeko Matsuura and Seiichi Komiya",
  title = 	 "Association Aspects",
  doi = 	 {10.1145/976270.976275},
  crossref =     "aosd2004",
  pages =	 "16--25",
  month =	 mar, 
  acceptanceRatio = {18% (15/83)},
  keywords = 	 {AspectJ},
  pdf = 	 {aosd2004.pdf},
  abstract = 	 {We propose a linguistic mechanism for AspectJ-like languages that concisely associates aspect instances to object groups. The mechanism, which supports association aspects, extends the per-object aspects in AspectJ by allowing an aspect instance to be associated to a group of objects, and by providing a new pointcut primitive to specify aspect instances as execution contexts of advice. With association aspects, we can straightforwardly implement crosscutting concerns that have stateful behavior related to a particular group of objects. The new pointcut primitive can more flexibly specify aspect instances when compared against previous implicit mechanisms. The comparison of execution times between the programs with association aspects and the ones with regular AspectJ aspects revealed that the association aspects exhibited almost equivalent for the medium-sized configurations.}
}

@InProceedings{kawauchi2004aosdsec,
  author = 	 "Kazunori Kawauchi and Hidehiko Masuhara",
  title = 	 "Dataflow Pointcut for Integrity Concerns",
  pdf = 	 {aosdsec2004.pdf},
  booktitle = 	 "Proceedings of AOSD Technology for Application-level Security (AOSDSEC'04)",
  year = 	 2004,
  address =	 "Lancaster, UK",
  month =	 mar,
  url =	 "https://web.archive.org/web/20050906081308/http://www.aosd.net:80/workshops/aosdsec/2004/",
  keywords = 	 {AspectJ, dflow},
  abstract = 	 {Some security concerns, such as secrecy and integrity, are sensitive to flow of information in a program execution. We proposed a new pointcut to aspect-oriented programming (AOP) languages in order to easily implement such security concerns as aspects. The pointcut identifies join points based on the origins of values, and can be used with the other kinds of pointcuts in existing AOP languages. This paper presents an example how the pointcut can be applied to an integrity concern in a web-application.}
}

@InProceedings{ubayashi2004ramse,
  author = 	 {Naoyasu Ubayashi and Hidehiko Masuhara and Tetsuo Tamai},
  title = 	 {An {AOP} Implementation Framework for Extending Join Point Models},
  pdf = 	 {ramse2004.pdf},
  booktitle =	 {ECOOP2004 Workshop on Reflection, AOP and Meta-Data for Software Evolution (RAM-SE'04)},
  pages =	 {71--81},
  year =	 2004,
  address =	 {Oslo, Norway},
  month =	 Jun,
  url =	 {https://dblp.org/db/conf/ecoop/ramse2004},
  abstract = 	 {Mechanisms in AOP (aspect-oriented programming) can be characterized by a JPM (join point model). AOP is effective in unanticipated software evolution because crosscutting concerns can be added or removed without making invasive modifications on original programs. However, the effectiveness would be restricted if new crosscutting concerns cannot be described with existing JPMs. Mechanisms for extending JPMs are needed in order to address the problem. In this paper, an implementation framework for extending JPMs is proposed. Using the framework, we can introduce new kinds of JPMs or extend existing JPMs in the process of software evolution.},
}

@InProceedings{kamio2004wnasc,
  pdf = 	 {wnasc2004.pdf},
  author = 	 "Takahiro Kamio and Hidehiko Masuhara",
  title = 	 "A Value Profiler for Assisting Object-Oriented
		  Program Specialization", 
  booktitle = 	 "Proceedings of Workshop on New Approaches to
		  Software Construction (WNASC 2004)",
  year = 	 2004,
  pages =        "95--102",
  editor =	 "Tetsuo Tamai",
  address =	 "Tokyo",
  month =	 sep,
  keywords = 	 {ASpectJ},
  abstract = 	 {We present a value profiler for object-oriented programs that counts frequencies parameters to method calls. It is aimed at identifying methods that can be optimized by program specialization techniques. By adding timestamps to objects, the profiler accurately tests equality over mutable objects on a per-method basis. Our experiments with a 64602 lines of Java program showed that the profile report can reduce effort at manually finding the target methods of optimization, which speeded the overall execution time up more than 10\%.}
}

@InProceedings{tatsuzawa2005foal,
  author = 	 {Hideaki Tatsuzawa and Hidehiko Masuhara and Akinori Yonezawa},
  title = 	 {{A}spectual {C}aml: an Aspect-Oriented Functional Language},
  crossref =	 {foal2005},
  pdf = 	 {foal2005.pdf},
  note =	 {An extended version appears as \cite{masuhara2005icfp}.},
  pages =        {39--50},
  keywords = 	 {OCaml},
  abstract = 	 {We propose an aspect-oriented programming (AOP) language called Aspectual Caml based on a strongly-typed functional language Objective Caml. Aspectual Caml offers two AOP mechanisms, namely the pointcut and advice mechanism and the type extension mechanism, which gives similar functionality to the inter-type declarations in AspectJ. Those mechanisms are not simple adaptation of the similar mechanisms in existing AOP languages, but re-designed for common programming styles in functional languages such as type inference, polymorphic types, and curried functions. We implemented a prototype compiler of the language and used the language for separating crosscutting concerns in application programs, including separating a type system from a compiler of a simple language.}
}

@InProceedings{aotani2005splat,
  author = 	 {Tomoyuki Aotani and Hidehiko Masuhara},
  title = 	 {Compiling Conditional Pointcuts for User-Level Semantic Pointcuts},
  pdf = 	 {splat2005.pdf},
  crossref =	 {splat2005},
  keywords = 	 {SCoPE, AspectJ},
  abstract = 	 {We propose a compilation framework that compiles conditional pointcuts (i.e., if pointcuts) in AspectJ for allowing the programmer to define expressive pointcuts without runtime overheads. The framework automatically finds conditional pointcuts that are static with respect to join point shadows, evaluates them at compile-time, and generates compiled code that performs no runtime tests for those pointcuts. By writing conditions that examine static properties of a program, the programmer can simulate many semantic pointcuts within current AspectJ's semantics yet without runtime overheads. Our compiler implementation identifies static conditional pointcuts by using a technique similar to the binding-time analysis in partial evaluation, and employs double-compilation scheme to guarantee the same behavior to the code generated by the existing AspectJ compilers. Our experiments confirmed that the compiler is capable of compiling several semantic pointcuts, such as the ones testing class membership (e.g., has and hasfield), testing join point location (e.g., withinstaticinitialization), matching by using regular expressions, and checking high-level coding rules (e.g., the Law of Demeter).}
}

@InProceedings{yamazaki2005wtaop,
  author = 	 "Yudai Yamazaki and Kouhei Sakurai and Saeko Matsuura
		  and Hidehiko Masuhara and Hiroaki Hashiura and
		  Seiichi Komiya",
  pdf = 	 {wtaop2005.pdf},
  title = 	 "A Unit Testing Framework for Aspects without Weaving",
  booktitle = 	 "Proceedings of Workshop on Testing Aspect-Oriented Programs (WTAOP'05)",
  year = 	 2005,
  editor =	 "Roger T. Alexander and Anneliese A. Andrews",
  address =	 "Chicago, IL",
  month =	 mar,
  OPTurl =	 "http://www.sic.shibaura-it.ac.jp/~m105108/aspect/WTAOP/paper.pdf",
  keywords = 	 {AspectJ},
  abstract = 	 {Unit testing of aspects can verify aspects implementations of aspects against their specification. Current technique for unit testing of aspects requires to weave the aspect definition into a target program, which thus makes it difficult to write comprehensive test cases and to avoid interference from other aspects. In this paper, we propose a framework for unit testing aspects without weaving. Our framework generates testing methods from an aspect definition so that test cases can directly verify properties of aspects such as the advice behavior and pointcut matching.}
}

@InProceedings{masuhara2005icfp,
  pdf = 	 {icfp2005.pdf},
  url = 	 {https://www.icfpconference.org/archived/icfp2005/www.brics.dk/~danvy/icfp05/},
  slides = 	 {icfp2005-slides.pdf},
  author = 	 {Hidehiko Masuhara and Hideaki Tatsuzawa and Akinori Yonezawa},
  title = 	 {{A}spectual {C}aml: an Aspect-Oriented Functional Language},
  note = 	 {Extended from \cite{tatsuzawa2005foal}.},
  crossref =  {icfp2005},
  pages =	 {320--330},
  acceptanceRatio = {33% (26/78)},
  keywords = 	 {OCaml},
  abstract = 	 {We propose an aspect-oriented programming (AOP) language called Aspectual Caml based on a strongly-typed functional language Objective Caml with two AOP mechanisms similar to those in AspectJ language. This paper describes the design and implementation issues of those AOP mechanisms that give us insights into the interaction between AOP features and common features in strongly-typed functional languages such as type inference, polymorphic types and curried functions. We implemented a prototype compiler of the language and used the language for separating crosscutting concerns in application programs, including for separating descriptions of a type system from compiler descriptions.}
}

@InProceedings{ubayashi2005ase,
  author = 	 {Naoyasu Ubayashi and Hidehiko Masuhara and Tetsuo Tamai},
  title = 	 {A Parameterized Interpreter for Modeling Different {AOP} Mechanisms},
  pdf = 	 {ase2005.pdf},
  booktitle = 	 {2005 IEEE/ACM International Conference on Automated Software Engineering (ASE 2005)},
  OPTcrossref =  {},
  OPTkey = 	 {},
  OPTpages = 	 {194--203},
  year = 	 2005,
  OPTeditor = 	 {},
  OPTvolume = 	 {},
  OPTnumber = 	 {},
  OPTseries = 	 {},
  OPTaddress = 	 {},
  month = 	 nov,
  OPTorganization = {IEEE/ACM},
  OPTpublisher = {},
  OPTannote = 	 {},
  acceptanceRatio = {9.6% (28/291) for full papers},
  abstract = 	 {We present a parameterized interpreter for modeling aspect-oriented mechanisms. The interpreter takes several param- eters to cover different AOP mechanisms found in AspectJ, Hyper/J, and Demeter. The interpreter helps our understanding of the AOP mechanisms in two ways. First, its core part represents the common mechanical structure shared by different AOP mechanisms. Second, by reconstructing the existing AOP mechanisms and using parameters to configure the interpreter, we can illustrate the differences and similarities of those mechanisms clearly. This will also be helpful in rapid-prototyping a new AOP mechanism or a reflective AOP system that supports different mechanisms.}

}

@InProceedings{endo2005wnasc,
  author = 	 "Yusuke Endoh and Hidehiko Masuhara and Akinori Yonezawa",
  title = 	 "Is Join Point a Point?: a pointcut and advice mechanism 
for making aspects more reusable",
  pdf = 	 {wnasc2005.pdf},
  slides = 	 {wnasc2005-slides.pdf},
  booktitle = 	 "Proceedings of Workshop on New Approaches
		  to Software Construction (WNASC 2005)",
  year = 	 2005,
  editor =	 "Tetsuo Tamai",
  pages =	 "93--98",
  month =	 sep,
  keywords = 	 {AspectJ, continuation}
}

@Article{sakurai2006taosd,
  author = 	 "Kouhei Sakurai and Hidehiko Masuhara and Naoyasu
		  Ubayashi and Saeko Matsuura and Seiichi Komiya",
  pdf = 	 {taosd2006.pdf},
  title = 	 "Design and Implementation of An Aspect Instantiation Mechanism", 
  year = 	 2006,
  editor =	 "Awais Rashid and Mehmet Ak\c{s}it",
  pages =	 "259--292",
  journal = 	 TAOSD,
  volume =	 {3880/2006},
  note =	 {Extended from \cite{sakurai2004aosd}.},
  doi =          {10.1007/11687061_8},
  keywords = 	 {AspectJ},
  abstract = 	 {This paper describes the design and implementation of association aspects, which are a linguistic mechanism for the AspectJ language that concisely associates aspect instances to object groups by extending the per-object aspects in AspectJ. This mechanism allows an aspect instance to be associated to a group of objects, and by providing a new pointcut primitive to specify aspect instances as execution context of advice. With association aspects, we can straightforwardly implement crosscutting concerns that have stateful behavior related to a particular group of objects. The new pointcut primitive can more flexibly specify aspect instances when compared against previous implicit mechanisms. We implemented a compiler for association aspects by modifying the AspectJ compiler, which reduces the size of data structures for keeping associations. Our benchmark tests confirm that the overheads of association aspects are reasonably small when compared against functionally equivalent aspects in pure AspectJ that manually manage associations. The expressiveness of association aspects is demonstrated through development of an integrated development environment with and without association aspects.}
}

@Misc{masuhara2005asian-aosd,
  author =	 {Hidehiko Masuhara},
  title =	 {Pointcut \& Advice Mechanism and Types: the case of {Aspectual Caml}},
  howpublished = {Talk at the First Asian Workshop on Aspect-Oriented Software Development},
  month =	 dec,
  year =	 2005,
  url = 	 {https://sites.google.com/site/aoasiaworkshop/aoasia-2005},
  annote =	 {A pedagogical talk},
  keywords = 	 {OCaml}
}

@InProceedings{endoh2006foal,
  author = 	 {Yusuke Endoh and Hidehiko Masuhara and Akinori Yonezawa},
  pdf = 	 {foal2006.pdf},
  title = 	 {Continuation Join Points},
  booktitle = 	 {Proceedings Foundations of Aspect-Oriented Languages
Workshop (FOAL 2006) at AOSD 2006},
  pages =	 {1--10},
  year =	 2006,
  editor =	 {Curtis Clifton and Ralf L\"ammel and Gary T. Leavens},
  volume =	 {TR {\#}06-01},
  series =	 {Technical Report, Department of Computer Science, Iowa State University},
  month =	 mar,
  acceptanceRatio = {47% (7/15) for long+short papers},
  keywords = 	 {AspectJ},
  abstract = 	 {In AspectJ-like languages, there are several different kinds of advice declarations, which are specified by using advice modifiers such as before and after returning. This makes semantics of advice complicated and also makes advice declarations less reusable since advice modifiers are not param- eterized unlike pointcuts. We propose a simpler join point model and an experimental AOP language called PitJ. The proposed join point model has only one kind of advice, but has finer grained join points. Even though we unified different kinds of advice into one, the resulted language is sufficiently expressive to cover typical advice usages in AspectJ, and has improved advice reusability by allowing pointcuts, rather than advice modifiers, to specify when advice body runs. Along with the language design, this paper gives a formalization of the join point model in a continuation-passing style (CPS).}
}

@misc{hanemann2006diku-ist,
  author = 	 "Jan Hannemann and Hidehiko Masuhara",
  title = 	 "Aspect Mining using Structural Program Properties",
  howpublished = 	 "A talk at The Second DIKU-IST Joint Workshop on Foundations of Software",
  year = 	 2006,
  address =	 "Kanagawa, Japan",
  month =	 apr,
  date = "2006-4-22",
  OPTnote =	 "a talk",
  keywords = 	 {AspectJ}
}

@InProceedings{masuhara2006adi,
  pdf = 	 {adi06.pdf},
  author = 	 masuhara # AND # aotani,
  title = 	 "Issues on Observing Aspect Effects from Expressive Pointcuts",
  booktitle = 	 "Proceedings of Workshop on Aspects, Dependencies and Interactions (ADI'06)",
  year = 	 2006,
  series =	 "Technical Report COMP-001-2006, Lancaster University Computing Department",
  pages =	 "53--61",
  month =	 jul,
  keywords = 	 {AspectJ},
  abstract = 	 {This paper discusses issues on interactions of aspects with expressive pointcuts. Since expressive pointcuts specify join points based on the results of program analysis, they should be carefully designed in order to analyze effects of aspects and their precedence correctly. We show examples in which aspects with expressive pointcuts interact, and point out the required properties to those pointcuts for correct aspect interaction. We also briefly present our approach to satisfy those properties in our SCoPE compiler, which supports expressive pointcuts within AspectJ language.}
}

@InProceedings{masuhara2006aplas,
  author = 	 masuhara # AND # "Yusuke Endoh and Akinori Yonezawa",
  pdf = 	 {aplas2006.pdf},
  title = 	 "A Fine-Grained Join Point Model for More Reusable Aspects",
  pages =	 "131--147",
  crossref = {aplas2006},
  doi = 	 "10.1007/11924661_8",
  OPTurl = "10.1007/11924661_8",
  acceptanceRatio = {31% (22/70)},
  keywords = 	 {AspectJ, continuation},
  abstract = 	 {We propose a new join point model for aspect-oriented programming (AOP) languages. In most AOP languages including AspectJ, a join point is a time interval of an action in execution. While those languages are widely accepted, they have problems in aspects reusability, and awkwardness when designing advanced features such as tracematches. Our proposed join point model, namely the point-in-time join point model redefines join points as the moments both at the beginning and end of actions. Those finer-grained join points enable us to design AOP languages with better reusability and flexibility of aspects. In this paper, we designed an AspectJ-like language based on the point-in-time model. We also give a denotational semantics of a simplified language in a continuation passing style, and demonstrate that we can straightforwardly model advanced language features such as exception handling and cflow pointcuts.} 
}

@InProceedings{aotani2007aosd,
  author = 	 aotani # AND # masuhara,
  pdf = 	 {aosd2007.pdf},
  title = 	 "{SCoPE}: an {AspectJ} Compiler for Supporting User-Defined Analysis-Based Pointcuts",
  crossref = 	 "aosd2007",
  pages =	 "161--172",
  doi = "10.1145/1218563.1218582",
  abstract = 	 {This paper proposes an approach called SCoPE, which supports user-defined analysis-based pointcuts in aspect-oriented programming (AOP) languages. The advantage of our approach is better integration with existing AOP languages than previous approaches. Instead of extending the language, SCoPE allows the programmer to write a pointcut that analyzes a program by using a conditional (if) pointcut with introspective reflection libraries. A compilation scheme automatically eliminates runtime tests for such a pointcut. The approach also makes effects of aspects visible to the analysis, which is essential for determining proper aspect interactions. We implemented a SCoPE compiler for the AspectJ language on top of the AspectBench compiler using a backpatching technique. The implementation efficiently finds analysis-based pointcuts, and generates woven code without runtime tests for those pointcuts. Our benchmark tests with JHotDraw and other programs showed that SCoPE compiles programs with less than 1\% compile-time overhead, and generates a program that is as efficient as an equivalent program that uses merely static pointcuts.},
}

@InProceedings{aotani2007foal,
  pdf = 	 {foal2007.pdf},
  author = 	 aotani # AND # masuhara,
  title = 	 "Towards A Type System for Rejecting Never-Matching Pointcut Compositions",
  url = 	 {http://www.eecs.ucf.edu/~leavens/FOAL/index-2007.shtml},
  crossref = 	 "foal2007",
  pages =	 "23--26",
  keywords = 	 {AspectJ},
  abstract = 	 {Pointcuts in the current AspectJ family of languages are loosely checked because the languages allow compositions of pointcuts that never match any join points, which developers are unlikely to intend, for example, \verb|set(* *)&&get(* *)|. We formalize the problem by defining well-formedness of pointcuts and design a novel type system for assuring well-formedness. The type of pointcuts is encoded by using record, union and the bottom types.}
}

@InProceedings{sakurai2007late,
  author = 	 sakurai # AND # masuhara,
  title = 	 "Test-based Pointcuts: A Robust Pointcut Mechanism Based on Unit Test Cases for Software Evolution",
  crossref = 	 "late2007",
  keywords = 	 {AspectJ},
  pdf = 	 {late2007.pdf},
  abstract = 	 {This paper proposes test-based pointcuts, a new aspect-oriented
programming language construct that uses unit test cases as interface of crosscutting concerns. A test-based pointcut primarily specifies a set of test cases associated to a program. At execution time, it matches the join points that have the same execution history to the one of the specified test cases. The test-based approach improves pointcut definitions in two respects. First, test-based pointcuts are less fragile with respect to program changes because rather than directly relying on type and operation names in a program, they indirectly specify join points through unit test cases, which are easier to be kept up-to-date. Second, test-based pointcuts can discriminate execution histories without requiring to specify detailed execution steps, as they use test cases as abstractions of execution histories. With the abstractions, the second respect contributes to the first respect. We designed and implemented the test-based pointcuts as an extension to AspectJ, and confirmed, through an case study, test-based pointcuts are more robust against evolution when used for a practical application program.}
}

@Misc{masuhara2007aplas-poster,
  author = masuhara,
  title = "Relaxing Type Restrictions of Around Advice in Aspect-Oriented Programming",
  howpublished = "Poster presentation at APLAS 2007",
  crossref = "aplas2007",
  poster = 	 {aplas2007poster.pdf},
  note = "poster presentation",
  keywords = 	 {AspectJ},
  pdf = 	 {aplas2007abstract.pdf}
}

@Misc{masuhara2008msra-nlp-poster,
  author =	 masuhara # AND # watanabe,
  title =	 {Spontaneous Source Code Recommendation Tool based on Text Search Techniques},
  howpublished = {Poster presentation at Microsoft Research Asia (MSRA) Regional Workshop on Web-Scale Natural Language Processing },
  month =	 feb,
  year =	 2008,
  pdf = 	 {msranlp2008.pdf},
  location={Daedeok, Korea},
  keywords = 	 {Selene, Eclipse}
}

@InProceedings{sakurai2008aosd,
  author = 	 sakurai # AND # masuhara,
  pdf = 	 {aosd2008.pdf},
  title = 	 "Test-Based Pointcuts for Robust and Fine-Grained Join Point Specification",
  crossref = 	 "aosd2008",
  pages = {96--107},
  doi= {10.1145/1353482.1353494},
  keywords = 	 {AspectJ},
  abstract = 	 {We propose test-based pointcuts, a novel pointcut mechanism for AspectJ-like aspect-oriented programming languages. The idea behind the test-based pointcuts is to specify join points through unit test cases associated with the target program. The test-based pointcuts improve robustness and precision of pointcut languages. The test-based pointcuts are more robust against software evolution because they do not directly rely on identifier names in a target program. The test-based pointcuts are more precise because they can distinguish fine grained execution histories including conditional branches by comparing the runtime execution histories with recorded for ones of the unit test cases. This paper presents design and implementation of the test-based pointcuts as an extension of an AspectJ compiler. We evaluated robustness and runtime efficiency of test-based pointcuts through case studies that applied test-based pointcuts to several versions of practical application programs.}
}

@Misc{aotani2008aosd-poster,
  author =	 aotani # AND # masuhara,
  title =	 {{SCoPE}: an {AspectJ} compiler for developing intuitive and robust aspects by using program analysis},
  howpublished = {Poster presentation at AOSD.08},
  month =	 apr,
  year =	 2008,
  date = {2008-4-1}
}

@InProceedings{masuhara2008adi,
  author = 	 masuhara,
  title = 	 {On Type Restriction of Around Advice and Aspect Interference},
  booktitle =	 {Proceedings of the 3rd International Workshop on Aspects, Dependencies and Interactions (ADI'08)},
  year =	 2008,
  location = 	 {Paphos, Cyprus},
  month =	 jul,
  url =	 {https://web.archive.org/web/20080723204002/http://gateway.comp.lancs.ac.uk/computing/aosd-europe//adi08},
  pdf = 	 {adi2008.pdf},
  keywords = 	 {AspectJ},
  abstract = 	 {Statically typed AOP languages restrict application of around advice only to the join points that have conforming types. Though the restriction guarantees type safety, it can prohibit application of advice that is useful, yet does not cause runtime type errors. To this problem, we present a novel weaving mechanism, called the type relaxed weaving, that allows such advice applications while preserving type safety. This paper discusses language design issues to support the type relaxed weaving in AOP languages.}
}

@Misc{masuhara2008ramse,
  author =	 masuhara,
  title =	 {Towards Right Abstraction Mechanisms for Crosscutting Concerns},
  howpublished = {Workshop on
Reflection, AOP and Meta-Data for Software Evolution (RAM-SE'08)},
  month =	 jul,
  year =	 2008,
  note = 	 {Keynote talk},
  pdf = 	 {ramse2008.pdf},
  keywords = 	 {AspectJ},
  url =	 {http://homes.dico.unimi.it/~cazzola/RAM-SE08.html},
  date = {2008-7-7}
}



@Misc{masuhara2008grace,
  author = 	 masuhara,
  title = 	 {An Abstraction Mechanism for Aspect-Oriented Programming Based on Test Cases''},
  url = 	 {http://grace-center.jp/2008/12/2173},
  howpublished = {Talk at the 12th GRACE Seminar},
  month = 	 dec,
  year = 	 2008,
  slides = 	 {grace-seminar-dec-2008.pdf},
  location = 	 {National Instutite of Informatics}}

@Misc{aotani2009aosd-poster,
  author = 	 aotani # AND # masuhara,
  title = 	 {Optimizing Dynamic Pointcuts by using {SCoPE}},
  howpublished = {Poster presentation at AOSD.09},
  keywords = 	 {AspectJ, Java},
  month = 	 mar,
  year = 	 2009}

Misc{marletta2009ramse,
  author = 	 {Daniele Marletta} # AND # masuhara # AND # {Emiliano Tramontana},
  title = 	 {Finding Scattered Code on {Globus} Toolkit},
  howpublished = {submitted to RAM-SE'09 (rejected)},
  month = 	 may,
  year = 	 2009,
  abstract =     {Currently, research efforts aim at identifying whether a
                  concern is scattered among modules implementing some
                  existing software systems.  This paper investigates
                  the scattered code within the implementation of
                  Globus Toolkit, the widespread middleware providing
                  support for Grid computing.  The core
                  functionalities of Globus Toolkit are implemented as
                  a big number of C source files.  The analysis of
                  Globus Toolkit has shown that calls to functions
                  handling output, errors, synchronisation and memory
                  have the highest values of fan-in and are the most
                  scattered.}
}


@InProceedings{appeltauer2009cop,
  author = 	 {Malte Appeltauer and Robert Hirschfeld} # AND # masuhara,
  title = 	 {Improving the Development of
                  Context-dependent {Java} Applications},
  booktitle = {Proceedings of the Intenational workshop on
                  Context-Oriented Programming (COP'09)},
  pages = 	 {article no.~5},
  doi = 	 {10.1145/1562112.1562117},
  pdf = 	 {cop2009.pdf},
  year = 	 2009,
  address = 	 {Genoa, Italy},
  month = 	 {7 } # jul,
  abstract =     {Context-oriented programming languages ease the
                  design and implementation of context-dependent
                  applications.  ContextJ is a context-oriented
                  extension to the Java programming language. In this
                  paper, we assess the applicability of ContextJ
                  language abstractions for the development of a
                  graphical user interface-based application. We
                  present a text editor that has been implemented with
                  ContextJ based on the Qt Jambi framework and discuss
                  possible extensions to ContextJ to improve its
                  applicability.}
}

@Misc{masuhara2009tsle,
  author = 	 {Hidehiko Masuhara},
  title = 	 {Can we use {AOP} for patching?: A weakness in
                  {AspectJ}'s type system and a remedy},
  howpublished = {Talk at the Workshop on Trade-offs in Software
                  Language Engineering, University of Twente, the Netherlands},
  month = 	 jun # { 11},
  year = 	 2009,
  location = 	 {University of Twente, the Netherlands},
  abstract = 	 {Whether you like or not, one of the typical usages
                  of AOP is to tentatively modify program's behavior
                  in order to fix a bug, to quickly add a new feature,
                  to simulate different execution environment, and so
                  on.  This talk illustrates a weakness in AspectJ's
                  type system for such purposes, which is too
                  restrictive about types of the around advice.  We
                  then propose an AspectJ compiler that has a more
                  relaxed type system without compromising type
                  safety.}
}

@InProceedings{appeltauer2009jssst,
  pdf = 	 {jssst2009.pdf},
  author = 	 {Malte Appeltauer and Robert Hirschfeld and  Michael Haupt and Hidehiko Masuhara},
  url = 	 {https://ipl.cs.uec.ac.jp/jssst2009/},
  title = 	 {{ContextJ}: Context-Oriented Programming with {Java}},
  note = 	 {Full paper veresion is published as \cite{appeltauer2011compsoft}},
  crossref =  {jssst2009},
  pages = 	 {2D-1},
  month = 	 sep # { 16},
  abstract = 	 {Context-oriented programming (COP) allows for the modularization of context-dependent behavioral variations. So far, COP has been implemented for dynamically-typed languages such as Lisp, Smalltalk, Python, and Ruby relying on reflection mechanisms, and for the statically-typed programming language Java based on a library and a pre-processor. ContextJ is our COP implementation for Java. It properly integrates COP's layer concept into the Java type system. ContextJ is compiler-based. As confirmed by a benchmark and a case study, it provides both better performance and higher-level abstraction mechanisms than its Java-based predecessors. In this paper, we present the ContextJ language and explain its constructs and semantics. Further, we give an overview of the implementation of our compiler and discuss run-time benchmarks.},
  }

@InProceedings{aotani2009aoasia,
  author = 	 aotani # and # masuhara,
  title = 	 {A Join Point Model for Implicit Conversion},
  booktitle = {Proceedings of the 5th Asian Workshop on
                  Aspect-Oriented Softawer Development (AOAsia 5)},
  url = 	 {https://appsrv.cse.cuhk.edu.hk/~aoasia/workshop/ASE09/index.html},
  year = 	 2009,
  month = 	 nov # { 17},
  location = 	 {Auckland, New Zealand},
  note = 	 {Position paper}}

@InProceedings{masuhara2010aosd,
  pdf = 	 {aosd2010.pdf},
  author = 	 masuhara # and # igarashi # and # touyama,
  doi = 	 {10.1145/1739230.1739245},
  title = 	 {Type Relaxed Weaving},
  crossref =  {aosd2010},
  pages = 	 {121--132},
  acceptanceRatio = {29% (18/62)},
  month = 	 mar # { 18},
  keywords = 	 {AspectJ},
  OPTnote = 	 {extended version http://www.graco.c.u-tokyo.ac.jp/ppp/index.php?plugin=attach&refer=Projects%2Ftyperelaxedweaving.ja&openfile=trw-full.pdf},
  abstract = 	 {Statically typed aspect-oriented programming languages restrict application of around advice only to the join points that have conforming types. Though the restriction guarantees type safety, it can prohibit application of advice that is useful, yet does not cause runtime type errors. To this problem, we present a novel weaving mechanism, called the type relaxed weaving, that allows such advice applications while preserving type safety. We formalized the mechanism, and implemented as an AspectJ compatible compiler, called RelaxAJ.}
}

@InProceedings{fanyang2010acp4is,
  pdf = 	 {acp4is2010.pdf},
  author = 	 fanyang # and # masuhara # and # aotani # and # "Flemming Nielson" # and # "Hanne Riis Nielson",
  title = 	 {{AspectKE*}: Security Aspects with Program Analysis for Distributed Systems},
  booktitle = {Proceedings of the 9th Workshop on Aspects, Components, and Patterns for Infrastructure Software (ACP4IS'10), (published as Technical Report No.~33, Hasso-Plattner Institut, University of Potsdam)},
  editor = 	 {Bram Adams and Michael Haupt and Daniel Lohmann},
  isbn = 	 {978-3-86956-043-4},
  issn = 	 {1613-5652},
  pages = 	 {27--31},
  year = 	 2010,
  month = 	 mar # { 16},
  pdf = 	 {acp4is2010.pdf},

  url = 	 {http://publishup.uni-potsdam.de/opus4-ubp/files/3946/tbhpi33.pdf},
  abstract = 	 {Enforcing security policies to distributed systems is difficult, in particular, when a system contains untrusted components. We designed AspectKE*, a distributed AOP language based on a tuple space, to tackle this issue. In AspectKE*, aspects can enforce access control policies that depend on future behavior of running processes. One of the key language features is the predicates and functions that extract results of static program analysis, which are useful for defining security aspects that have to know about future behavior of a program. AspectKE* also provides a novel variable binding mechanism for pointcuts, so that pointcuts can uniformly specify join points based on both static and dynamic information about the program. Our implementation strategy performs fundamental static analysis at load-time, so as to retain runtime overheads minimal. We implemented a compiler for AspectKE*, and demonstrate usefulness of AspectKE* through a security aspect for a distributed chat system.}}


@Misc{yang2010aosd-demo,
  author = 	 fanyang # and # masuhara # and # aotani # and # "Flemming Nielson" # and # "Hanne Riis Nielson",
  title = 	 {{AspectKE*}: Security Aspects with Program Analysis for Distributed Systems},
  url = 	 {http://modularity.info/conference/2010/},
  howpublished = {Demonstration presentation at } # AOSD,
  month = 	 mar # { 17--18},
  year = 	 2010,}

@InProceedings{aotani2010foal,
  pdf = 	 {foal2010.pdf},
  slides = 	 {foal2010-slides.pdf},
  author = 	 aotani # AND # touyama # AND # masuhara,
  title = 	 {{StrongRelaxAJ}: integrating adaptability of {RelaxAJ} and expressiveness of {StrongAspectJ}},
  crossref =  {foal2010},
  url = 	 {http://www.cs.ucf.edu/~leavens/FOAL/index-2010.shtml},
  pages = 	 {1--4},
  keywords = 	 {AspectJ},
  abstract = 	 {A sketch of StrongRelaxAJ is presented. StrongRelaxAJ is an extension to AspectJ with a type system for around advice that integrates the ones in RelaxAJ and StrongAspectJ. In other words, StrongRelaxAJ employs the type-relaxed weaving mechanism in RelaxAJ for better adaptability of around advice, and supports type variables and explicit signatures of proceed for better expressiveness without relying on dangerous and annoying dynamic casting on the return values from proceed.}}

@InProceedings{appeltauer2010sc,
  author = 	 appeltauer #AND# hirschfeld #AND# masuhara #AND#  haupt #AND# kawauchi,
  pdf = 	 {sc2010.pdf},
  title = 	 {Event-specific Software Composition in Context-Oriented Programming},
  booktitle = {Proceedings of the Conference on Software Composition (SC'10)},
  pages = 	 {50--65},
  volume = 	 6144,
  doi = 	 {10.1007/978-3-642-14046-4_4},
  acceptanceRatio = {10/33 (30%)},
  OPTurl = 	 {http://www.springerlink.com/content/e3g04335p55v43m1/},
  year = 	 2010,
  series = 	 LNCS,
  address = 	 {Malaga, Spain},
  month = 	 jul #{ 1-2},
  acceptanceRatio = {10/33 (30%)},
  publisher = SV,
  keywords = 	 {Java, ContextJ},
  abstract = 	 {Context-oriented programming (COP) introduces dedicated abstractions for the modularization and dynamic composition of crosscutting context-specific functionality. While existing COP languages offer constructs for control-flow specific composition, they do not yet consider the explicit representation of event-specific context-dependent behavior, for which we observe two distinguishing properties: First, context can affect several control flows. Second, events can establish new contexts asynchronously. In this paper, we propose new language constructs for event-specific composition and explicit context representation and introduce their implementation in JCop, our COP extension to Java.},},



@InProceedings{kamina2010cop,
  author = 	 kamina # AND # aotani # ANd # masuhara,
  pdf = 	 {cop2010.pdf},
  doi = 	 {10.1145/1930021.1930023},
  title = 	 {Designing Event-based Context Transition in Context-Oriented Programming},
  booktitle = {Proceedings of 2nd International Workshop on Context-Oriented Programming (COP'10)},
  pages = 	 {7--12},
  year = 	 2010,
  editor = 	 {Pascal Costanza},
  address = 	 {Maribor, Solovenia},
  month = 	 jun,
  day = "22",
  abstract = 	 {This paper proposes a new programming language EventCJ. Its design stems from our observation that, in many context-aware applications, context changes are triggered by external events. Thus, in addition to the current COP language mechanisms, namely the one to activate/deactivate layers in accordance with a flow of control in programs, and the one to dispatch method calls to partial methods on active layers, we propose a mechanism to declaratively switch contexts of the receiver of events. EventCJ can declare events that trigger context transitions, and context transition rules that define how each instance's context changes when it receives a specific event. After the transition, the instance acquires the context dependent behaviors provided by the activated context. Each event is declared in an AspectJ-like pointcut that specifies where the event is fired in the join points of the system. EventCJ separates the specification of when each context is activated and deactivated that may crosscut whole program in the existing COP languages. Furthermore, the declarative nature of the context transition rules help validation of some properties that the contexts should satisfy}
}

@Article{appeltauer2011compsoft,
  pdf = 	 {compsoft2011.pdf},
  author = 	 {Malte Appeltauer and Robert Hirschfeld and  Michael Haupt} #AND# masuhara,
  doi = 	 {10.11309/jssst.28.1_272},
  title = 	 {{ContextJ}: Context-Oriented Programming with {Java}},
  journal = 	 compsofte,
  year = 	 2011,
  volume = 	 28,
  number = 	 1,
  pages = 	 {272--292},
  month = 	 jan,
  note = 	 {Presented as \cite{appeltauer2009jssst}. \href{https://www.jssst.or.jp/award/detail/ronbunsho_list.html}{JSSST Best Paper Award.}},
  abstract = 	 {The development of context-aware systems requires dynamic adaptation that challenges state-of-the-art programming language support. Context-oriented programming (COP) provides dedicated abstractions for first-class representation of context-dependent behavior. So far, COP has been implemented for dynamically-typed languages such as Lisp, Smalltalk, Python, Ruby, and JavaScript relying on reflection mechanisms, and for the statically-typed programming language Java based on libraries and pre-processors. ContextJ is our compiler-based COP implementation for Java that properly integrates COP's layer concept into the Java type system. In this paper, we introduce ContextJ's language constructs, semantics, and implementation. We present a case-study of a ContextJ-based desktop application.}}

@InProceedings{kamina2011aosd,
  pdf = 	 {aosd2011.pdf},
  author = 	 kamina #and# aotani #and# masuhara,
  title = 	 {{EventCJ}: A Context-Oriented Programming Language with Declarative Event-based Context Transition},
  doi = 	 {10.1145/1960275.1960305},
  crossref =  {aosd2011},
  pages = 	 {253--264},
  abstract = 	 {This paper proposes EventCJ, a context-oriented programming (COP) language that can modularly control layer activation based on user-defined events. In addition to defining context-specific behaviors by using existing COP constructs, the EventCJ programmer declares events to specify when and on which instance layer switching should happen, and layer transition rules to specify which layers should be activated/deactivated upon events. These constructs enable controlling layer activation on a per-instance basis, separately from a base program. We also demonstrate an approach to verify safety properties of layer transitions by using a model checker. With these advantages, EventCJ enables more modular descriptions of context-aware programs, especially when layer switching is triggered in many places of a program, or by activities external to the base program. We implemented a prototype EventCJ compiler with Eclipse IDE support.}}

                  
@InProceedings{aotani2011foal,
  author = 	 aotani #and# touyama #and# masuhara,
  title = 	 {Supporting covariant return types and generics in
type-relaxed weaving},
  crossref =  {foal2011},
  pages = 	 {13--17},
  doi = 	 {10.1145/1960510.1960516},
  url = {foal2011-trw.pdf},
  keywords = 	 {AspectJ},
  abstract = 	 {This paper introduces our ongoing study on type safety of the type relaxed weaving mechanism in the presence of two Java 5 features, namely covariant return types and generics. We point out additional conditions that are necessary to ensure type safety, which can be checked by a slightly modified type checking rules for the type relaxed weaving.}
}

@InProceedings{hirschfeld2011foal,
  author = 	 hirschfeld #and# igarashi #and# masuhara,
  title = 	 {{ContextFJ}: A Minimal Core Calculus for Context-Oriented Programming},
  crossref = 	 {foal2011},
  doi = 	 {10.1145/1960510.1960515},
  pages = 	 {25--29},
  pdf = {foal2011-contextfj.pdf},
  abstract = 	 {We develop a minimal core calculus called ContextFJ to model language mechanisms for context-oriented programming (COP). Unlike other formal models of COP, ContextFJ has a direct operational semantics that can serve as a precise description of the core of COP languages. We also discuss a simple type system that helps to prevent undefined methods from being accessed via proceed.}
}

@InProceedings{watanabe2011suite,
  pdf = 	 {suite2011.pdf},
  author = 	 watanabe #and #masuhara,
  title = 	 {A Spontaneous Code Recommendation Tool Based on Associative Search},
  booktitle = {Proceedings of the 3rd International Workshop on Search-driven development: Users, Infrastructure, Tools and Evaluation (SUITE'11)},
  pages = 	 {17--20},
  year = 	 2011,
  month = 	 may,
  location = 	 {Waikiki, Honolulu, Hawaii, USA},
  day = 	 28,
  keywords = 	 {Selene, Eclipse},
  doi = 	 {10.1145/1985429.1985434},
  abstract = 	 {We present Selene, a source code recommendation tool based on an associative search engine. It spontaneously searches and displays example programs while the developer is editing a program text. By using an associative search engine, it can search a repository of two million example programs within a few seconds. This paper discusses issues that are revealed by our ongoing implementation of Selene, in particular those of performance, similarity measures and user interface.}
}


@InProceedings{yang2011coordination,
  pdf = 	 {coordination2011.pdf},
  author = 	 fanyang # and # masuhara # and # aotani # and # "Flemming Nielson" # and # "Hanne Riis Nielson",
  title = 	 {Combining Static Analysis and Runtime Checking in Security Aspects for Distributed Tuple Spaces},
  booktitle = {Proceedings of the 13th International Conference on Coordination Models and Languages},
  OPTurl = 	 {http://discotec.ru.is/coordination/main},
  pages = 	 {202--218},
  series = 	 lncs,
  location = 	 {Reykjavik, Iceland},
  volume = 	 6721,
  year = 	 2011,
  month = 	 jun # { 6-8},
  doi = 	 {10.1007/978-3-642-21464-6_14},
  acceptanceRatio = {40% (14/35)},
  abstract = 	 {Enforcing security policies to distributed systems is difficult, in particular, to a system containing untrusted components. We designed AspectKE*, an aspect-oriented programming language based on distributed tuple spaces to tackle this issue. One of the key features in AspectKE* is the program analysis predicates and functions that provide information on future behavior of a program. With a dual value evaluation mechanism that handles results of static analysis and runtime values at the same time, those functions and predicates enable the users to specify security policies in a uniform manner. Our two-staged implementation strategy gathers fundamental static analysis information at load-time, so as to avoid performing all analysis at runtime. We built a compiler for AspectKE*, and successfully implemented security aspects for a distributed chat system and an electronic healthcare record workflow system.},
}

@InProceedings{aotani2011cop,
  pdf = 	 {cop2011.pdf},
  author = 	 aotani # and # kamina # and # masuhara,
  title = 	 {Featherweight {EventCJ}: a Core Calculus for a Context-Oriented
  Language with Event-Based Per-Instance Layer Transition},
  booktitle = {Proceedings of the Workshop on Context-Oriented Programming (COP'11)},
  pages = 	 {1:1--1:7},
  year = 	 2011,
  month = 	 jul,
  location = 	 {Lancaster, UK},
  doi = 	 {10.1145/2068736.2068737},
  abstract = 	 {We propose Featherweight EventCJ, which is a small calculus for context-oriented languages with event-based per-instance layer controls like EventCJ. It extends ContextFJ with stores, labels and transitions for modeling the per-instance layer management, events and declarative layer transition rules, respectively.}
}

@InProceedings{perscheid2011jssst,
  author = 	 {Michael Perscheid and Michael Haupt and Robert Hirschfeld} #AND# masuhara,
  url = 	 {http://jssst11.kuis.kyoto-u.ac.jp/},
  title = 	 {Test-Driven Fault Navigation for Debugging Reproducible Failures},
  crossref =  {jssst2011},
  pdf = 	 {jssst2011-perscheid.pdf},
  pages = 	 {3E-3},
  date = 	 {2011-09-27},
  note = 	 {Published as \cite{perscheid2012compsoft}},
  abstract = 	 {Debugging activities, particularly those for searching for failure causes, are often laborious and time-consuming. Techniques such as spectrum-based fault localization or back-in-time debugging help programmers to reduce development cost. However, such approaches are often limited to a single point of view, ignoring the need for combined perspectives.

We present test-driven fault navigation as an interconnected guide to failure causes. Based on failure-reproducing unit tests, we introduce a novel systematic top-down debugging process with corresponding tool support. With spectrum-based fault localization, we offer navigation to suspicious system parts and erroneous behavior in the execution history and rank developers most qualified for addressing the faults localized. Our evaluation illustrates the practicability of this approach, its high accuracy of developer recommendation, and the fast response times of its corresponding tool suite}}

MISC{kamina2011coomp,
  author = 	 kamina #AND# aotani #AND# masuhara #AND# tamai,
  title = 	 {Modeling and Implementing Context-Aware Applications using Event-Based Layer Trasaction},
  note = 	 {submitted COOMP'11, but rejected as out-of-scoped}}

Misc{sakurai2012icse,
  author = 	 sakurai #and# masuhara,
  title = 	 {Debugging What-Should-Have-Happened Bugs with an Execution Trace and Points-to Analysis},
  howpublished = {submitted to ICSE'12; not accepted},
  keywords = 	 {back-in-time debugger, trace-based debugger, omniscent debugging, Java},
  month = 	 sep,
  year = 	 2011}

Misc{kamina2012icse,
  author = 	 kamina #and# aotani #and# masuhara #and# tamai,
  title = 	 {{COSE}: Context-Oriented Software Engineering with Use Cases and Event-Based Context Transition},
  howpublished = {submitted to ICSE'12; not accepted},
  month = 	 sep,
  year = 	 2011}

@InProceedings{toyama2012varicomp,
  pdf = 	 {varicomp2012.pdf},
  author = 	 touyama #AND# aotani #AND# masuhara,
  title = 	 {A Per-Type Instantiation Mechanism for Generic Aspects},
  booktitle = {Proceedings of the 3rd International Workshop on Variablity and Composition (VariComp'12)},
  pages = 	 {25--30},
  year = 	 2012,
  doi = 	 {10.1145/2161996.2162003},
  month = 	 mar,
  keywords = 	 {AspectJ},
  abstract = 	 {We propose a per-type instantiation mechanism for generic aspects. Though AspectJ supports generic aspects, which declare type parameters, we cannot declare aspects that are parametrized over both field types and return types of applied join points without manually concretizing the type parameters. Our mechanism creates an instance of a generic aspect for each type of the applied join points.}
}


                  
@InProceedings{murakami2012rsse,
  author = 	 murakami #and# masuhara,
  pdf = 	 {rsse2012.pdf},
  title = 	 {Optimizing a Search-based Code Recommendation System},
  booktitle = {Proceedings of the third International Workshop on Recommendation Systems for Software Engineering (RSSE'12)},
  year = 	 2012,
  pages = 	 {68--72},
  date = 	 {2012-06-04},
  doi = 	 {10.1109/RSSE.2012.6233414},
  keywords = 	 {Selene},
  location = 	 {Zurich, Switzerland},
  isbn = 	 {978-1-4673-1758-0},
  month = 	 jun,
  abstract = 	 {Search-based code recommendation systems with a large-scale code repository can provide the programmers example code snippets that teach them not only names in application programming interface of libraries and frameworks, but also practical usages consisting of multiple steps. However, it is not easy to optimize such systems because usefulness of recommended code is indirect and hard to be measured. We propose a method that mechanically evaluates usefulness for our recommendation system called Selene. By using the proposed method, we adjusted several search and user-interface parameters in Selene for better recall factor, and also learned characteristics of those parameters.},
}

@InProceedings{masuhara2012suite,
  pdf = 	 {suite2012.pdf},
  author = 	 masuhara #and# murakami #and# watanabe,
  title = 	 {Duplication Removal for a Search-based Recommendation System},
  pages = 	 {31--34},
  date = 	 {2012-06-05},
  location = 	 {Zurich, Swizerland},
  doi = 	 {10.1109/SUITE.2012.6225477},
  booktitle = {Proceedings of the 4th International Workshop on Search-driven development: Users, Infrastructure, Tools and Evaluation (SUITE'12)},
  year = 	 2012,
  keywords = 	 {Selene},
  month = 	 jun,
  abstract = 	 {A search-based recommendation system looks, in the code repository, for programs that are relevant to the program being edited. Storing a large amount of open source programs into the repository will make the search results better, but also causes the code clone problem; i.e., recommending a set of program fragments that are almost idential. To tackle this problem, we propose a novel approach that ranks recommended programs by taking their ,Y4freshness,Y! count into account. This short paper discusses the background of the problem, and illustrates the proposed algorithm.}},


@InProceedings{kamina2012cop,
  pdf = 	 {cop2012.pdf},
  author = 	 kamina #and# aotani #and# masuhara,
  title = 	 {Bridging Real-World Contexts and Units of Behavioral Variations by Composite Layers},
  booktitle = {Proceedings of the Workshop on Context-Oriented Programming (COP'12)},
  year = 	 2012,
  month = 	 jun,
 isbn = {978-1-4503-1276-9},
 location = {Beijing, China},
 pages = {4:1--4:6},
 articleno = 4,
 numpages = 6,
 OPTurl = {http://doi.acm.org/10.1145/2307436.2307440},
 doi = {10.1145/2307436.2307440},
 acmid = {2307440},
 publisher = {ACM},
 address = {New York, NY, USA},
 keywords = {EventCJ, atomic and composite layers, implicit layer activation},
  abstract = 	 {This paper proposes a new linguistic construct composite layers and an extension of EventCJ with it. A composite layer is implicitly activated when the declared condition is met. This extension bridges the gap between contexts and units of behavioral variations that complicates programs written in COP languages. In this proposal, only atomic layers (layers that directly correspond to a context) can be explicitly controlled by linguistic operations for layer activation. Composite layers (layers that are not atomic) are declared with a proposition constructed from other layers. Examples show that the extension simplifies programs and enhances separation of concerns.},
}

@InProceedings{masuhara2012ramse,
  pdf = 	 {ramse2012.pdf},
  author = 	 masuhara #and# nishiguchi,
  title = 	 {A Data-Parallel Extension to {Ruby} for {GPGPU}:
Toward a Framework for Implementing Domain-Specific Optimizations},
  booktitle = {Proceedings of the 9th Workshop on
Reflection, AOP and Meta-Data for Software Evolution (RAM-SE'12)},
  pages = 	 {3--6},
  doi = 	 {10.1145/2237887.2237888},
  year = 	 2012,
  month = 	 jun,
  day = 	 13,
  location = 	 {Beijing, China},
  keywords = 	 {Ikra},
  publisher = 	 ACM,
  abstract = 	 {We propose Ikra, a data-parallel extension to Ruby for general-purpose computing on graphical processing unit (GPGPU). Our approach is to provide a special array class with higher-order methods for describing computation on a GPU. With a static type inference system that identifies code fragments that shall be executed on a GPU and with a skeleton-based compiler that generates CUDA code, we aim at separating application logic and parallelization and optimizations. The paper presents the design of Ikra and an overview of its implementation along with preliminary performance evaluation.},
}

@Article{perscheid2012compsoft,
  author = 	 {Michael Perscheid and Michael Haupt and Robert Hirschfeld} #AND# masuhara,
  title = 	 {Test-Driven Fault Navigation for Debugging Reproducible Failures},
  doi = 	 {10.11309/jssst.29.3_188},
  journal = 	 compsoftE,
  pdf = 	 {compsoft2012.pdf},
  year = 	 2012,
  volume = 	 29,
  number = 	 3,
  pages = 	 {188--211},
  month = 	 apr,
  note = 	 {Presented as \cite{perscheid2011jssst}.  Also appears in \href{https://doi.org/10.11185/imt.7.1377}{Journal of Information and Media Technologies, Vol.7, No.4, pp.1370--1376, 2012}.
},
  OPTurl = {http://japanlinkcenter.org/DN/JST.JSTAGE/jssst/29.3_188},
  abstract = 	 {Debugging failing test cases, particularly the search for failure causes, is often a laborious and time-consuming activity. With the help of spectrum-based fault localization developers are able to reduce the potentially large search space by detecting anomalies in tested program entities. However, such anomalies do not necessarily indicate defects and so developers still have to analyze numerous candidates one by one until they find the failure cause. This procedure is inefficient since it does not take into account how suspicious entities relate to each other, whether another developer is better qualified for debugging this failure, or how erroneous behavior comes to be. 

We present test-driven fault navigation as an interconnected debugging guide that integrates spectrum-based anomalies and failure causes. By analyzing failure-reproducing test cases, we reveal suspicious system parts, developers most qualified for addressing localized faults, and erroneous behavior in the execution history. The Paths tool suite realizes our approach: PathMap supports a breadth first search for narrowing down failure causes and recommends developers for help; PathFinder is a lightweight back-in-time debugger that classifies failing test behavior for easily following infection chains back to defects. The evaluation of our approach illustrates the improvements for debugging test cases, the high accuracy of recommended developers, and the fast response times of our corresponding tool suite.}
}

@Misc{masuhara2012cob,
  author = 	 masuhara,
  title = 	 {Reflection on the Power of Pointcuts},
  slides = 	 {cob2012-slides.pdf},
  howpublished = {Talk at the Symposium in Honor of Professor Akinori Yonezawa's 65th Birthday ``Concurrent Objects and Beyond: From Theory to High-Performance Computing''},
  location = 	 {Kobe, Japan},
  url = 	 {https://sites.google.com/site/aki65thbd/},
  month = 	 may,
  year = 	 2012,
  date = 	 {2012-05-29},
  keywords = 	 {AspectJ}}

@InProceedings{igarashi2012fool,
  pdf = 	 {fool2012.pdf},
  url = 	 {https://2012.splashcon.org/track/fool-2012-papers},
  author = 	 igarashi #AND# hirschfeld #AND# masuhara,
  title = 	 {A Type System for Dynamic Layer Composition},
  booktitle = {Proceedings of 19th International Workshop on Foundations of Object-Oriented Languages (FOOL 2012)},
  pages = 	 {13--24},
  year = 	 2012,
  month = 	 oct,
  date = 	 {2012-10-22},
  location = 	 {Tucson, AZ, USA},
  keywords = 	 {ContextFJ},
  abstract = 	 {Dynamic layer composition is one of the key features in context-oriented programming (COP), an approach to improving modularity of behavioral variations that depend on the dynamic context of the execution environment. It allows a layer---a set of new or overriding methods that can belong to several classes---to be added to or removed from existing objects in a disciplined way. We develop a type system for dynamic layer composition, which may change the interfaces of objects at run time, based on a variant of ContextFJ, a core calculus for COP, and prove its soundness.},
}

@Article{kamina2013ipsj-trpro,
  pdf = 	 {kamina2013ipsj-trpro.pdf},
  author = 	 kamina #and# aotani #and# masuhara,
  title = 	 {Introducing Composite Layers in {EventCJ}},
  doi = 	 {10.11185/imt.8.279},
  journal = 	 {IPSJ Transaction on Programming},
  year = 	 2013,
  volume = 	 6,
  number = 	 1,
  pages = 	 {1--8},
  month = 	 jan,
  annote = 	 {First presented at IPSJ SIG-PRO workshop on June 2012 \cite{kamina2012pro}},
  abstract = 	 {Context-oriented programming (COP) languages provide a modularization mechanism called a layer, which modularizes behaviors that are executable under specific contexts, and specify a way to dynamically switch behaviors. However, the correspondence between real-world contexts and units of behavioral variations is not simple. Thus, in existing COP languages, context-related concerns can easily be tangled within a piece of layer activation code. In this paper, we address this problem by introducing a new construct called a composite layer, which declares a proposition in which ground terms are given other layer names (true when active). A composite layer is active only when the proposition is true. We introduce this construct into EventCJ, out COP language, and verify this approach by conducting two case studies involving a context-aware Twitter client and a program editor. The results obtained in our approach show that the layer activation code is simple and free from tangled context-related concerns. We also discuss the efficient implementation of this mechanism in EventCJ.}
}

@InProceedings{kamina2013foal,
  pdf = 	 {foal2013.pdf},
  author = 	 kamina #and# aotani #and# masuhara,
  title = 	 {A Core Calculus of Composite Layers},
  doi = 	 {10.1145/2451598.2451601},
  crossref =  {foal2013},
  pages = 	 {7--12},
  abstract = 	 {Composite layers in context-oriented programming (COP) are the abstraction that localizes conditions about when the specified layer becomes active. A composite layer changes the behavior of the system by implicit layer activation triggered by explicit activation of contexts. Existing studies on formalization of COP languages do not cover such an activation mechanism. This paper formalizes composite layers to clarify the operational semantics of implicit layer activation. Based on this formalization, we prove that the translation of composite layers into the existing COP language is sound, which ensures the correctness of the existing implementation of composite layers.}
}

(Student only)
@Misc{touyama2013aosd-poster,
  author = 	 touyama,
  title = 	 {Dependencies of Inter-Type Methods and Base Code},
  howpublished = {Poster presentation at MODULARITY:aosd 2013},
  month = 	 mar,
  year = 	 2013,
  keywords = 	 {AspectJ}
}

@InProceedings{kamina2013cop,
  pdf = 	 {cop2013-activation.pdf},
  month = 	 jul,
  author = 	 kamina #and# aotani #and# masuhara,
  title = 	 {A Unified Context Activation Mechanism},
  crossref =  {cop2013},
  pages = 	 {Article No.~2},
  doi = 	 {10.1145/2489793.2489795},
  year = 	 2013,
  abstract = 	 {With the increase of research interest in context-oriented programming (COP), several COP languages with different characteristics have been proposed. Although they share common language features to modularize context-dependent variations of behavior, they take quite different ways to realize them. Because of such differences, each language cannot solely cover all use cases of implementing context-dependent behavioral variations. In this paper, we propose a new COP language Javanese that unifies several COP mechanisms into general linguistic constructs. Specifically, it provides context declarations to identify context and its specification of the range of execution sequences where this context is active, activate declarations to define the relation between contexts and layers, and context group declarations that modularize these declarations and specify the set of instances where they are applied. This paper describes design of Javanese and an implementation strategy.}
}

@InProceedings{hirschfeld2013cop,
  pdf = 	 {cop2013-l.pdf},
  month = 	 jul,
  author = 	 hirschfeld #and# masuhara #and# igarashi,
  title = 	 {{L}: Context-Oriented Programming With Only Layers},
  crossref =  {cop2013},
  pages = 	 {Article No.~4},
  year = 	 2013,
  doi = 	 {10.1145/2489793.2489797},
  day = 	 {2013-07-02},
  abstract = 	 {Most if not all extensions to object-oriented languages that allow for context-oriented programming (COP) are asymmetric in the sense that they assume a base implementation of a system to be composed into classes and a set of layers to provide behavioral variations applied to those classes at run-time. We propose L as an experimental language to further explore the design space for COP languages. In this position paper we talk about first steps towards the unification of classes and layers and with that the removal of the asymmetry in composition mechanisms of contemporary COP implementations.}
}

@Misc{toyama2013pro,
  author = 	 touyama #and# aotani #and# bodden #and# masuhara #and# tanter,
  title = 	 {Aspect Interfaces: Towards Separate Type-checking of Aspect-Oriented Programs with Inter-Type Declarations},
  url = 	 {http://www.spa.is.uec.ac.jp/pro/sig2/ipsj/sig_1_094.html},
  howpublished = IPSJ-PRO-PRE # {94} # IPSJ-PRO-POST # {2013-1-(4)},
  month = 	 jun,
  year = 	 2013,
  location = 	 {Akita, Japan},
  day = 	 {2013-06-04},
  keywords = 	 {AspectJ}}

@Misc{hircshfeld2013pro,
  author = 	 hirschfeld #and# masuhara #and# igarashi,
  title = 	 {Layer and Object Refinement for Context-Oriented Programming in {L}},
  pdf = 	 {pro2013-2-2.pdf},
  howpublished = IPSJ-PRO-PRE # {95} # IPSJ-PRO-POST # {2013-2-(2)},
  month = 	 aug,
  year = 	 2013,
  note = 	 {Kitakyushu, Japan},
  day = 	 {2013-08-02},
  abstract = 	 {Context-oriented programming (COP) languages provide layers as an abstraction mechanism for modularizing context-dependent behavioral variations. While existing COP languages offer layers in addition to other constructs like classes asymetrically, we propose an experimental language called L that removes such asymmetry. The design of L started from ContextFJ, our minimalistic COP language, with extensions for state and refinement. This proposal presents one such refinement mechanism as a first step towards a small yet practical COP kernel.}}

@InProceedings{kamina2013rem,
  author = 	 kamina #and# aotani #and# masuhara,
  title = 	 {Mapping Context-Dependent Requirements to Event-Based Context-Oriented Programs for Modularity},
  url = 	 {http://soft.vub.ac.be/REM13/},
  booktitle = {Proceedings of the Workshop on Reactivity, Events and Modularity (REM 2013), colocated with OOPSLA'13},
  day = 	 {2013-10-28},
  year = 	 2013,
  pdf = 	 {rem2013.pdf},
  slides = 	 {rem2013-slides.pdf},
  month = 	 oct,
  location = 	 {Indianapolis, IN, USA},
  abstract = 	 {There are several challenges in development of context-aware
systems. First, while contexts are abstract from the viewpoint of behavior that depends on them, we need to elicit more concrete level of contexts that are sensed by complex context sensing technologies. Second, there are complicated relations between contexts and behavioral variations. Several variations may depend on multiple contexts, and several behavioral variations crosscut across several requirements. Third, contexts and context-dependent behavior reactively change with respect to external/internal events, and these changes also crosscut across several requirements. Finally, these complexities in requirements make it difficult to modularly map requirements to the implementation. This paper proposes a model of context-dependent requirements and shows the modular mapping from the model to the implementation in the existing COP language EventCJ. The model represents the following facts: (1) abstract contexts, context-dependent use cases, and groups of related use cases called layers; (2) concrete level of contexts, context-related external entities, and their correspondence to the abstract contexts; and (3) events that trigger changes of the contexts and thus switch the variations of behavior. We show that all such facts are injectively translated into the program written in EventCJ.}}

@InProceedings{aotani2014foal,
  pdf = 	 {foal2014.pdf},
  author = 	 aotani #and# kamina #and# masuhara,
  title = 	 {Context Holders: Realizing Multiple Layer Activation
Mechanisms in a Single Context-Oriented Language},
  crossref =  {foal2014},
  pages = 	 {3--6},
  doi = 	 {10.1145/2588548.2588552},
  abstract = 	 {We propose LamFJ, a calculus for expressing various layer activation mechanisms in context-oriented programming languages. LamFJ extends FeatherweightJava with context holders, which are the abstraction of dynamic layer activation. By encoding programs with different layer activation mechanisms into a program manipulating context holders, LamFJ serves as a foundation to reason about interactions between different mechanisms. This paper presents a sketch of the context holders and encodings of existing layer activation mechanisms.}}

@InProceedings{kamina2014mv,
  pdf = 	 {modularity2014.pdf},
  author = 	 kamina #and# aotani #and# masuhara #and# tamai,
  title = 	 {Context-Oriented Software Engineering: A Modularity Vision},
  annote = 	 {submitted on October 22, 2013, accepted on February 11, 2014},
  crossref =  {modularity2014},
  doi = 	 {10.1145/2577080.2579816},
  annote = 	 {Track on Modularity Visions},
  pages = 	 {85--98},
  annote = 	 {21/60 -- 35 percent acceptance},
  abstract = 	 {There are a number of constructs to implement context-dependent
behavior, such as conditional branches using if statements, method dispatching in object-oriented programming (such as the state design pattern), dynamic deployment of aspects in aspect-oriented programming, and layers in context-oriented programming (COP). Uses of those constructs significantly affect the modularity of the obtained implementation. While there are a number of cases where COP improves modularity, it is not clear when we should use COP in general.

This paper presents a preliminary study on our software development methodology, the context-oriented software engineering (COSE), which is a use-case-driven software development methodology that guides us to a specification of context-dependent requirements and design. We provide a way to map the requirements and design formed by COSE to the implementation in our COP language ServalCJ. We applied COSE to two applications in order to assess its feasibility. We also identify key linguistic constructs that make COSE effective by examining existing COP languages. These feasibility studies and examination raise a number of interesting open issues. We finally show our future research roadmap to address those issues.}}

                  
@InProceedings{murakami2014rsse,
  author = 	 murakami #and# masuhara #and# aotani,
  pdf = 	 {rsse2014.pdf},
  title = 	 {Code Recommendation Based on a Degree-of-Interest Model},
  crossref =  {rsse2014},
  annote = 	 {submitted on February 1, 2014, accepted},
  doi = 	 {10.1145/2593822.2593828},
  pages = 	 {28--29},
  keywords = 	 {Selene, Mylyn, Eclipse},
  abstract = 	 {Code recommendation systems predict and present what the user is likely to write next by using the user's editing context, namely textual and semantic information about the programs being edited in a programming editor. Most existing systems however use information merely around the cursor position---i.e., the class/method definition at the cursor position---as the editing context. By including the code related to the current method/class, like the callers and callees of the method, recommendation could become more appropriate. We propose to use the user's editing activity for identifying code relevant to the current method/class. Specifically, we use a modified degree-of-interest model in the Mylyn task management tool, and incorporated the model in our repository-based code recommendation system, Selene. This paper reports the design of the system and the results of our initial experiments.}}


Misc{toyama2014oopsla,
  author = 	 touyama #and# aotani #and# bodden #and# masuhara #and# tanter,
  title = 	 {Interfaces for Separate Compilation of Aspect-Oriented Programs with Inter-Type Declarations},
  howpublished = {submitted to OOPSLA'14},
  year = 	 2014,
  annote = 	 {submitted on March 25, 2014, not accepted},
  keywords = 	 {AspectJ}
}

@InProceedings{hirschfeld2014jssst,
  author = 	 {Robert Hirschfeld and Hidehiko Masuhara and Atsushi Igarashi and Tim Felgentreff},
  title = 	 {Visibility of Context-Oriented Behavior and State in {L}},
  url = 	 {http://jssst.or.jp/files/user/taikai/2014/toc.html#ppl2},
  crossref =  {jssst2014e},
  pages = 	 {PPL2--1},
  note = 	 {revised version appears in Computer Software journal \cite{hirschfeld2015compsoft}},
  date = 	 {2014-09-08}}

@inproceedings{aotani2014cop,
 author = {Aotani, Tomoyuki and Kamina, Tetsuo and Masuhara, Hidehiko},
 title = {Unifying Multiple Layer Activation Mechanisms Using One Event Sequence},
  pdf = 	 {cop2014-unifying.pdf},
 booktitle = {Proceedings of 6th International Workshop on Context-Oriented Programming},
 series = {COP'14},
  date = 	 {2014-07-29},
 year = 2014,
  month = 	 jul,
 isbn = {978-1-4503-2861-6},
 location = {Uppsala, Sweden},
 pages = {2:1--2:6},
 articleno = 2,
 numpages = 6,
 OPTurl = {http://doi.acm.org/10.1145/2637066.2637068},
 doi = {10.1145/2637066.2637068},
 acmid = 2637068,
 publisher = {ACM},
 address = {New York, NY, USA},
 keywords = {Context-Oriented Programming, Layer Activation Mechanisms},
  abstract = 	 {Different context-oriented programming languages try to capture contexts with respect to different things, including a computation, an object, and a device that executes a program, by providing different layer activation mechanisms. When we want to exploit all of those different kinds of contexts at the same time, it is not clear how the effects of those contexts should be combined.
                  
We develop LamFJ, a calculus for expressing various layer activation mechanisms. It replaces the with and without expressions in ContextFJ with four expressions that fire context change events, which models changes of each context. LamFJ is not only powerful enough to express multiple layer activation mechanisms but also clearly defines combined effects of those mechanisms. In addition to the supported layer activation mechanisms in the paper, namely imperative activation, per-object activation and dynamic scoping, we aim at supporting other mechanisms like reactive and structural activation with small extensions.},
}

@inproceedings{kamina2014cop,
 author = {Kamina, Tetsuo and Aotani, Tomoyuki and Igarashi, Atsushi},
 title = {On-Demand Layer Activation for Type-Safe Deactivation},
  date = 	 {2014-07-29},
  month = 	 jul,
 booktitle = {Proceedings of 6th International Workshop on Context-Oriented Programming},
  pdf = 	 {cop2014-ondemand.pdf},
 series = {COP'14},
 year = 2014,
 isbn = {978-1-4503-2861-6},
 location = {Uppsala, Sweden},
 pages = {4:1--4:7},
 articleno = {4},
 numpages = {7},
 OPTurl = {http://doi.acm.org/10.1145/2637066.2637070},
 doi = {10.1145/2637066.2637070},
 acmid = {2637070},
 publisher = {ACM},
 address = {New York, NY, USA},
 keywords = {ContextFJ, Dynamic layer deactivation, Type soundness},
  abstract = 	 {Dynamic layer deactivation in context-oriented programming (COP) allows a layer to be dynamically disabled in the running application in a disciplined way. Deactivating a layer may lead to an error if there is another layer which has been activated but depends on the deactivated layer in the sense that the latter calls a method that exists only in the former. A type system or static analysis might be able to check the absence of such depending layers at each deactivation point but it would not be very easy, especially in the open-world setting.

We argue that the on-demand activation, which implicitly activates all layers on which currently activated layer depends, addresses this problem. In this mechanism, the precedent layer deactivation is canceled when the depending layer requires the implementation of the deactivated layer. This means that this mechanism can ensure that all method calls succeed without performing the checks of absent depending layers, which simplifies the type system. We formalize this idea as an extension of ContextFJ, a COP extension of Featherweight Java, and prove its type soundness.},
} 

@Book{concurrentObjectsAndBeyond2014,
  editor = 	 {Gul Agha} #and# igarashi #and# {Naoki Kobayashi} #and# masuhara #and# {Satoshi Matsuoka} #and# {Etsuya Shibayama} #and # taura,
  title = 	 {Concurrent Objects and Beyond},
  publisher = 	 SV,
  year = 	 2014,
  volume = 	 8665,
  OPTurl = 	 {https://link.springer.com/book/10.1007/978-3-662-44471-9},
  doi = 	 {10.1007/978-3-662-44471-9},
  isbn = 	 {978-3-662-44470-2},
  series = 	 LNCS,
  month = 	 sep,
  annote = 	 {Papers dedicated to Akinori Yonezawa on the Occasion of His 65th Birthday}
}

@InProceedings{sakurai2014aoasia,
  author = 	 sakurai #and# masuhara,
  title = 	 {{Crossver}: a Code Transformation Language for Crosscutting Changes},
  url = 	 {http://prg.is.titech.ac.jp/events/aoasia14/},
  pdf = 	 {aoasia2014.pdf},
  booktitle = {Proceedings of the 9th International Workshop on Advanced Modularization Techniques (AOAsia/Pacific 2014)},
  year = 	 2014,
  month = 	 nov,
  date = 	 {2014-11-16},
  location = 	 {Hong Kong},
  keywords = 	 {Java},
  abstract = 	 {Software evolution sometimes requires changes of module interfaces, which in turn cause crosscutting changes, or changes of module clients that are spreading over a program. Such changes on the client-side can be too complicated to be automatically achieved by text replacement and refactoring tools. We propose a code transformation language, called Crossver, for consistently updating code fragments in a program. Crossver offers a source-level pattern sublanguage to express complicated transformation conditions. The patterns are robust against variety among clients thanks to the dataflow-based pattern matcher. In the paper, we overview the design and core semantics of Crossver.}}

@Misc{masuhara2014isp2s2,
  location = 	 {Kobe},
  author = 	 masuhara #and# aotani,
  pdf = 	 {isp2s2-poster.pdf},
  title = 	 {A Dynamically-typed Language for Prototyping High-Performance Data Parallel Programs},
  howpublished = {Poster presentation at JST/CREST International Symposium on Post Petascale System Software},

  month = 	 dec,
  date = 	 {2014-12-02},
  keywords = 	 {Ikra, CUDA, Ruby},
  year = 	 2014}

@InProceedings{kamina2015modularity,
  pdf = 	 {modularity2015.pdf},
  author = 	 kamina #and# aotani #and# masuhara,
  title = 	 {Generalized Layer Activation Mechanism Through Contexts and Subscribers},
  crossref =  {modularity2015},
  pages = 	 {14--28},
  doi = {10.1145/2724525.2724570},
  abstract = 	 {Context-oriented programming (COP) languages modularize context-dependent behaviors in multiple classes into layers. These languages have layer activation mechanisms so that the behaviors in layers take effect on a particular unit of computation during a particular period of time. Existing COP languages have different layer activation mechanisms, and each of them has its own advantages. However, because these mechanisms interfere with each other in terms of extent (time duration) and scope (a set of units of computations) of activation, it is not trivial to combine them into a single language. We propose a generalized layer activation mechanism based on contexts and subscribers to implement the different activation mechanisms in existing COP languages in a single COP language called ServalCJ. Contexts specify the extent of activation through temporal logic terms, and subscribers specify the scope of activation through operators provided by the language. We implement a compiler of ServalCJ, and demonstrate its expressiveness by writing a couple of application programs.},
}

@InProceedings{sakurai2015sac,
  pdf = 	 {sac2015.pdf},
  author = 	 sakurai #and# masuhara,
  title = 	 {The Omission Finder for Debugging What-Should-Have-Happened Bugs in Object-Oriented Programs},
  doi = 	 {10.1145/2695664.2695735},
  crossref =  {sac2015},
  booktitle = {In Proceedings of The 30th ACM/SIGAPP Symposium On Applied Computing (SAC 2015)},
  pages = 	 {1962--1969},
  annote = 	 {OOPS! Track},
  date = 	 {2015-04-13 .. 2015-04-17},
  keywords = 	 {Java, Back-in-time debugger, Omniscent debugging, Traced-based debugger},
  abstract = 	 {Trace-based debuggers help a debugging process by displaying a history of executed operations with their parameters in a run of a program. However, those debuggers are unable to provide any clues when a program does not perform operations that ought to occur. This paper proposes a novel feature called the omission finder for trace-based debuggers. This feature correlates points-to analysis results with an execution history to show operations that could have been but actually were not performed on a specified instance if the program behaved differently. We implemented the omission finder on top of an existing trace-based debugger, and confirmed reduction of the number of debugging steps with an omission bug in a real-world program. Our user-study also showed reduction of debugging times with programs containing omission bugs.},
}
                  
@Article{hirschfeld2015compsoft,
  pdf = 	 {hirschfeld2015compsoft.pdf},
  author = 	 {Robert Hirschfeld and Hidehiko Masuhara and Atsushi Igarashi and Tim Felgentreff},
  title = 	 {Visibility of Context-Oriented Behavior and State in {L}},
  doi = 	 {10.11309/jssst.32.3_149},
  journal = 	 {Computer Software},
  year = 	 2015,
  volume = 	 32,
  number = 	 3,
  pages = 	 {149--158},
  month = 	 aug,
  note = 	 {revised from \cite{hirschfeld2014jssst}, accepted 2015-04-15},
  annote = 	 {submitted September 2014},
  abstract = 	 {One of the properties of context-oriented programming languages is the composition of partial module definitions. While in most such language extensions the state and behavior introduced by partial definitions are treated equally at the module level, we propose a refinement of that approach to allow for both public and restricted visibility of methods and local and shared visibility of fields in our experimental language L. Furthermore, we propose a new lookup mechanism to reduce the risk of name captures.}
}

@Proceedings{array2015,
  title = 	 {Proceedings of the 2nd {ACM SIGPLAN} International Workshop on Libraries, Languages, and Compilers for Array Programming ({ARRAY'15})},
  year = 	 2015,
  url = 	 {https://pldi15.sigplan.org/track/ARRAY-2015-papers},
  editor = 	 {Laurie Hendren and Hidehiko Masuhara and Mary Sheeran and Jan Vitek},
  doi = 	 {10.1145/2774959},
  isbn = 	 {978-1-4503-3584-3},
  month = 	 jun,
  date = 	 {2015-06-13},
  location = 	 {Portland, Oregon, USA},
  publisher = {ACM},
  annote = 	 {co-located with PLDI '15 ACM SIGPLAN Conference on Programming Language Design and Implementation}
}

@Misc{masuhara2015eassy,
  author = 	 {Hidehiko Masuhara},
  title = 	 {Context-Oriented Programming and Units of Adaptation},
  howpublished = {talk at NII Shonan Meeting on Engineering Adaptive Software Systems (EASSy)},
  slides = 	 {eassy2015.pdf},
  date = 	 {2015-09-07},
  month = 	 sep,
  year = 	 2015}

@InProceedings{platz2015jssst,
  pdf = 	 {platz2015jssst.pdf},
  author = 	 {Stephanie Platz and Marcel Taeumel and Bastian Steinert}#and#
 hirschfeld #and# masuhara,
  title = 	 {Unravel Programming Sessions With {THRESHER}: Identifying Coherent and Complete Sets of Fine-granular Source Code Changes},
  crossref =  {jssst2015e},
  pages = 	 {Modularity-3},
  keywords = 	 {Squeak, Smalltalk}}

@InProceedings{huang2015splash-poster,
  pdf = 	 {huang2015splash-poster.pdf},
  author = 	 huang #and# masuhara #and# aotani,
  title = 	 {{Pyrlang}: A High Performance {Erlang} Virtual Machine Based on {RPython}},
  crossref =  {splash-companion2015},
  pages = 	 {48--49},
  doi = 	 {10.1145/2814189.2817267},
  annote = 	 {  Refereed.},
  keywords = 	 {PyPy},
  note = 	 {Poster presentation.}
}


@InProceedings{imai2015splash-demo,
  pdf = 	 {imai2015splash-demo.pdf},
  author = 	 imai #and# masuhara #and# aotani,
  title = 	 {Making Live Programming Practical by Bridging the Gap Between Trial-and-error Development and Unit Testing},
  crossref =  {splash-companion2015},
  pages = 	 {11--12},
  doi = 	 {10.1145/2814189.2814193},
  annote = 	 {Refereed.},
  note = 	 {Demonstration.},
  keywords = 	 {Emacs}
}

@InProceedings{imai2015splash-poster,
  pdf = 	 {imai2015splash-poster.pdf},
  author = 	 imai #and# masuhara #and# aotani,
  title = 	 {{Shiranui}: A Live Programming with Support for Unit Testing },
  crossref =  {splash-companion2015},
  pages = 	 {36--37},
  doi = 	 {10.1145/2814189.2817268},
  annote = 	 {Refereed.},
  note = 	 {Poster presentation.},
  keywords = 	 {Emacs}
}


@InProceedings{khatchadourian2015splash-demo,
  pdf = 	 {khatchadourian2015splash-demo.pdf},
  author = 	 khatchadourian #and# rashid #and# masuhara #and# watanabe,
  title = 	 {{Fraglight}: Shedding Light on Broken Pointcuts in Evolving Aspect-Oriented Software},
  crossref =  {splash-companion2015},
  pages = 	 {17--18},
  date = 	 {2015-10-28},
  doi = 	 {10.1145/2814189.2814195},
  annote = 	 {Refereed},
  note = 	 {Demonstration.},
  keywords = 	 {AspectJ}
}


@InProceedings{khatchadourian2015ase,
  author = 	  khatchadourian #and# "Awais Rashid" #and# masuhara #and# watanabe,
  title = 	 {Detecting Broken Pointcuts using Structural Commonality and Degree of Interest},
  booktitle = {Proceedings of 30th IEEE/ACM International Conference on
Automated Software Engineering (ASE 2015)},
  location = 	 {Lincoln, Nebraska, USA},
  pages = 	 {641--646},
  year = 	 2015,
  editor = 	 {Lars Grunske and Michael Whalen},
  doi = 	 {http://dx.doi.org/10.1109/ASE.2015.80},
  pdf = 	 {ase2015.pdf},
  month = 	 nov,
  date = 	 {2015-11-09 .. 2015-11-13},
  keywords = 	 {AspectJ},
  abstract = 	 {Pointcut fragility is a well-documented problem in Aspect-Oriented Programming; changes to the base-code can lead to join points incorrectly falling in or out of the scope of pointcuts. Deciding which pointcuts have broken due to base-code changes is a daunting venture, especially in large and complex systems. We present an automated approach that recommends pointcuts that are likely to require modification due to a particular base-code change, as well as ones that do not. Our hypothesis is that join points selected by a pointcut exhibit common structural characteristics. Patterns describing such commonality are used to recommend pointcuts that have potentially broken to the developer. The approach is implemented as an extension to the popular Mylyn Eclipse IDE plug-in, which maintains focused contexts of entities relevant to the task at hand using a Degree of Interest (DOI) model.}
}

2015-11-07
@Article{kamina2016tomc,
  pdf = 	 {tomc2016.pdf},
  author = 	 kamina #and# aotani #and# masuhara,
  title = 	 {Generalized Layer Activation Mechanism for Context-Oriented Programming},
  journal = 	 {Transactions on Modularity and Composition (TOMC)},
  year = 	 2016,
  volume = 	 9800,
  series = 	 LNCS,
  pages = 	 {123--166},
  month = 	 sep,
  date = 	 {2016-09-30},
  annote = 	 {accetped on 2015-11-07},
  note = 	 {extendend from \cite{kamina2015modularity}},
  OPTurl = 	 {http://link.springer.com/chapter/10.1007/978-3-319-46969-0_4},
  doi = 	 {10.1007/978-3-319-46969-0_4},
  abstract = 	 {Context-oriented programming (COP) languages modularize context-dependent behaviors in multiple classes into layers. These languages have layer activation mechanisms so that the behaviors in layers take effect on a particular unit of computation during a particular period of time. Existing COP languages have different layer activation mechanisms, and each of them has its own advantages. However, since these mechanisms interfere with each other in terms of extent (time duration) and scope (a set of units of computations) of activation, combining them into a single language is not trivial. We propose a generalized layer activation mechanism based on contexts and subscribers to implement the different activation mechanisms in existing COP languages in a single language called ServalCJ. We formalize the operational semantics of ServalCJ as a small calculus and prove priority preservation, i.e., ensuring that layer prioritization, which resolves the interference between layers, is preserved during computation. To prove this property, we give a formal definition of layer priority that is general so that we can discuss the priorities of layers in other COP calculi and implementations. We implement a ServalCJ compiler, and demonstrate its effectiveness through several example applications.}
}


@Article{asakura2015jip,
  author = 	 asakura #and# masuhara #and# aotani,
  pdf = 	 {asakura2015jip.pdf},
  title = 	 {Proof of Soundness of Concurrent Separation Logic for {GPGPU} in {Coq}},
  journal = 	   JIP,
  year = 	 2016,
  month = 	 jan,
  pages = 	 {132--140},
  volume = 	 {24},
  number = 	 {1},
  doi = 	 {http://doi.org/10.2197/ipsjjip.24.132},
  note = 	 {\href{http://prg.is.titech.ac.jp/news/izumi-asakura-receives-award/}{IPSJ Computer Science Research Award for Young Scientists} and \href{http://prg.is.titech.ac.jp/news/ipsj-outstanding-paper-award/}{IPSJ Outstanding Paper Award}},
  annote = 	 {extended from \cite{asakura2015-ipsj-pro}, accepted: 2015-07-28},
  abstract = 	 {We design a concurrent separation logic for GPGPU, namely GPUCSL, and prove its soundness by using Coq. GPUCSL is based on a CSL proposed by Blom et al., which is for automatic verification of GPGPU kernels, but employs different inference rules because the rules in Blom's CSL are not standard. For example, Blom's CSL does not have a frame rule. Our CSL is a simple extension of the original CSL, and it is more suitable as a basis of advanced properties proposed for other studies on CSLs. Our soundness proof is based on Vafeiadis' method, which is for a CSL with a fork-join concurrency model. The proof reveals two problems in Blom's approach in terms of soundness and extensibility. First, their assumption that thread ID independence of a kernel implies barrier divergence freedom does not hold. Second, it is not easy to extend their proof to other CSLs with a frame rule. Although our CSL covers only a subset of CUDA, our preliminary experiment shows that it is useful and expressive enough to verify a simple kernel with barriers.},
}

@InProceedings{springer2016modularity,
  author = 	 springer #and# {Fabio Niephaus} #and# hirschfeld #and# masuhara,
  title = 	 {Matriona: Class Nesting with Parameterization in {Squeak/Smalltalk}},
  crossref =  {modularity2016},
  pdf = 	 {modularity2016.pdf},
  annote = 	 {Modularity Visions Track},
  pages = 	 {118--129},
  doi = 	 {10.1145/2889443.2889457},
  abstract = 	 {We present Matriona, a module system for Squeak, a Smalltalk dialect. It supports class nesting and parameterization and is based on a hierarchical name lookup mechanism. Matriona solves a range of modularity issues in Squeak. Instead of a flat class organization, it provides a hierarchical namespace, that avoids name clashes and allows for shorter local names. Furthermore, it provides a way to share behavior among classes and modules using mixins and class hierarchy inheritance (a form of inheritance that subclasses an entire class family), respectively. Finally, it allows modules to be externally configurable, which is a form of dependency management decoupling a module from the actual implementation of its dependencies.

Matriona is implemented on top of Squeak by introducing a new keyword for run-time name lookups through a reflective mechanism, without modifying the underlying virtual machine. We evaluate Matriona with a series of small applications and will demonstrate how its features can benefit modularity when porting a simple application written in plain Squeak to Matriona.}}

@Misc{springer2016-ppl-poster,
  author = 	 springer #and# masuhara,
  title = 	 {{Ikra}: Leveraging Object-Oriented Abstractions in a {Ruby-to-CUDA} {JIT} Translator
},
  pdf = 	 {ppl2016-ikra-poster.pdf},

  crossref =     {ppl2016},                  
  note = 	 {Poster presentation},
  howpublished = {18th JSSST Workshop on Programming and Programming Languages},
}


@InProceedings{masuhara2016foal,
  author = 	  	 masuhara #and# {Kenta Fujita} #and# aotani,
  title = 	 {An Advice Mechanism for Non-local Flow Control},
  pdf = 	 {foal2016.pdf},
  slides = 	 {foal2016-slides.pdf},
  crossref =  {foal2016},
  pages = 	 {73--78},
  keywords = 	 {AspectJ},
  doi = 	 {10.1145/2892664.2892674},
  abstract = 	 {We propose an advice mechanism called Chop&Graft for non-local flow control. It offers a novel chop pointcut that lets a piece of advice terminate the current execution, and graft and retry operators that resume and restart the terminated executions. By using pointcuts for specifying the region of termination, the mechanism is more robust and more concise than the traditional exception handling mechanisms that rely on names or exception classes. The paper presents the design of the mechanism along with the sketches of two implementations using delimited continuations or threads and exceptions.},
}

@InProceedings{khatchadourian2016lamod,
  author = 	 khatchadourian #and# {Olivia Moore} #and# masuhara,
  title = 	 {Towards Improving Interface Modularity in Legacy {Java} Software through Automated Refactoring},
  doi = 	 {10.1145/2892664.2892681},
  pdf = 	 {lamod2016-refactoring.pdf},
  crossref =  {lamod2016},
  pages = 	 {104--106},
  abstract = 	 {The skeletal implementation pattern is a software design pattern consisting of defining an abstract class that provides a partial interface implementation. However, since Java allows only single class inheritance, if implementers decide to extend a skeletal implementation, they will not be allowed to extend any other class. Also, discovering the skeletal implementation may require a global analysis. Java 8 enhanced interfaces alleviate these problems by allowing interfaces to contain (default) method implementations, which implementers inherit. Java classes are then free to extend a different class, and a separate abstract class is no longer needed; developers considering implementing an interface need only examine the interface itself. We argue that both these benefits improve software modularity, and discuss our ongoing work in developing an automated refactoring tool that would assist developers in taking advantage of the enhanced interface feature for their legacy Java software.},}

@InProceedings{kiriyama2016lamod,
  author = 	 kiriyama #and# aotani #and# masuhara,
  crossref = 	 {lamod2016},
  title = 	 {A Lightweight Optimization Technique for Data Types {\`a} la Carte},
  pdf = 	 {lamod2016-alacarte.pdf},
  pages = 	 {86--90},
  doi = 	 {10.1145/2892664.2892677},
  abstract = 	 {Data types a la carte (DTC) is a technique for adding new variants to data types modularly. A drawback of DTC compared with simple variant types, which are commonly used to define data types in functional programming languages, is runtime inefficiency caused by the destruction of these values. In this paper, we propose a lightweight optimization technique for functions that destruct the values of DTC data types. It makes their execution as efficient as their non-DTC counterparts by just (1) deriving non-extensible algebraic data types isomorphic to extensible data types defined in DTC fashion and (2) using them within the type annotations that specify concrete data types using the composition operator given in DTC. The approach is based on an insight on the functions: the functions never depend on any concrete data types but merely constrain them. We implemented functions that take an extensible data type defined in DTC fashion and derive an isomorphic non-extensible algebraic data type using Template Haskell. Our experimental results show that DTC functions using our approach run as efficiently as their non-DTC counterparts and avoid performance slow down even if the data types are extended multiple times.}}

@InProceedings{springer2016lassy,
  author = 	 springer #and# masuhara #and# hirschfeld,
  title = 	 {Hierarchical Layer-based Class Extensions in {Squeak/Smalltalk}},
  crossref =  {lassy2016},
  pages = 	 {107--112},
  doi = 	 {10.1145/2892664.2892682},
  pdf = 	 {lassy2016.pdf},
  abstract = 	 {Class extensions are frequently used in programming languages such as Ruby and Smalltalk to add or change methods of a class that is defined in the same application or in a different one. They suffer from modularity issues if globally visible: Other applications using the same classes are then affected by the modifications. This paper presents a hierarchical approach for dynamically scoping class extensions in dynamically-typed, class-based programming languages supporting class nesting. Our mechanism allows programmers to define the scope of class extensions and to reuse class extensions in other programs. Class extensions can be scoped according to a nested class hierarchy or based on whether programmers regard a potentially affected class as a black box or not. Class extensions are organized in layers, where multiple layers targeting the same class can be active at the same time.},
}

@InProceedings{kamina2016mass,
  author = 	 kamina #and# aotani #and# masuhara,
  title = 	 {Toward Fluent Module Interactions},
  crossref =  {mass2016},
  doi = 	 {10.1145/2892664.2892689},
  pdf = 	 {mass2016.pdf},
  pages = 	 {158--159},
  abstract = 	 {Recent progress on sensor technologies poses challenges on software development such as more interaction with physical environment and context-awareness. This trend makes it difficult to decide the boundaries between changing module interactions. In this paper, we propose a concept of fluent module interactions where we characterize the module interactions in three dimensions, i.e., definition, duration, and scope. Module interactions in any of those dimensions can change dynamically. We also propose a possible extension of existing programming language with fluent module interactions based on context-oriented programming (COP). Then, we derive a future research roadmap for realizing fluent module interactions that covers a wide range of research fields including theory, implementation, engineering, and applications.}}

2016-04-25
@Article{felgentreff2016jip,
  author = 	 {Tim Felgentreff} #and# hirschfeld #and# {Maria Graber} #and# {Alan Borning} #and# masuhara,
  title = 	 {Declaring Constraints on Object-Oriented Collections},
  pdf = 	 {ipsj-trans-pro-2016.pdf},
  journal = 	 JIP,
  year = 	 2016,
  volume = 	 24,
  number = 	 5,
  OPTurl = 	 {http://id.nii.ac.jp/1001/00174563/},
  cacheurl = 	 {http://prg.is.titech.ac.jp/members/masuhara/papers/ipsj-trans-pro-2016.pdf},
  
  pages = 	 {917--927},
  month = 	 nov,
  note = 	 {A preprint is also archived as IPSJ Transaction on Programming, 9(4), September 2016},
  annote = 	 {accepted: 2016-04-25},
  keywords = 	 {Squeak, Smalltalk},
  doi = 	 {10.2197/ipsjjip.24.917},
  abstract = 	 {Logic puzzles such as Sudoku are described by a set of properties that a valid solution must have. Constraints are a useful technique to describe and solve for such properties. However, constraints are less suited to express imperative interactions in a user interface for logic puzzles, a domain that is more readily expressed in the object-oriented paradigm. Object constraint programming provides a design to integrate constraints with dynamic, object- oriented programming languages. It allows developers to encode multi-way constraints over objects using existing, object-oriented abstractions. These constraints are automatically maintained at run-time. In this paper we present an application of this design to logic puzzles in the Squeak/Smalltalk programming environment, as well as an extension of the design and the formal semantics of Babelsberg to allow declaring constraints using the imperative collection API provided in Squeak. We argue that our implementation facilitates creating applications that use imperative construction of user interfaces and mutable program state as well as constraint satisfaction techniques for different parts of the system. The main advantage of our approach is that it moves the burden to maintain constraints from the developer to the runtime environment, while keeping the development experience close to the purely object-oriented approach.}
}

2016-06-08
@InProceedings{huang2016tfp,
  author = 	 huang #and# masuhara #and# aotani,
  pdf = 	 {tfp2016.pdf},
  title = 	 {Improving Sequential Performance of {Erlang} based on a Meta-tracing Just-In-Time Compiler},
  booktitle="Trends in Functional Programming",
  publisher=SV,
  OPTurl = 	 {https://link.springer.com/chapter/10.1007/978-3-030-14805-8_3},
  doi = 	 {10.1007/978-3-030-14805-8_3},
  abstract="In widely-used actor-based programming languages, such as Erlang, sequential execution performance is as important as scalability of concurrency. In order to improve sequential performance of Erlang, we develop Pyrlang, an Erlang virtual machine with a just-in-time (JIT) compiler by applying an existing meta-tracing JIT compiler. In this paper, we overview our implementation and present the optimization techniques for Erlang programs, most of which heavily rely on function recursion. Our preliminary evaluation showed approximately 38{\%} speedup over the standard Erlang interpreter.",
  pages="44--58",
  year = 	 2016,
  month = 	 jun,
  editor="Van Horn, David and Hughes, John",
  date = 	 {2016-06-08},
  location = 	 {University of Maryland, College Park, Maryland, USA},
  note = 	 {Post-sympoisum proceedings will be published in 2017.},
  date = 	 {presentation: 2016-06-08, notification: 2016-11-10},
  keywords = 	 {PyPy, RPython},
  isbn="978-3-030-14805-8"
}

2016-06-14
@inproceedings{springer2016array,
  author = 	 springer #and# masuhara,
 title = {Object Support in an Array-based {GPGPU} Extension for {Ruby}},
 booktitle = {Proceedings of the 3rd ACM SIGPLAN International Workshop on Libraries, Languages, and Compilers for Array Programming},
 series = {ARRAY 2016},
 year = 2016,
 date = 	 {2016-06-14},
  month = 	 jun,
 isbn = {978-1-4503-4384-8},
 location = {Santa Barbara, CA, USA},
 pages = {25--31},
 numpages = 7,
 OPTurl = {http://doi.acm.org/10.1145/2935323.2935327},
 doi = {10.1145/2935323.2935327},
 acmid = 2935327,
 publisher = {ACM},
 address = {New York, NY, USA},
 keywords = {CUDA, GPGPU, Ruby, Object-Oriented Programming},
  pdf = 	 {array2016.pdf},
  abstract = 	 {This paper presents implementation and optimization techniques to support objects in Ikra, an array-based parallel extension to Ruby with dynamic compilation. The high-level goal of Ikra is to allow developers to exploit GPU-based high-performance computing without paying much attention to intricate details of the underlying GPU infrastructure and CUDA.

Ikra supports dynamically-typed object-oriented programming in Ruby and performs a number of optimizations. It supports parallel operations (e.g., map, each) on arrays of polymorphic objects, allowing polymorphic method calls inside a kernel by compiling them to conditional branches. To reduce branch divergence, Ikra shuffles thread assignments to base array elements based on runtime types of elements. To facilitate memory coalescing, Ikra stores objects in a structure-of-arrays (SoA) representation (columnar object layout). To eliminate intermediate data in global memory, Ikra merges cascaded parallel sections into one kernel using symbolic execution.},
} 
                  
2016-07-19
@inproceedings{springer2016cop,
  author = 	 springer #and# masuhara #and# hirschfeld,
  title = {Classes As Layers: Rewriting Design Patterns with {COP}: Alternative Implementations of Decorator, Observer, and Visitor},
  pdf = 	 {cop2016.pdf},
 booktitle = {Proceedings of the 8th International Workshop on Context-Oriented Programming},
 series = {COP'16},
  month = 	 jul,
 year = {2016},
 isbn = {978-1-4503-4440-1},
  date = 	 {2016-07-19},
 location = {Rome, Italy},
 pages = {21--26},
 numpages = {6},
 OPTurl = {http://doi.acm.org/10.1145/2951965.2951968},
 doi = {10.1145/2951965.2951968},
 acmid = {2951968},
 publisher = {ACM},
 address = {New York, NY, USA},
 keywords = {Context-Oriented Programming, Decorator, Design Patterns, Layers, Observer, Visitor, Squeak, Smalltalk},
  abstract = 	 {This paper analyzes and presents alternative implementations of three well-known Gang of Four design patterns: Decorator, Observer, and Visitor. These implementations are more than mere refactorings and take advantage of a variant of context-oriented programming that unifies classes and layers to overcome shortcomings in a conventional, object-oriented implementation.},
} 

2016-07-19
@Misc{springer2016ecoop-poster,
  author = 	 Springer #and# Masuhara #and# Hirschfeld,
  title = 	 {Classes as Layers: Rewriting Design Patterns with {COP}},
  pdf = 	 {ecoop2016-poster.pdf},
  url = 	 {https://2016.ecoop.org/details/Posters/17/Classes-as-Layers-Rewriting-Design-Patterns-with-COP},
  howpublished = {Poster Presentation at ECOOP'16},
  month = 	 jul,
  year = 	 2016,
  day = 	 {2016-07-20},
  location = 	 {Rome, Italy},
  keywords = 	 {Squeak, Smalltalk}}

@Misc{springer2016pro,
  author = 	 Springer #and# Masuhara #and# Hirschfeld,
  title = 	 {A Layer-based Approach to Hierarchical Dynamically-scoped Open Classes},
  note = 	 {Published as \cite{springer2017jip}},
  url = 	 {https://sigpro.ipsj.or.jp/pro2016-2/},
  howpublished = IPSJ-PRO-PRE # {110} # IPSJ-PRO-POST # {2016-2-(6)},

  month = 	 aug,
  year = 	 2016,
  day  = 	 {2016-08-10},
  keywords = 	 {Squeak, Smalltalk}}


2016-09-13
@Article{taeumel2017compsoft,
  author = 	 {Marcel Taeumel and Stephanie Platz and Bastian Steinert} #and# hirschfeld #and# masuhara,
  title = 	 {Unravel Programming Sessions with {THRESHER}: Identifying Coherent and Complete Sets of Fine-granular Source Code Changes},
  journal = 	 CompSoft,
  year = 	 2017,
  volume = 	 34,
  note = 	 {JSSST Best Research Paper Award},
  pdf = 	 {compsoft2017.pdf},
  number = 	 1,
  pages = 	 {103--118},
  month = 	 feb,
  annote = 	 {Accepted 2016-09-13, Published 2017-01-25},
  keywords = 	 {Squeak, Smalltalk},
  doi = 	 {10.11309/jssst.34.1_103},
  abstract = 	 {Development teams benefit from version control systems, which manage shared access to code repositories and persist entire project histories for analysis or recovery. Such systems will be efficient if developers commit coherent and complete change sets. These best practices, however, are difficult to follow because multiple activities often interleave without notice and existing tools impede unraveling changes before committing them. We propose an interactive, graphical tool, called Thresher, that employs adaptable scripts to support developers to group and commit changes---especially for fine-granular change tracking where numerous changes are logged even in short programming sessions. We implemented our tool in Squeak/Smalltalk and derived a foundation of scripts from five refactoring sessions. We evaluated those scripts' precision and recall, which indicate a reduced manual effort because developers can focus on project-specific adjustments. Having such an interactive approach, they can easily intervene to accurately reconstruct activities and thus follow best practices.}
}

2016-10-26
@Article{springer2017jip,
  author = 	 Springer #and# Masuhara #and# Hirschfeld,
  title = 	 {A Layer-based Approach to Hierarchical Dynamically-scoped Open Classes},
  pdf = 	 {jip2017.pdf},
  journal = 	 JIP,
  year = 	 2017,
  volume={25},
  OPTnumber = 	 { },
  pages={296-307},
  month = 	 mar,
  doi={10.2197/ipsjjip.25.296},
  annote = 	 {Revised version of \cite{springer2016pro}, received 2016-07-08, accepted 2016-10-26},
  note = 	 {Also published in IPSJ Transactions on Programming.},
  keywords = 	 {Squeak, Smalltalk},
  abstract = 	 {Open classes are frequently used in programming languages such as Ruby and Smalltalk to add or change methods of a class that is defined in the same component or in a different one. They are typically used for bug fixing, multi-dimensional separation of concerns, or to modularly add new operations to an existing class. However, they suffer from modularity issues if globally visible: Other components using the same classes are then affected by their modifications. This work presents Extension Classes, a hierarchical approach for dynamically scoping such modifications in Ruby, built on top of ideas from Context-oriented Programming (COP). Our mechanism organizes modifications in classes and allows programmers to define their scope according to a class nesting hierarchy and based on whether programmers regard an affected class as a black box or not. Moreover, Extension Classes support modularizing modifications as mixins, such that they can be reused in other components.}
}

2016-11-21
@Misc{asakura2016aplas-poster,
  pdf = 	 {aplas2016.pdf},
  author = 	 asakura #and# masuhara #and# aotani,
  title = 	 {Towards a Formally Verified Skeleton-based Data Parallel {DSL} for {GPGPU}},
  url = 	 {http://www.fos.kuis.kyoto-u.ac.jp/aplas2016/accepted-posters/},
  location = 	 {Hanoi, Vietnam},
  howpublished = {14th Asian Symposium on Programming Languages and Systems (APLAS 2016), poster presentation},
  month = 	 nov,
  year = 	 2016,
  date = 	 {2016-11-21},
  keywords = 	 {Coq, CertSkel}
}

2017-01-21
@InProceedings{asakura2017coqpl,
  author = 	 asakura #and# masuhara #and# aotani,
  url = 	 {https://popl17.sigplan.org/track/main},
  pdf = 	 {coqpl2017.pdf},
  title = 	 {{CertSkel}: a Verified Compiler for a {Coq}-embedded {GPGPU DSL}},
  booktitle = {Proceedings of The Third International Workshop on Coq for Programming Languages (CoqPL 2017), colocated with PoPL'17},
  year = 	 2017,
  OPTpages = 	 {},
  month = 	 jan,
  location = 	 {Paris, France},
  note = 	 {},
  date = 	 {2017-01-21}}
                  
2017-03-08
@Misc{springer2017ppl-poster,
  key = 	 {
  },
  author = 	 springer #and# {Peter Wauligmann} #and# masuhara,
  title = 	 {Iterative Stencil Computations in {Ruby} on {GPUs}},
  pdf = 	 {ppl2017.pdf},
  booktitle =    {19th JSSST SIGPPL Workshop on Programming and Programming Languages (PPL2017)},
  date = 	 {2017-03-08},
  howpublished = {Poster presentation at PPL'17},
  month = 	 mar,
  day = 	 {8--10},
  year = 	 2017,
  url = {https://ppl2017.ipl-e.ai.kyutech.ac.jp/},
  keywords = 	 {Ikra},
  location = {Fuefuki, Yamanashi, Japan}
  }


2017-04-04
@InProceedings{oka2017px,
  author = 	 Oka #and# Masuhara #and# Imai #and# Aotani,
  title = 	 {Live Data Structure Programming},
  booktitle = {Proceedings of the 2nd Edition of the Programming Experience Workshop (PX/17) in Companion to the First International Conference on the Art, Science and Engineering of Programming},
  year = 	 2017,
  editor = 	 {Richard P. Gabriel and Robert Hirschfeld and Hidehiko Masuhara},
 series = {Programming '17},
  pages = 	 {26:1--26:7},
  month = 	 apr,
 isbn = {978-1-4503-4836-2},
 url = {http://doi.acm.org/10.1145/3079368.3079400},
  pdf = 	 {px2017.pdf},
 doi = {10.1145/3079368.3079400},
  location = 	 {Vreij Universitat Brussels},
  OPTorganization = {.},
 publisher = {ACM},
 keywords = {Live programming, data structures, object graph, Kanon, JavaScript},
  date = 	 {2017-04-04},
  abstract = 	 {When we write a program that manipulates data structures, we often draw and manipulate a visual image of the structures in our mind. In order to immediately connect those mental images with the data objects created by the program, we propose a live programming environment, called Kanon, specialized for data structure programming. It automatically executes a program being edited, and draws objects and their mutual references as a node-link diagram. In order to visualize information relevant to the programmer's concern, it offers two visualization modes based on the cursor position in the editor. It also offers two interactive mechanisms that relate elements in the program to elements on the diagram, and vice versa. The implementation includes a novel technique for mental map preservation of visual diagrams.},
}

2017-05-24
@inproceedings{khatchadourian2017icse,
  month = 	 may,
  pdf = 	 {icse2017.pdf},
 author = khatchadourian #and# Masuhara,
 title = {Automated Refactoring of Legacy {Java} Software to Default Methods},
 OPTbooktitle = {Proceedings of the 39th International Conference on Software Engineering},
  crossref = 	 {icse2017},
 OPTseries = {ICSE '17},
 year = {2017},
 isbn = {978-1-5386-3868-2},
 location = {Buenos Aires, Argentina},
 pages = {82--93},
  date = 	 {2017-05-24},
 numpages = {12},
 url = {https://doi.org/10.1109/ICSE.2017.16},
 doi = {10.1109/ICSE.2017.16},
 acmid = {3097379},
 publisher = {IEEE Press},
 address = {Piscataway, NJ, USA},
 keywords = {Java, default methods, interfaces, refactoring},
  abstract = 	 {Java 8 default methods, which allow interfaces to contain (instance) method implementations, are useful for the skeletal implementation software design pattern. However, it is not easy to transform existing software to exploit default methods as it requires analyzing complex type hierarchies, resolving multiple implementation inheritance issues, reconciling differences between class and interface methods, and analyzing tie-breakers (dispatch precedence) with overriding class methods to preserve type-correctness and confirm semantics preservation. In this paper, we present an efficient, fully-automated, type constraint-based refactoring approach that assists developers in taking advantage of enhanced interfaces for their legacy Java software. The approach features an extensive rule set that covers various corner-cases where default methods cannot be used. To demonstrate applicability, we implemented our approach as an Eclipse plug-in and applied it to 19 real-world Java projects, as well as submitted pull requests to popular GitHub repositories. The indication is that it is useful in migrating skeletal implementation methods to interfaces as default methods, sheds light onto the pattern's usage, and provides insight to language designers on how this new construct applies to existing software.},
} 

2017-06-18
@inproceedings{springer2017array,
 author = springer #and# {Wauligmann, Peter} #and# Masuhara,
  pdf = 	 {array2017.pdf},
 title = {Modular Array-based {GPU} Computing in a Dynamically-typed Language},
 booktitle = {Proceedings of the 4th ACM SIGPLAN International Workshop on Libraries, Languages, and Compilers for Array Programming (ARRAY2017)},
  month = 	 jun,
 series = {ARRAY 2017},
 year = {2017},
 isbn = {978-1-4503-5069-3},
 location = {Barcelona, Spain},
 pages = {48--55},
 numpages = {8},
 url = {http://doi.acm.org/10.1145/3091966.3091974},
 doi = {10.1145/3091966.3091974},
 acmid = {3091974},
 publisher = {ACM},
 address = {New York, NY, USA},
 keywords = {CUDA, GPGPU, Ruby, kernel fusion, Ikra},
 date = {2017-06-18},
  abstract = 	 {Nowadays, GPU accelerators are widely used in areas with large data-parallel computations such as scientific computations or neural networks. Programmers can either write code in low-level CUDA/OpenCL code or use a GPU extension for a high-level programming language for better productivity. Most extensions focus on statically-typed languages, but many programmers prefer dynamically-typed languages due to their simplicity and flexibility.

This paper shows how programmers can write high-level modular code in Ikra, a Ruby extension for array-based GPU computing. Programmers can compose GPU programs of multiple reusable parallel sections, which are subsequently fused into a small number of GPU kernels. We propose a seamless syntax for separating code regions that extensively use dynamic language features from those that are compiled for efficient execution. Moreover, we propose symbolic execution and a program analysis for kernel fusion to achieve performance that is close to hand-written CUDA code.}
} 

2017-06-19
@inproceedings{Springer2017icooolps,
 author = Springer #and# {Krieger, Andrew and Manilov, Stanislav} #and# masuhara,
 title = {{Dart2Java}: Running {Dart} in {Java}-based Environments},
 booktitle = {Proceedings of the 12th Workshop on Implementation, Compilation, Optimization of Object-Oriented Languages, Programs and Systems (ICOOOLPS'17)},
 series = {ICOOOLPS'17},
 year = {2017},
 isbn = {978-1-4503-5088-4},
 location = {Barcelona, Spain},
 pages = {1:1--1:6},
 articleno = {1},
 numpages = {6},
 OPTurl = {http://doi.acm.org/10.1145/3098572.3098575},
  pdf = 	 {icooolps2017.pdf},
  month = 	 jun,
 doi = {10.1145/3098572.3098575},
 acmid = {3098575},
 publisher = {ACM},
 address = {New York, NY, USA},
 keywords = {Dart, Java, compiler, source code generation},
 date = {2017-06-19},
  abstract = 	 {We present the design and implementation of dart2java, an experimental Dart to Java compiler. It is implemented in Dart and currently supports many but not all Dart language constructs. dart2java is a playground to evaluate performance implications of running Dart code on the JVM and to investigate if it is possible to write Dart code in a largely Java-dominated environment.

This paper describes the architecture of dart2java, performance optimizations such as non-nullability of primitive types and generic specialization (and their implications), as well as ideas for language interoperability, i.e., calling Java code from Dart and vice versa.},
}

2017-06-20
@InProceedings{kamina2017cop,
  author = 	 kamina #and# aotani #and# masuhara,
  pdf = 	 {cop2017.pdf},
  title = 	 {Push-based Reactive Layer Activation in Context-Oriented Programming},
  crossref = {cop2017},
 pages = {17--21},
  date = 	 {2017-06-20},
 doi = {10.1145/3117802.3117805},
  month = 	 jun,
 keywords = {implicit layer activation, reactive values, transition processes},
  year = 	 2017,
  abstract = 	 {There are context-dependent behaviors that are active only when
a certain condition holds, and that require a certain transition process before activation. We propose a layer-activation mechanism of context-oriented programming languages for such context-dependent behaviors. Our mechanism supports the implicit layer activation (as opposed to the event-based layer activation) in a sense that a condition of activation is written as a conditional expression over reactive values (e.g., values obtained from sensors). In addition, it is push-based in a sense that it executes the transition process immediately after the condition becomes valid (as opposed to the mechanisms that defer the transition process until the first execution of a context-dependent behavior). In this paper, we present how this mechanism works in an extension of ServalCJ with push-based reactive values, and identify open issues raised by this proposal.},
}

2017-06-26
@article{khatchadourian2017scp,
    title = "Detecting Broken Pointcuts Using Structural Commonality and Degree of Interest",
    journal = "Science of Computer Programming ",
    volume = 150,
    OPTnumber = ".",
    pages = "56--74",
    year = 2017,
    note = "accepted 2017-06-26",
  month = 	 dec,
    issn = "0167-6423",
    doi = "10.1016/j.scico.2017.06.011",
    url = "http://www.sciencedirect.com/science/article/pii/S0167642317301326",
    author = "Raffi Khatchadourian and Awais Rashid "#and# masuhara #and# watanabe,
  pdf = 	 {scp2017.pdf},
    keywords = "Software development environments",
    keywords = "Software maintenance",
    keywords = "Software tools ",
  keywords = 	 {AspectJ},
  abstract = 	 {Pointcut fragility is a well-documented problem in Aspect-Oriented Programming; changes to the base-code can lead to join points incorrectly falling in or out of the scope of pointcuts. Deciding which pointcuts have broken due to base-code changes is a daunting venture, especially in large and complex systems. We present an automated approach that recommends pointcuts that are likely to require modification due to a particular base- code change, as well as ones that do not. Our hypothesis is that join points selected by a pointcut exhibit common structural characteristics. Patterns describing such commonality are used to recommend pointcuts that have potentially broken with a degree of confidence as the developer is typing. The approach is implemented as an extension to the popular Mylyn Eclipse IDE plug-in, which maintains focused contexts of entities relevant to the task at hand using a Degree of Interest (DOI) model. We show that it is accurate in revealing broken pointcuts by applying it to multiple versions of several open source projects and evaluating the quality of the recommendations produced against actual modifications. We found that our tool made broken pointcuts 2.14 times more interesting in the DOI model than unbroken ones, with a p-value under 0.1, indicating a significant difference in final DOI value between the two kinds of pointcuts (i.e., broken and unbroken).
}
}

2017-08-09
@Article{asakura2017jip,
  pdf = 	 {ipsj-trans-pro-2017.pdf},
  author = 	 asakura #and# masuhara #and# {Takuya Matsumoto and Kiminori Matsuzaki},
  title = 	 {Identification and Elimination of the Overhead of {Accelerate} with a Super-Resolution Application},
  keywords = 	 {Haskell, GPGPU},
  journal = 	 JIP,
  year = 	 2018,
  volume = 	 26,
  OPTnumber = 	 {.},
  pages = 	 {48--53},
  month = 	 jan,
  annote = 	 {presented as IPSJ PRO 2017-1-(3), also appears in IPSJ Trans. PRO},
  doi = 	 {10.2197/ipsjjip.26.48},
  note = 	 {Accepted on 2017-08-09.  \href{http://id.nii.ac.jp/1001/00184819}{A preprint is also archived as IPSJ Transaction on Programming, 10(6), December 2017}},
  abstract = 	 {This paper supplements the evaluation of libraries for parallel computing in Haskell by Matsumoto and Matsuzaki. The previous work implemented an image processing program by using two different libraries and compared expressiveness and parallel execution performance. In particular, it found that a parallel execution of the Accelerate program on a GPU is slower than the execution of the handwritten CUDA-C program by a factor of more than 70. We analyzed the execution of the Accelerate program and identified that the major sources of the overhead are in the process of the syntax tree before execution of a GPU kernel. Since the program realizes repeated execution by constructing a large syntax tree whose size is proportional to the number of repetitions, we rewrote this part by using a while-construct, which significantly reduces the overhead as it runs half as fast as the CUDA-C program. We also discuss language design alternatives for avoiding this type of overhead.}
}

2017-09-21
@Misc{khatchadourian2017icse-invited,
  slides = 	 {jssst2017-slides.pdf},
  author = 	 khatchadourian #and# masuhara,
  title = 	 {Automated Refactoring of Legacy {Java} Software to Default Methods},
  note = {reproduction of the ICSE'17 talk at JSSST Annual Conference},
  month = 	 sep,
  date = 	 {2017-09-21},
  year = 	 2017,
  location = 	 {Keio University, Hiyoshi, Japan}
  }
2017-11-01
@INPROCEEDINGS{khatchadourian2017ase-demo,
  pdf = 	 {ase2017.pdf},
  author = 	 khatchadourian #and# masuhara,
booktitle={2017 32nd IEEE/ACM International Conference on Automated Software Engineering (ASE)},
title={Defaultification refactoring: A tool for automatically converting {Java} methods to default},
year={2017},
volume={},
number={},
pages={984-989},
keywords={Java;Object-Oriented Programming;software maintenance;Java 8 default methods;Java methods;MIGRATE Skeletal Implementation;automated refactoring tool;complex type hierarchies;defaultification refactoring;dispatch precedence;legacy Java code;legacy software;method implementations;multiple implementation inheritance issues;refactoring approach;semantics preservation;type constraint;ubiquitous skeletal implementation software design pattern;Computer architecture;Java;Semantics;Software;Software engineering;Tools;default methods;eclipse;interfaces;java;refactoring;type constraints},
doi={10.1109/ASE.2017.8115716},
ISSN={},
month=nov,
  date = 	 {2017-11-01},
  location = 	 {University of Illinois at Urbana-Champaign},
  abstract = 	 {Enabling interfaces to declare (instance) method implementations, Java 8 default methods can be used as a substitute for the ubiquitous skeletal implementation software design pattern. Performing this transformation on legacy software manually, though, may be non-trivial. The refactoring requires analyzing complex type hierarchies, resolving multiple implementation inheritance issues, reconciling differences between class and interface methods, and analyzing tie-breakers (dispatch precedence) with overriding class methods. All of this is necessary to preserve type-correctness and confirm semantics preservation. We demonstrate an automated refactoring tool called MIGRATE SKELETAL IMPLEMENTATION TO INTERFACE for transforming legacy Java code to use the new default construct. The tool, implemented as an Eclipse plug-in, is driven by an efficient, fully-automated, type constraint-based refactoring approach. It features an extensive rule set covering various corner-cases where default methods cannot be used. The resulting code is semantically equivalent to the original, more succinct, easier to comprehend, less complex, and exhibits increased modularity. A demonstration can be found at http://youtu.be/YZHIy0yePh8.},}

2018-01-21
@Article{kamina2018scp,
  pdf = 	 {scp2018.pdf},
  author = 	 kamina #and# aotani #and# masuhara #and# igarashi,
  title = 	 {Method Safety Mechanism for Asynchronous Layer Deactivation},
  keywords = 	 {Context-Oriented Programming},
  journal = 	 scp,
  year = 	 2018,
  volume = 	 156,
  date = 	 {2018-05-01},
  annote = 	 {Received 17 February 2016, Revised 15 January 2018, Accepted 21 January 2018, Available online 20 February 2018.},
  pages = 	 {104--120},
  doi = 	 {https://doi.org/10.1016/j.scico.2018.01.006},
  month = 	 may,
  url = 	 {https://www.sciencedirect.com/science/article/pii/S0167642318300236},
  abstract = 	 {Context-oriented programming (COP) enhances the modularity of context-dependent behavior in context-aware systems, as it provides modules to implement context- dependent behavior (layers) and composes them dynamically in a disciplined manner (layer activation). We propose a COP language that enables layers to define base methods, while the layers can be asynchronously activated and deactivated. Base methods in layers enhance modularity because they extend the interface of classes without modifying original class definitions. However, calling such a method defined in a layer is problematic as the layer may be inactive when the method is called. We address this problem by introducing a method lookup mechanism that uses the static scope of method invocation for COP; i.e., in addition to currently activated layers, the layer where the method invocation is written, as well as the layers on which that layer depends, are searched during method lookup. We formalize this mechanism as a small calculus referred to as ContextFJ a and prove its type soundness. We implement this mechanism in ServalCJ, a COP language that supports asynchronous, as well as synchronous, layer activation.},
}

2018-02-24
@InProceedings{springer2018wpmvp,
  pdf = 	 {wpmvp2018.pdf},
  author = 	 springer #and# masuhara,
  title = 	 {{Ikra-Cpp}: A {C++/CUDA} {DSL} for Object-OrientedProgramming with Structure-of-Arrays Layout},
  booktitle = {Proceedings of the 2018 4th Workshop on Programming Models for SIMD/Vector Processing (WPMVP 2018)},
 series = {WPMVP'18},
  year = 	 2018,
 isbn = {978-1-4503-5646-6},
 articleno = {6},
 pages = {6:1--6:9},
 numpages = 9,
 doi = {10.1145/3178433.3178439},
  month = 	 feb,
  date = 	 {2018-02-24},
  location = 	 {Vienna, Austria},
  annote = 	 {no formal proceedings},
  url = 	 {https://ppopp18.sigplan.org/details/WPMVP2018/6/Ikra-Cpp-A-C-CUDA-DSL-for-Object-Oriented-Programming-with-Structure-of-Arrays-Lay},
 acmid = 3178439,
 publisher = {ACM},
 address = {New York, NY, USA},
 keywords = {C++, CUDA, Object-Oriented Programming, SIMD, Structure of Arrays, Template Metaprogramming},
  abstract = 	 {Structure of Arrays (SOA) is a well-studied data layout technique for SIMD architectures. Previous work has shown that it can speed up applications in high-performance computing by several factors compared to a traditional Array of Structures (AOS) layout. However, most programmers are used to AOS-style programming, which is more readable and easier to maintain. We present Ikra-Cpp, an embedded DSL for object-oriented programming in C++/CUDA. Ikra-Cpp's notation is very close to standard AOS-style C++ code, but data is layouted as SOA. This gives programmers the performance benefit of SOA and the expressiveness of AOS-style object-oriented programming at the same time. Ikra-Cpp is well integrated with C++ and lets programmers use C++ notation and syntax for classes, elds, member functions, constructors and instance creation.},
  }

2018-03-29
@Article{khatchadourianandmasuhara2018programming,
  pdf = 	 {programming2018.pdf},
  author = 	 khatchadourian #and# masuhara,
  title = 	 {Proactive Empirical Assessment of New Language Feature Adoption via Automated Refactoring: The Case of {Java} 8 Default Methods},
  journal = 	 programming-journal,
  year = 	 2018,
  volume = 	 2,
  number = 	 1,
  month = 	 mar,
  doi = 	 {https://doi.org/10.22152/programming-journal.org/2018/2/6},
  date = 	 {2018-03-29},
  submitted = 	 {2017-08-04},
  note = 	 {Article no.6},
  abstract = 	 {Programming languages and platforms improve over time, sometimes resulting in new language features that offer many benefits. However, despite these benefits, developers may not always be willing to adopt them in their projects for various reasons. In this paper, we describe an empirical study where we assess the adoption of a particular new language feature. Studying how developers use (or do not use) new language features is important in programming language research and engineering because it gives designers insight into the usability of the language to create meaning programs in that language. This knowledge, in turn, can drive future innovations in the area. Here, we explore Java 8 default methods, which allow interfaces to contain (instance) method implementations.

Default methods can ease interface evolution, make certain ubiquitous design patterns redundant, and improve both modularity and maintainability. A focus of this work is to discover, through a scientific approach and a novel technique, situations where developers found these constructs useful and where they did not, and the reasons for each. Although several studies center around assessing new language features, to the best of our knowledge, this kind of construct has not been previously considered.

Despite their benefits, we found that developers did not adopt default methods in all situations. Our study consisted of submitting pull requests introducing the language feature to 19 real-world, open source Java projects without altering original program semantics. This novel assessment technique is proactive in that the adoption was driven by an automatic refactoring approach rather than waiting for developers to discover and integrate the feature themselves. In this way, we set forth best practices and patterns of using the language feature effectively earlier rather than later and are able to possibly guide (near) future language evolution. We foresee this technique to be useful in assessing other new language features, design patterns, and other programming idioms.}}

2018-06-19
@inproceedings{springer2018array,
  author    = springer #and# {Yaozhu Sun} #and# masuhara,
  pdf = 	 {array2018.pdf},
  title     = {Inner Array Inlining for Structure of Arrays Layout},
  booktitle = {Proceedings of the 5th {ACM} {SIGPLAN} International Workshop on Libraries,
               Languages, and Compilers for Array Programming (ARRAY@PLDI 2018)},
  pages     = {50--58},
  year      = {2018},
  month = 	 jun,
  OPTcrossref  = {DBLP:conf/pldi/2018array},
  url       = {http://doi.acm.org/10.1145/3219753.3219760},
  doi       = {10.1145/3219753.3219760},
  timestamp = {Tue, 10 Jul 2018 08:34:20 +0200},
  biburl    = {https://dblp.org/rec/bib/conf/pldi/SpringerSM18},
  bibsource = {dblp computer science bibliography, https://dblp.org},
  location = 	 {Philadelphia, Pennsylvania, USA},
  keywords = 	 {Ikra, CUDA, C++},
  abstract = 	 {Previous work has shown how the well-studied and SIMD-friendly Structure of Arrays (SOA) data layout strategy can speed up applications in high-performance computing compared to a traditional Array of Structures (AOS) data layout. However, a standard SOA layout cannot handle structures with inner arrays; such structures appear frequently in graph-based applications and object-oriented designs with associations of high multiplicity.

This work extends the SOA data layout to structures with array-typed fields. We present different techniques for in-lining (embedding) inner arrays into an AOS or SOA layout, as well as the design and implementation of an embedded C++/CUDA DSL that lets programmers write such layouts in a notation close to standard C++. We evaluate several layout strategies with a traffic flow simulation, an important real-world application in transport planning.}
}

2018-07-16
@inproceedings{tanabe2018cop,
 author = {Yudai Tanabe}  #and# aotani #and# masuhara,
 title = {A Context-Oriented Programming Approach to Dependency Hell},
 booktitle = {Proceedings of the 10th International Workshop on Context-Oriented Programming: Advanced Modularity for Run-time Composition},
 series = {COP '18},
 year = 2018,
 isbn = {978-1-4503-5722-7},
 location = {Amsterdam, Netherlands},
  month = 	 jul,
  date = 	 {2018-07-16},
 pages = {8--14},
 numpages = {7},
 url = {http://doi.acm.org/10.1145/3242921.3242923},
  pdf = 	 {cop2018.pdf},
 doi = {10.1145/3242921.3242923},
 acmid = {3242923},
 publisher = {ACM},
 address = {New York, NY, USA},
 keywords = {Coeffects, Context-Oriented Programming, Contexts},
  abstract = 	 {Two or more incompatible versions of a library are sometimes
needed in one software artifact, which is so-called dependency hell.
One likely faces the problem if he or she uses two or more libraries
that depend on the same library. In this paper, we propose versioned
values to solve the problem. They allow us to have multiple versions
of functions in a binary file. This gets rid of requiring two or more
incompatible binaries. We develop a calculus $\lambda_{VL}$  to discuss type
safety in the case where definitions are available only in specific
versions, which is a common and important nature of versioned
programs.},
}

2018-08-29
@InProceedings{hirschfeld2018jssst,
  author = 	 hirschfeld #and# {Tobias Durschmid} #and# {Patrick Rein} #and# {Marcel Taeumel} #and# masuhara,
  pdf = 	 {jssst2018.pdf},
  title = 	 {Narratives for Multi-party Mechanisms and Concerns},
  crossref =  {jssst2018e},
  pages = 	 {No.~5-S},
  date = 	 {2018-08-29},
    keywords = 	 {Smalltalk},
  review = 	 {false},
  abstract = 	 {Cross-cutting concerns are an inherent property of the implementation of non-trivial software systems. Their study led to the development of advanced modularity constructs, usually supported by meta-level frameworks and programming language constructs, to improve comprehensibility. Because of their invasive nature, systems need to be refactored or rewritten to take advantage of these constructs. However, practical considerations such as organizational or economical constraints often do not allow for such reengineering efforts, leaving those systems without explicit representations of their cross-cutting concerns. We propose a lightweight, non-invasive approach to explicate and document cross-cutting, multi-party concerns called Crosscutting Commentary, or Commentary for short. Our proposal is based on the observation that comments are co-located with the individual semantic units they are about and with that scattered and tangled in the absence of advanced modularity constructs for crosscutting concerns and the assumption that well-crafted, informal explanations of system properties (their intents and the mechanisms they provide) improve comprehensibility. Commentaries are to help communicate narratives about system properties that involve multiple participants, both co-located in a single module or crosscutting several of them, and allow for navigating to, from, and between them to explore the implementation artifacts involved. Commentary was inspired by layers introduced with Context-oriented Programming to associate and manage partial definitions of system elements. While layers contribute to system comprehension during development and software composition at run-time, Commentary focuses on narratives for system exploration. We present our first attempt to provide Commentaries in Squeak/Smalltalk. We explain implementation details and discuss several application scenarios considering the documentation of basic mechanisms of this programming and runtime environment.}}

2018-11-05
@Misc{oka2018plateu,
  author = 	 oka #and# masuhara #and# aotani,
  title = 	 {(Preview) Live, Synchronized, and Mental Map Preserving Visualization for Data Structure Programming},
  howpublished = {Talk at PLATEU Workshop 2018},
  month = 	 nov,
  year = 	 2018,
  url = 	 {https://2018.splashcon.org/details/plateau-2018-papers/14/Live-Synchronized-and-Mental-Map-Preserving-Visualization-for-Data-Structure-Progra},
  keywords = 	 {JavaScript, Kanon},
  date = 	 {2018-11-05}}

2018-11-08
@inproceedings{oka2018onward,
  author = 	 oka #and# masuhara #and# aotani,
  title = 	 {Live, Synchronized, and Mental Map Preserving Visualization for Data Structure Programming},
 booktitle = {Proceedings of the 2018 ACM SIGPLAN International Symposium on New Ideas, New Paradigms, and Reflections on Programming and Software},
 series = {Onward! 2018},
  OPTannote = {submitted 2018-04-01},
  month = 	 nov,
  year = 	 2018,
  date = 	 {2018-11-08},
   isbn = {978-1-4503-6031-9},
 location = {Boston, MA, USA},
 pages = {72--87},
 numpages = {16},
 url = {http://doi.acm.org/10.1145/3276954.3276962},
 doi = {10.1145/3276954.3276962},
 acmid = {3276962},
 publisher = {ACM},
  keywords = 	 {Kanon, JavaScript},
 address = {New York, NY, USA},
 keywords = {Live programming, data structures, object graph},
  pdf = 	 {onward2018.pdf},
  abstract = 	 {Live programming is an activity in which the programmer edits code while observing the result of the program. It has been exercised mainly for pedagogical and artistic purposes, where outputs of a program are not straightforwardly imagined. While most live programming environments so far target programs that explicitly generate visual or acoustic outputs, we believe that live programming is also useful for data structure programming, where the programmer often has a hard time to grasp a behavior of programs. However, it is not clear what features a live programming environment should provide for such kind of programs. In this paper, we present a design of live programming environment for data structure programming, identify the problems of synchronization and mental map preservation, and propose solutions based on a calling-context sensitive identification technique. We implemented a live programming environment called Kanon, and tested with 13 programmers.},}



2018-11-09
@InProceedings{canino2018fse,
  pdf = 	 {fse2018.pdf},
  author = 	 canino #and# davidLiu #and# masuhara,
  title = 	 {Stochastic Energy Optimization for Mobile {GPS} Applications},
 booktitle = {Proceedings of the 2018 26th ACM Joint Meeting on European Software Engineering Conference and Symposium on the Foundations of Software Engineering},
 series = {ESEC/FSE 2018},
  year = 	 2018,
 isbn = {978-1-4503-5573-5},
 pages = {703--713},
 numpages = {11},
 url = {http://doi.acm.org/10.1145/3236024.3236076},
 doi = {10.1145/3236024.3236076},
 acmid = {3236076},
 publisher = {ACM},
 address = {New York, NY, USA},
 keywords = {Energy Management, Stochastic Optimization, Uncertainty},
  OPTannote = 	 {submitted on 2018-03-09, Accepted 2018-06-10},
  month = 	 nov,
  keywords = 	 {Android},
  location = 	 {Lake Buena Vista, Florida, USA},
  abstract = 	 {Mobile applications regularly interact with their noisy and ever-changing physical environment. The fundamentally uncertain nature of such interactions leads to significant challenges in energy optimization, a crucial goal of software engineering on mobile devices. This paper presents Aeneas, a novel energy optimization framework for Android in the presence of uncertainty. Aeneas provides a minimalistic programming model where acceptable program behavioral settings are abstracted as knobs and application-specific optimization goals  such as meeting an energy budget  are crystallized as rewards, both of which are directly programmable. At its heart, Aeneas is endowed with a stochastic optimizer to adaptively and intelligently select the reward-optimal knob setting through a form of reinforcement learning. We evaluate Aeneas on mobile GPS applications built over Google LocationService API. Through an in-field case study that covers approximately 6500 miles and 150 hours of driving as well as 20 hours of biking and hiking, we find that Aeneas can effectively and resiliently meet programmer-specified energy budgets in uncertain physical environments where individual GPS readings undergo significant fluctuation. Compared with non-stochastic approaches such as profile-guided optimization, Aeneas produces significantly more stable results across runs.},
}

2019-01-17
@Article{adkisson2019ipsj-pro,
  author = 	 adkisson #and# masuhara #and# westlund,
  title = 	 {A Shell-like Model for General Purpose Programming},
  journal = 	 IPSJ-PRO-PRE # {122} #IPSJ-PRO-POST,
  year = 	 2019,
  key = 	 {2018-4-(5)},
  date = 	 {2019-01-17},
  month = 	 jan,
  keywords = 	 {Margitte, Ruby},
  pdf = 	 {pro2018-4-5.pdf},
  url = 	 {http://id.nii.ac.jp/1001/00198113/},
  location = 	 {Fukuyama, Japan},
  abstract = 	 {Shell languages such as bash are designed to integrate with an OS, which mainly involves managing processes with implicit input and output streams. They also attempt to do this in a compact way that could be reasonably typed on a command-line interface. However, existing shell languages are not sufficient to serve as general-purpose languages - values are not observable except in raw streams of bytes, and they lack modern language features such as lexical scope and higher-order functions. By way of a new programming language, Magritte, we propose a general-purpose programming language with semantics similar to bash. In this presentation, we discuss the early design of such a system, in which the primary unit of composition, like bash, is processes with asynchronous inputs and outputs, which can be read from or written to at any time, and which can be chained together via a pipe operator. We also explore concurrency semantics for such a language. We explore the implementation and design challenges that come with such a model, and also show that this model is able to easily create and compose concurrent algorithms.}}

2019-03-06
@InProceedings{oka2019ppl,
  author = 	 oka #and# masuhara #and# aotani,
  pdf = 	 {ppl2019.pdf},
  title = 	 {On Defining Recursive Functions in Live Data Structure Programming},
  crossref =     {ppl2019},
  url = 	 {https://jssst-ppl.org/workshop/2019/},
  keywords = 	 {Kanon, JavaScript},
  abstract = 	 {Kanon is a live programming environment that automatically visualizes data structures created by the program being edited. Though its visualization is useful for the programmer to think about the next code fragment to be written, it becomes useless when defining recursive functions. This paper proposes an extended feature of Kanon that lets the programmer manually build an expected structure. The expected structure not only makes the visualization useful again, but also serves as a test case. This paper also discusses the usefulness of the extended feature through case studies.}}

2019-04-02
@InProceedings{izawa2019morevms,
  author = 	 izawa #and# masuhara #and# aotani,
  title = 	 {Extending a Meta-Tracing Compiler to Mix Method and Tracing Compilation},
  crossref = 	 {morevms2019},
  pages = {5:1--5:3},
  articleno = 5, 
  numpages = 3,
  OPTurl = {http://doi.acm.org/10.1145/3328433.3328439},
  doi = {10.1145/3328433.3328439},
  acmid = 3328439,
  keywords = {RPython, language implementation frameworks, tracing JIT compilation, BacCaml, MinCaml},
  pdf = 	 {morevms2019meta-tracing.pdf},
  year = 	 2019,
  month = 	 apr,
  abstract = 	 {Meta-interpreter-based just-in-time compiler frameworks provide a convenient way for language designers to implement efficient virtual machines. Those frameworks either employ tracing-based or method- (or partial evaluation) based strategies, which have their own pros and cons. This paper proposes an approach to enable both tracing- and method-based compilation so that the runtime can selectively apply an appropriate strategy to different parts of a program. The proposal basically extends a meta-tracing compiler to method-based compilation by roll backing at conditional branches, trace-splitting at loop entries, and not following at function calls. As a proof-of-concept, we implemented a tiny meta-tracing compiler in MinCaml by following the RPython's architecture and extended it to support both tracing- and method-based compilation.},
}

2019-04-02
@InProceedings{adkisson2019pass-morevms,
  author = 	 adkisson #and# westlund #and# masuhara,
  title = 	 {A Shell-like Model for General Purpose Programming},
  booktitle = {Proceedings of the Workshop on Modern Language Runtimes, Ecosystems, and VMs: Track on Programming Across the System Stack (MoreVMs/PASS'19)},
  pages = {10:1--10:7},
  articleno = 10,
  numpages = 7,
  OPTurl = {http://doi.acm.org/10.1145/3328433.3328444},
  doi = {10.1145/3328433.3328444},
  location = 	 {Genova, Italy},
  acmid = 3328444,
  keywords = 	 {Magritte, Ruby},
  pdf = 	 {morevms2019shell.pdf},
  year = 	 2019,
  month = 	 apr,
  abstract = 	 {Shell scripting languages such as bash are designed to integrate with an OS, which mainly involves managing processes with implicit input and output streams. They also attempt to do this in a compact way that could be reasonably typed on a command-line interface.

However, existing shell languages are not sufficient to serve as general-purpose languages---values are not observable except in raw streams of bytes, and they lack modern language features such as lexical scope and higher-order functions.

By way of a new programming language, Magritte, we propose a general-purpose programming language with semantics similar to bash. In this paper, we discuss the early design of such a system, in which the primary unit of composition, like bash, is processes with input and output channels, which can be read from or written to at any time, and which can be chained together via a pipe operator. We also explore concurrency semantics for such a language.}
}

(Student only)
2019-04-02
@inproceedings{izawa2019src-programming,
 author = {Izawa, Yusuke},
 title = {BacCaml: The Meta-hybrid Just-in-time Compiler},
 booktitle = {Proceedings of the Conference Companion of the 3rd International Conference on Art, Science, and Engineering of Programming},
 series = {Programming '19},
 year = {2019},
 isbn = {978-1-4503-6257-3},
 location = {Genova, Italy},
 pages = {32:1--32:3},
 articleno = {32},
 numpages = {3},
 url = {http://doi.acm.org/10.1145/3328433.3328466},
 doi = {10.1145/3328433.3328466},
 acmid = {3328466},
 publisher = {ACM},
  keywords = 	 {MinCaml, PyPy, RPython},
 address = {New York, NY, USA},
} 

(Student only )
2019-04-02
@inproceedings{adkisson2019src-programming,
 author = {Adkisson, Jeanine Miller},
 title = {Magritte: A Modern Shell Language},
 booktitle = {Proceedings of the Conference Companion of the 3rd International Conference on Art, Science, and Engineering of Programming},
 series = {Programming '19},
 year = {2019},
 isbn = {978-1-4503-6257-3},
 location = {Genova, Italy},
 pages = {33:1--33:2},
 articleno = {33},
 numpages = {2},
 url = {http://doi.acm.org/10.1145/3328433.3328467},
 doi = {10.1145/3328433.3328467},
 acmid = {3328467},
 publisher = {ACM},
 address = {New York, NY, USA},
} 




2019-04-23

@Misc{masuhara2019programming-demo,
  author = 	 masuhara #and# oka #and# ogushi,
  title = 	 {Programming Experiences with a Live Programming Environment for Data Structures},
  howpublished = {Demonstration at the International Conference on the Art, Science, and Engineering of Programming (<Programming>'19)},
  month = 	 apr,
  keywords = 	 {JavaScript, Kanon},
  year = 	 2019,
  location = 	 {Genova, Italy},
  url = 	 {https://2019.programming-conference.org/details/programming-2019-Demos/8/Programming-Experiences-with-a-Live-Programming-Environment-for-Data-Structures},
  abstract = 	 {This demonstration presents a live programming environment for data structures called Kanon \cite{oka2018onward},\href{https://prg-titech.github.io/Kanon/}{*}. The goal of the environment is to support professional programmers when they develop new data structures and operations thereof. The key feature for data structures is its automatic visualization of objects that are created in a program execution.

We first overviews the environment through a coding session of a small data structure. The environment assumes a program is written in a test-driven style, and displays objects as a node-link diagram. We introduce the notion of visualization contexts, which the program state stopped at the cursor position, and used for navigating the visualization.

We then discusses the features that support liveness and data-structures. The jump-to-construction mechanism navigates the programmer from a visual element to a code fragment that made the element. Our proposed graph layout algorithm automatically analyzes the object structure and places nodes so as to help the programmers to recognize the relations between objects. An on-the-fly test case generation mechanism enables top-down programming by letting the programmers handcraft an expected result upon a call to an unimplemented function.

Lastly, we discuss several issues for future research. Programming complicated data structures require customized visualization so that the programmer can see the objects at different levels of abstraction. In order not to distract the programmers' focus, it is crucial to handle errors appropriately especially in an environment where program code can be erroneous in the middle of editing. Our user experiment discovered some programming mistakes that can only be observed with the live programming environment, which might be an effect of live programming on the way of programming.}
}

2019-06-23
@InProceedings{springer2019ismm,
  author = 	 springer #and# masuhara,
  title = 	 {Massively Parallel {GPU} Memory Compaction},
  booktitle = {Proceedings of the ACM SIGPLAN International Symposium on Memory Management (ISMM 2019)},
  year = 	 2019,
  editor = 	 {Harry Xu},
  location = 	 {Phoenix, AZ},
  isbn = {978-1-4503-6722-6},
pages = {14--26},
 numpages = {13},
 url = {http://doi.acm.org/10.1145/3315573.3329979},
 doi = {10.1145/3315573.3329979},
 keywords = {GPUs, dynamic allocation, fragmentation},
 month = 	 jun,
  date = 	 {2019-06-23},
  keywords = 	 {CUDA, Ikra, DynaSOAr, C++},
  organization = ACM,
pdf = 	 {ismm2019.pdf},
  abstract = 	 {Memory fragmentation is a widely studied problem of dynamic memory allocators. It is well known that fragmentation can lead to premature out-of-memory errors and poor cache performance.

With the recent emergence of dynamic memory allocators for SIMD accelerators, memory fragmentation is becoming an increasingly important problem on such architectures. Nevertheless, it has received little attention so far. Memory-bound applications on SIMD architectures such as GPUs can experience an additional slowdown due to less efficient vector load/store instructions.

We propose CompactGpu, an incremental, fully-parallel, in-place memory defragmentation system for GPUs. CompactGpu is an extension to the DynaSOAr dynamic memory allocator and defragments the heap in a fully parallel fashion by merging partly occupied memory blocks. We developed several implementation techniques for memory defragmentation that are efficient on SIMD/GPU architectures, such as finding defragmentation block candidates and fast pointer rewriting based on bitmaps.

Benchmarks indicate that our implementation is very fast with typically higher performance gains than compaction overheads. It can also decrease the overall memory usage.}
},


2019-07-16
@InProceedings{springer2019ecoop,
  author = 	 springer #and# masuhara,
  title = 	 {{DynaSOAr}: A Parallel Memory Allocator for Object-Oriented Programming on {GPUs} with Efficient Memory Access},
  booktitle = {Proceedings of of European Conference on Object-Oriented Programming (ECOOP'19)},
  year = 	 2019,
  location = 	 {London, United Kingdom},
  date = 	 {2019-07-18},
  editor = 	 {Alastair Donaldson},
  series = 	 LIPIcs,
  volume = {134},
  pages = {17:1--17:37},
  URL = {http://drops.dagstuhl.de/opus/volltexte/2019/10809},
  doi = {10.4230/LIPIcs.ECOOP.2019.17},
  month = 	 jul,
  pdf = 	 {ecoop2019.pdf},
  keywords = 	 {CUDA, Data Layout, Dynamic Memory Allocation, GPUs, Object-Oriented Programming, SIMD, Single-Instruction Multiple-Objects, Structure of Arrays, C++},
  abstract = 	 { Object-oriented programming has long been regarded as too inefficient for SIMD high-performance computing, despite the fact that many important HPC applications have an inherent object structure. On SIMD accelerators, including GPUs, this is mainly due to performance problems with memory allocation and memory access: There are a few libraries that support parallel memory allocation directly on accelerator devices, but all of them suffer from uncoalesed memory accesses. We discovered a broad class of object-oriented programs with many important real-world applications that can be implemented efficiently on massively parallel SIMD accelerators. We call this class Single-Method Multiple-Objects (SMMO), because parallelism is expressed by running a method on all objects of a type. To make fast GPU programming available to domain experts who are less experienced in GPU programming, we developed DynaSOAr, a CUDA framework for SMMO applications. DynaSOAr consists of (1) a fully-parallel, lock-free, dynamic memory allocator, (2) a data layout DSL and (3) an efficient, parallel do-all operation. DynaSOAr achieves performance superior to state-of-the-art GPU memory allocators by controlling both memory allocation and memory access. DynaSOAr improves the usage of allocated memory with a Structure of Arrays (SOA) data layout and achieves low memory fragmentation through efficient management of free and allocated memory blocks with lock-free, hierarchical bitmaps. Contrary to other allocators, our design is heavily based on atomic operations, trading raw (de)allocation performance for better overall application performance. In our benchmarks, DynaSOAr achieves a speedup of application code of up to 3x over state-of-the-art allocators. Moreover, DynaSOAr manages heap memory more efficiently than other allocators, allowing programmers to run up to 2x larger problem sizes with the same amount of memory. }
  
 }

@Article{springer2019ecoop-ae,
  author =	{Matthias Springer and Hidehiko Masuhara},
  title =	{{DynaSOAr: A Parallel Memory Allocator for Object-Oriented Programming on GPUs with Efficient Memory Access (Artifact)}},
  pages =	{2:1--2:2},
  journal =	{Dagstuhl Artifacts Series},
  ISSN =	{2509-8195},
  month = 	 jul,
  year =	{2019},
  volume =	{5},
  number =	{2},
  publisher =	{Schloss Dagstuhl--Leibniz-Zentrum fuer Informatik},
  address =	{Dagstuhl, Germany},
  URL =		{http://drops.dagstuhl.de/opus/volltexte/2019/10779},
  doi =		{10.4230/DARTS.5.2.2},
  keywords = 	 {CUDA, Data Layout, Dynamic Memory Allocation, GPUs, Object-Oriented Programming, SIMD, Single-Instruction Multiple-Objects, Structure of Arrays, C++},
  abstract = 	 { This artifact contains the source code of DynaSOAr, a CUDA framework for Single-Method Multiple-Objects (SMMO) applications. SMMO is a type of object-oriented programs in which parallelism is expressed by running the same method on all applications of a type. DynaSOAr is a dynamic memory allocator, combined with a data layout DSL and a parallel do-all operation. This artifact provides a tutorial explaining the API of DynaSOAr, along with nine benchmark applications from different domains. All benchmarks can be configured to use a different memory allocator to allow for a comparison with other state-of-the-art memory allocators. }
}

2019-08-27
@InProceedings{li2019jssst,
  author = 	 {Dongfang Li} #and# masuhara,
  title = 	 {{ASTToken2Vec}: An Embedding Method for Neural Code Completion},
  crossref =  {jssst2019e},
  pages = 	 {No.~13-L},
  date = 	 {2019-08-27},
  note = 	 {\href{https://jssst2019.wordpress.com/}{The Student Research Award and the Best Presentation Award of the conference.}},
  review = 	 {false},
  keywords = 	 {JavaScript, LSTM},
  pdf = 	 {jssst2019completion.pdf},
  abstract = 	 {Code completion systems help programmers to write code more efficiently and to reduce typographical errors by automatically suggesting the code fragment that the programmers likely to write next. This work attempts to increase prediction performance of an LSTM-based code completion system proposed by Chang Liu et al. by proposing a new embedding method (a vector representation) for AST nodes. This method is called ASTToken2Vec, similar to Word2Vec, which trains a neural network by using context information to give a vector representation of an AST node. We integrate our embedding method with an LSTM model and evaluate its prediction performance on a JavaScript AST dataset generated from open-source programs containing a total of 150,000 JavaScript files.},}

2019-08-27
@InProceedings{izawa2019jssst,
  author = 	 izawa #and# masuhara #and# aotani #and# cong,
  title = 	 {A Stack Hybridization for Meta-hybrid Just-in-time Compilation},
  crossref =  {jssst2019e},
  pages = 	 {No.~2-L},
  date = 	 {2019-08-27},
  review = 	 {false},
  keywords = 	 {PyPy, BacCaml, MinCaml, RPython},
  pdf = 	 {jssst2019jit.pdf},
  abstract = 	 {Meta-interpreter-based language implementation frameworks, such as RPython and Truffe/Graal, are convenient tool for implementing state-of-the-art virtual machines. Those frameworks are classified into trace-based and method- (or ast-) based strategies. RPython uses a trace-based policy to compile straight execution paths, while Truffe/Graal leverages method invocation to compile entire method bodies. Each approach has its own advantages and disadvantages. The trace-based strategy is good at compiling pro- grams with many branching possibilities and able to reduce the size of compiled code, but it is weak at programs with varying control-flow. The method-based strategy is robust with the latter type of programs but it needs thorough method-inlining management to achieve excellent performance. To take advantage of both strategies, we propose a meta-hybrid compilation technique to integrate trace- and method-based compilations, as well as a proof-of-concept implementation called BacCaml. To achieve this goal, we develop a stack hybridization mechanism which makes it possible to coordinate trace- and method-based meta JIT compilation. In the implementation, we extend RPython's architecture and introduced a special syntax for realizing this system in a single interpreter definition.}
}

2019-10-23
@Proceedings{onward2019,
  title = 	 {Proceedings of the 2019 ACM SIGPLAN International Symposium on New Ideas, New Paradigms, and Reflections on Programming and Software (Onward! 2019)},
 year = 2019,
 isbn = {978-1-4503-6995-4},
 location = {Athens, Greece},
 publisher = {ACM},
 address = {New York, NY, USA},
  editor = 	 {Hidehiko Masuhara and Tomas Petricek},
  
  month = 	 oct,
  url = 	 {https://2019.splashcon.org/track/splash-2019-Onward-papers},
  url = 	 {https://dl.acm.org/citation.cfm?id=3359591},
  
  }

2019-11-21
@Misc{masuhara2019cuny-colloquium,
  author = 	 {Hidehiko Masuhara},
  title = 	 {Challenges and Ideas for Making Live Programming More Practical},
  howpublished = {Computer Science Colloquium, City University of New York},
  month = 	 nov,
  year = 	 2019,
  date = 	 {2019-11-21},
  abstract = 	 {Live programming environments are the programming editors that immediately shows results of an execution of a program being edited. The immediate feedback can change the way of programming---we can exercise a more trial-and-error style of programming, and we can be more confident of the code fragments that we are writing. So far, most of live programming environments are developed for education or for artistic performance. In order to apply live programming for practical software development, we still need overcome several issues, such as visualization, user interface, and runtime performance. This talk presents our live programming environment, called Kanon, that automatically visualizes data structures created inside of a program. We discuss interesting problems and solutions for making visualization natural to the programmers, and remaining challenges.},
  keywords = 	 {Kanon, JavaScript},
  slides = 	 {cuny2019.pdf}
  
}

2019-12-02
@InProceedings{masuhara2019seed,
  author = 	 masuhara,
  title = 	 {Teaching Object-Oriented Modeling as a Part of Programming Courses},
  booktitle = {Proceedings of the 2nd Software Engineering Education Workshop 2019 (SEED 2019) co-located with 26th Asia Pacific Software Engineering Conference (APSEC 2019)},
  year = 	 2019,
  volume = 	 2506,
  series = 	 {CEUR Workshop Proceedings},
  pages = 	 {15--19},
  month = 	 dec,
  location = 	 {Putrajaya, Malaysia},
  url = 	 {http://ceur-ws.org/Vol-2506/},
  pdf = 	 {seed2019.pdf},
  abstract = 	 {  Programming courses in computer science curricula usually teach the concepts and skills of programming, algorithms, data structures, and software development. Though the students who took those programming courses can solve programming exercises, they sometimes lack the problem-solving skills by programming.  This essay describes the author's observations with the phenomenon and an attempt of teaching object-oriented modeling as a part of programming courses.},
}

2020-03-02
@Misc{izawa2020ppl-poster,
  author = 	 izawa #and# masuhara,
  title = 	 {Making Different {JIT} Compilations Dancing to the Same Tune, Acting in the Meta-level},
  crossref = 	 {ppl2020},
  note = 	 {Poster Presentation},
  pdf = 	 {ppl2020-izawa.pdf}}
                  
2020-03-02
@Misc{luthfan2020ppl-poster,
  author = 	 luthfan  #and# tanabe #and# aotani #and# masuhara,
  title = 	 {Object-oriented Programming with Versions},
  crossref = 	 {ppl2020},
  note = 	 {Poster Presentation},
  pdf = 	 {ppl2020-luthfan.pdf}}

2020-03-02
@Misc{chenxin2020ppl-poster,
  author = 	 chenxin  #and# masuhara #and# springer,
  title = 	 {Sanajeh: a {DSL} for {GPGPU} Programming With {Python} Objects},
  crossref = 	 {ppl2020},
  note = 	 {Poster Presentation},
  pdf = 	 {ppl2020-chenxin.pdf}}

2020-03-02
@Misc{shu2020ppl-poster,
  author = 	 shu  #and# masuhara,
  title = 	 {{ACKN}: A Context-Aware Keyword Programming System},
  crossref = 	 {ppl2020},
  note = 	 {Poster Presentation},
  pdf = 	 {ppl2020-shu.pdf}}

2020-03-13
@Article{shu2020ipsj-pro,
  author = 	 shu #and# masuhara,
  pdf = 	 {pro2019-5-2.pdf},
  title = 	 {Improving Keyword-based Code Recommendation by Exploiting Context Information},
  journal = 	 IPSJ-PRO-PRE # {128} #IPSJ-PRO-POST,
  year = 	 2020,
  key = 	 {2019-5-(2)},
  date = 	 {2020-03-13},
  month = 	 mar,
  keywords = 	 {code completion, DNN, deep neural network, LSTM, long short-term memory, word2vec, keyword programming},
  url = 	 {https://sigpro.ipsj.or.jp/pro2019-5/online/},
  location = 	 {Online Workshop},
  annote = 	 {The workshop was originally planned at Waseda University, but was held online due to the COVID-19 outbreak.},
  abstract = 	 {Code recommendation provides code fragments that the programmer likely to type in. One of the advanced code recommendation techniques is keyword programming, which can reflect the programmers' intention. Keyword programming lets the user specify keywords and recommends expressions that contain as many of them. Another one is neural code completion, which uses neural networks to recommend likely occurring expressions according to the context (the program text preceding the cursor position). Previous work showed that the accuracy of a keyword programming system is not high enough. One of the reasons is that the existing keyword programming always recommends shorter expressions without using the context information. In this presentation, we improve keyword programming by combining a neural code completion technique. In addition to the occurrence of keyword, the ranking algorithm incorporates the likeliness factor of the code fragment concerning the context. To estimate the likeliness, we utilize a neural network-based sentence generator. Thus, we can achieve a more complicatedly suitable code fragment and generate a candidate list varying along with different contexts. We implemented our proposal for Java called ACKN as an Eclipse plug-in. The implementation is publicly available.}}

2020-08-28
@Misc{cong2020scheme,
  author = 	 cong #and# furudono #and# masuhara,
  title = 	 {On Teaching Type Systems as Macros},
  howpublished = {Lighting Talk at Scheme and Functional Programming Workshop (Scheme 2020)},
  month = 	 aug,
  year = 	 2020,
  date = 	 {2020-08-28},
  url = 	 {https://icfp20.sigplan.org/home/scheme-2020},
  abstract = 	 {Type systems are one of the fundamental things that everyone in the programming languages community must study. In our research group, we run a semester-long type systems seminar every two years, covering essential chapters of the traditional TaPL book. This year, however, we are attempting a different approach, namely teaching type systems through programming in the Turnstile language of Chang et al. Turnstile is a Racket DSL for creating typed programming languages, built under the slogan ``type systems as macros''. More specifically, it allows the user to define typing rules in the familiar, derivation-like syntax, and to reuse Racket's infrastructure for type checking and evaluation.

We report our experience in teaching type systems as macros to an undergraduate student who joined our research group this spring (the second author). In particular, we show how the student used Turnstile to build simple type-and- effect systems, and what difficulties the student had in the course of implementation.}}

2020-08-28
@Misc{nose2020scheme,
  author = 	 nose #and# cong #and# masuhara,
  title = 	 {Designing a Programming Environment Based on the Program Design Recipe},
  howpublished = {Lighting Talk at Scheme and Functional Programming Workshop (Scheme 2020)},
  month = 	 aug,
  year = 	 2020,
  date = 	 {2020-08-28},
  url = 	 {https://icfp20.sigplan.org/home/scheme-2020},
  abstract = 	 {The program design recipe, introduced by Felleisen et al. in their textbook ``How to Design Programs'', is a step-by-step procedure that solves a problem by programming. The design recipe encourages the programmer, after examining the problem statement, to analyze the data, create input-output examples, and develop a template, instead of immediately starting coding. This helps reduce various kinds of errors, such as non-exhaustive conditional expressions and infinite loops.

One problem in programming with the design recipe is the lack of error-checking support for steps other than coding. For instance, in DrRacket, the programmer cannot check the correctness of data definitions or templates, as they are not written as runnable Racket programs.

We propose a programming environment based on the design recipe. The environment covers the whole process of the design recipe, including data analysis and template construction, with an IDE-like user interface. We also create a domain-specific language that allows systematic design of the user interface and error checking algorithms. Although it is only partly implemented at this point, we hope to receive suggestions on the design of our environment, especially from the workshop participants who are teaching with the design recipe.}}

@InProceedings{leger2020cop,
  author = 	 leger #and# masuhara #and# {Ismael Figueroa},
  title = 	 {Interfaces for Modular Reasoning in Context-Oriented Programming},
  booktitle = {Proceedings of the 12th International Workshop on Context-Oriented Programming and Advanced Modularity (COP 2020)},
  year = 	 2020,
  OPTvolume = 	 {.},
  OPTnumber = 	 {.},
  OPTpages = 	 {Article No.3},
  doi = 	 {10.1145/3422584.3423152},
  pdf = 	 {cop2020.pdf},
  month = 	 jul,
  date = 	 {2020-07-21},
  url = 	 {https://2020.ecoop.org/home/COP-2020},
  abstract = 	 {Different activation mechanisms for Context-Oriented Programming (COP) like implicit activations have been proposed, increasing COP opportunities to be applied in real scenarios. However, activation mechanisms and base code definitions are insufficiently decoupled, as conditionals to activate layers require base code variable references. This hinders reuse, evolution, and modular reasoning of COP and base code, and therefore, uses of COP in real scenarios. This paper proposes interfaces, which are shared abstractions to communicate activation mechanisms and base code in a decoupled manner. Using these interfaces, an object can exhibit its internal state and behaviors, and conditionals use them to (de)activate layers. As layers are planned to be (re)used in different applications, developers can use interfaces to overcome the incompatibility between values exposed by a particular base code and values required by a layer. In addition, as a layer is a plain object, it can use an interface to exhibit the conditional evaluation of its activation to other layers to resolve conflicts among activations of layers. We apply this proposal to implicit activations in which evaluations of conditionals implicitly (de)activate layers. Finally, we illustrate the benefits of this proposal through RI-JS, a practical JavaScript library that currently supports interfaces, reactive activations (implementation variant for implicit activations), global and dynamic deployment, enter and exit transition processes, and partial methods.}}


@InProceedings{izawa2020dls,
  author = 	 izawa #and# masuhara,
  title = 	 {Amalgamating Different {JIT} Compilations in a Meta-tracing {JIT} Compiler Framework},
  booktitle = {Proceedings of the 16th ACM SIGPLAN International Symposium on Dynamic Language (DLS'20)},
  editor = 	 {Matthew Flatt},
  acceptanceRatio = 	 {9/14(64\%)},
  year = 	 2020,
  OPTvolume = 	 {TBA},
  OPTnumber = 	 {TBA},
  doi = 	 {10.1145/3426422.3426977},
  pages = 	 {1--15},
  pdf = 	 {dls2020.pdf},
  url = 	 {https://conf.researchr.org/home/dls-2020},
  month = 	 nov,
  abstract = 	 {Most virtual machines employ just-in-time (JIT) compilers to achieve high-performance. Trace-based compilation and method-based compilation are two major compilation strategies in JIT compilers. In general, the former excels in compiling programs with more in-depth method calls and more dynamic branches, while the latter is suitable for a wide range of programs. Some previous studies have suggested that each strategy has its advantages and disadvantages,and there is no clear winner. In this paper, we present a new approach, namely, the meta-hybrid JIT compilation strategy, mixing the two strategies in a meta-tracing JIT compiler. As a prototype, we implemented a simple meta-tracing JIT compiler framework called BacCaml based on the MinCaml compiler by following RPython's architecture. We also report that some programs ran faster by the hybrid compilation in our experiments.}},


@Misc{masuhara2020live,
  author = 	 masuhara #and# takahashi #and# izawa #and# cong,
  title = 	 {Toward a Multi-Language and Multi-Environment Framework for Live Programming},
  howpublished = {Talk at the 2020 Workshop on Live Programming (colocated with SPLASH 2020)},
  month = 	 nov,
  year = 	 2020,
  url = 	 {https://2020.splashcon.org/home/live-2020},
  pdf = 	 {live2020.pdf},
  abstract = 	 {While applications of live programming are expanding to more practical and professional domains, most live programming environments (LPEs) are still developed for a single target language with an original code editor.  We propose an implementation framework for developing LPEs so that we can minimize efforts on implementing an LPE for a different target language and an existing code editor/IDE.  Our idea is to use a meta-JIT language implementation framework (e.g., Graal/Truffle and RPython) and LSP to separate core live programming implementations from language-specific and editor/IDE specific implementations.  This paper takes the Kanon live programming environment as a concrete example and discusses how we can design the framework to accommodate the features of Kanon.  Although the framework design is still underway, the paper presents a sketch of the framework APIs for separating language-specific functions and clarifies the requirements to LSP.},
  date = 	 {2020-11-17}
}

@InProceedings{kamina2020rebls,
  author = 	 kamina #and# aotani #and# masuhara,
  title = 	 {Managing Persistent Signals using Signal Classes},
  booktitle = {Proceedings of the 7th Workshop on Reactive and Event-based Languages and Systems (REBLS 2020)},
  year = 	 2020,
  editor = 	 {Ivan Perez},
  month = 	 nov,
  url = 	 {https://2020.splashcon.org/details/rebls-2020-papers/5/Managing-Persistent-Signals-using-Signal-Classes},  
  publisher = ACM,
  pdf = 	 {rebls2020.pdf}, 
  note = 	 {to appear},
  OPTdoi = 	 {.},
  abstract = 	 {Persistent signals provide a convenient abstraction for time-varying values with their execution histories by implicitly leaving the management of execution histories to the database system. The current design of persistent signals is very rudimental. For example, they do not provide abstractions for representing complex data structures, and they can only be connected using API methods prepared in advance. To make matters worse, dynamic creation of persistent signals is not allowed. In this paper, we show that these problems can be addressed by introducing a new language mechanism called signal classes. A signal class packages a network of related persistent signals that comprises a complex data structure. A signal class can be instantiated dynamically, and this instance is considered a ``small world,'' where all signals within it are synchronous. We further show that this synchronous world makes it easy to realize persistent signal networks connected by expressions that are not limited to the API methods. This dynamic creation of signal class instances is managed by a simple lifecycle model where both dynamic lifecycle events and persistency are defined.}
}

2020-12-02
@Misc{masuhara2020aplas,
  author = 	 masuhara,
  title = 	 {Object Support for {GPU} Programming: Why and How},
  howpublished = {Keynote talk at the 18th Asian Symposium on Programming Languages and Systems (APLAS 2020)},
  month = 	 nov,
  year = 	 2020,
  date = 	 {2020-12-02},
  url = 	 {https://conf.researchr.org/details/aplas-2020/aplas-2020-keynote-talks/2/Object-Support-for-GPU-Programming-Why-and-How},
  abstract = 	 {General-purpose computing on graphics processing units (GPGPU) is now widely used in many application domains. However, programming for GPGPU is challenging due to its peculiar performance characteristics and still being done either in low-level languages or through libraries (e.g., those for matrix computation and machine learning). This talk discusses the performance challenges of using objects in GPGPU programming from the viewpoint of memory management, and the efficient mechanisms to support objects.}
}

2021-02-16
@InProceedings{nose2021tfpie,
  author = 	 nose #and# cong #and# masuhara,
  title = 	 {Toward Automated Feedback in {HtDP}-based Programming: A {DSL}-based Approach},
  booktitle = {Proceedings of the International Workshop on Trends in Functional Programming in Education (TFPIE 2021)},
  year = 	 2021,
  date = 	 {2021-02-16},
  url = 	 {https://wiki.tfpie.science.ru.nl/TFPIE2021},
  month = 	 feb,
  note = 	 {to appear in an EPTCS volume}}

2021-03-09
@Misc{izawa2021ppl-reproduction,
  author = 	 izawa #and# masuhara,
  title = 	 {Amalgamating Different {JIT} Compilations in a Meta-tracing {JIT} Compiler Framework},
  note = 	 {reproduction of the DLS'20 talk \cite{izawa2020dls} at JSSST Programming and Programming Languages Workshop},
  year = 	 2021,
  month = 	 mar,
  date = 	 {2021-03-09},
  url = 	 {https://jssst-ppl.org/workshop/2021/},
}

2021-03-09
@Misc{izawa2021ppl-poster,
  author = 	 izawa #and# masuhara #and# cong,
  title = 	 {An Interpreter Design for Supporting Different {JIT} Compilations in {RPython} Framework},
  crossref = 	 {ppl2021},
  note = 	 {Poster Presentation},
  abstract = 	 {Most modern programming languages, such as Java, JavaScript, and PHP, have a
just-in-time (JIT) compiler for achieving their fast runtime.
Method-based compilation and trace-based compilation are two major compilation
strategies, and they have their advantages and disadvantages. To incorporate the
benefits of both, we proposed a meta-hybrid JIT compiler framework and its
proof-of-concept implementation called BacCaml. It can generate a virtual machine
with a JIT compiler that can use the two strategies from an interpreter definition.
As a next step, we move on to a more practical framework to show that the meta-hybrid
JIT compilation is useful for many languages. This presentation presents a sprouting
idea for supporting the two strategies in a meta-tracing JIT compiler. This approach
does not extend the compiler itself but designs an interpreter to enable the two
compilation strategies in RPython.}}

2021-06-21
@Misc{chenxin2021array,
  author = 	 chenxin #and# masuhara,
  title = 	 {Nested Object Support in a Structure-of-Arrays Dynamic Objector Allocator},
  howpublished = {Presentation at the ARRAY 2021 Workshop, co-located with PLDI 2021},
  abstract = 	 {DynaSOAr is a dynamic object allocator for GPGPU that enables object-oriented programming with an efficient structure-of-arrays (SOA) memory layout.  One of the limitations in DynaSOAr is its poor support for nested objects.  
When a class has a field of another class, the fields of the inner class are allocated in an arrays-of-structure layout.  
This paper proposes a technique that translates nested class definitions into flat ones by inlining inner classes into top-level classes.
We implemented this technique as a Sanajeh domain-specific language that translates Python class definitions into C++ classes using DynaSOAr.  
Our preliminary evaluation showed that Sanajeh executes a parallel benchmark program with nested objects at almost the same speed as the one with manually flatten classes.  
},
  month = 	 jun,
  year = 	 2021}



2021-07-13
@Misc{izawa2021icooolps,
  OPTkey = 	 {},
  OPTauthor = 	 izawa #and# masuhara #and# bolz #and# cong,
  OPTtitle = 	 {Threaded Code Generation with a Meta-tracing {JIT} Compiler},
  OPThowpublished = {Talk at ICOOOLPS 2021},
  OPTmonth = 	 jul,
  OPTyear = 	 2021,
  date = 	 {2021-07-13},
  abstract = 	 {Language implementation frameworks such as RPython and Truffle/Graal are effective tools for creating a high-performance language with lower effort than implementing from scratch. The two frameworks support only a single JIT compilation strategy, trace-based compilation, and method-based compilation, but they have its own advantages and disadvantages. We proposed a meta-hybrid JIT compiler framework to take advantages of the two strategies as a meta-tracing JIT compiler framework. We also implemented a proof-of-concept framework called BacCaml. As a next step, in this position paper, we propose a new approach to realize a method-based baseline JIT compiler along with a trace-based JIT compilation. We aim to use it for further speed-up by preventing the path-divergence problem, which causes serious slow-down. We also show how to implement the baseline JIT compiler with minimal changes on the top of RPython. },
  OPTnote = 	 {Position paper is archived as arXiv:2106.12496.},
  url = 	 {https://conf.researchr.org/details/issta-2021/ecoop-issta-2021-icooolps/3/Threaded-Code-Generation-with-a-Meta-tracing-JIT-Compiler},
  OPTannote = 	 {}
}

2021-07-14
@InProceedings{kamina2021ecoop,
  author = 	 kamina #and# aotani #and# masuhara,
  title = 	 {Signal Classes: A Mechanism for Building Synchronous and Persistent Signal Networks},
  OPTcrossref =  {},
  OPTkey = 	 {},
  booktitle = {Proceedings of the 35th European Conference on Object-Oriented Programming (ECOOP 2021)},
  url = 	 {https://2021.ecoop.org/details/ecoop-2021-ecoop-research-papers/19/Signal-Classes-A-Mechanism-for-Building-Synchronous-and-Persistent-Signal-Networks},
  year = 	 2021,
  OPTeditor = 	 {.},
  OPTvolume = 	 {.},
  OPTnumber = 	 {},
  series = 	 LIPICS,
  OPTpages = 	 {TBA},
  month = 	 jul,
  OPTaddress = 	 {},
  OPTorganization = {},
  OPTpublisher = {},
  note = 	 {to appear},
  OPTannote = 	 {},
  abstract = 	 {Signals are principal abstraction in reactive programming languages and constitute the basics of reactive computations in modern systems, such as the Internet of Things. Signals sometimes utilize past values, which leads to space leak, a problem where accumulated past values waste resources such as the main memory. Persistent signals, an abstraction for time-varying values with their execution histories, provide a generalized and standardized way of space leak management by leaving this management to the database system. However, the current design of persistent signals is very rudimental. For example, they cannot represent complex data structures; they can only be connected using pre-defined API methods that implicitly synchronize the persistent signal network; and they cannot be created dynamically.

In this paper, we show that these problems are derived from more fundamental one: no language mechanism is provided to group related persistent signals. To address this problem, we propose a new language mechanism signal classes. A signal class packages a network of related persistent signals that comprises a complex data structure. A signal class defines the scope of synchronization, making it possible to flexibly create persistent signal networks by methods not limited to the use of pre-defined API methods. Furthermore, a signal class can be instantiated, and this instance forms a unit of lifecycle management, which enables the dynamic creation of persistent signals. We formalize signal classes as a small core language where the computation is deliberately defined to interact with the underlying database system using relational algebra. Based on this formalization, we prove the language,F"s glitch freedom. This formalization also clarifies the initialization problem regarding the underlying database relations, and we formulate its type soundness by introducing an additional check of program well-formedness. This mechanism is implemented as a compiler and a runtime library that is based on a time-series database. The usefulness of the language is demonstrated through the vehicle tracking simulator and viewer case study. We also conducted a performance evaluation that confirms the feasibility of this application scenario.}
}

2021-08-22
@InProceedings{niimi2021tyde,
  author = 	 niimi #and# cong #and# masuhara #and# {Jonathan Immanuel Brachth,Aduser},
  title = 	 {Contextual Polymorphism Meets Bidirectional Effects},
  booktitle = {In Proceedings of Workshop on Type-Driven Development 2021 (TyDe 2021)},
  year = 	 2021,
  date = 	 {2021-08-22},
  month = 	 aug,
  note = 	 {to appear}}
2022-03-21
@Article{tanabe2022programming,
  author = 	 tanabe #and# luthfan #and# aotani #and# masuhara,
  title = 	 {A Functional Programming Language with Versions},
  journal = 	 programming-journal,
  year = 	 2022,
  date = 	 {2022-03-21},
  volume = 	 6,
  number = 	 1,
  OPTpages = 	 {.},
  OPTmonth = 	 {.},
  OPTabstract = 	 {While modern software development heavily uses versioned packages, programming languages rarely support the concept of versions in their semantics, which makes software update more bulky and unsafe. This paper proposes a programming language that intrinsically supports versions. The main goals are to design core language features to support multiple versions in one program and establish a proper notion of type safety with those features. The proposed a core calculus, called Lambda VL, has versioned values, each of which can contain different values under different versions. We show the construction of the type system as an extension of coeffect calculus by mapping versions to computational resources. The type system guarantees the existence of a valid combinations of versions for a program. The calculus enables programming languages to use multiple versions of a package within a program. It will serve as a basis for designing advanced language features like module systems and semantic versioning.},
  note = 	 {accepted; to appear}}



