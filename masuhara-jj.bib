% -*- Mode: BibTeX -*-
% masuhara-jj.bib
% Japanese papers written by Masuhara
% for the citation in Japanese paper

% include: strings.bib

% include: strings-j.bib

@InProceedings{masuhara92wooc,
  author = 	 jmasuhara # " and 松岡 聡 and 渡部 卓雄 and " # jyonezawa ,
  yomi = 	  masuhara # " and Satoshi Matsuoka and Takuo
		  Watanabe and Akinori Yonezawa",
  title = 	 "自己反映計算の機能を持つ並列オブジェクト指向言語の高
		  効率な実現方式",
  booktitle = 	 WOOC,
  year = 	 1992,
  editor =	 "田中 克己 and 西尾 章治郎",
  volume =	 4,
  organization = JSSST,
  address =	 "神戸",
  note =	 "近代科学社 レクチャーノート/ソフトウェア学シリーズ
		  第4巻 pp.209--224, 1993 として 1993年7月
		  出版\cite{masuhara93woocLN}",
  month =	 mar
}


@InCollection{masuhara93woocLN,
  author = 	 jmasuhara # " and 松岡 聡 and 渡部 卓雄 and " # jyonezawa ,
  yomi = 	  masuhara # " and Satoshi Matsuoka and Takuo
		  Watanabe and Akinori Yonezawa",
  title = 	 "自己反映計算の機能を持つ並列オブジェクト指向言語の高
		  効率な実現方式",
  booktitle = WOOC92LN,
  publisher = KindaiKagaku,
  year = 	 1993,
  editor = 	 "田中 克己 and 西尾 章治郎",
  volume = 	 4,
  series = 	 "レクチャーノート/ソフトウェア学",
  pages = 	 "209--224",
  month = 	 jul
}

@Article{masuhara92prg,
  author = 	 jmasuhara # " and 松岡 聡 and " # jyonezawa ,
  yomi =          masuhara # " and Satoshi Matsuoka and Akinori
		  Yonezawa",
  title = 	 "自己反映的並列オブジェクト指向言語{ABCL/R2}のコンパイ
		  ラについて",
  journal = 	 IPSJ-SIG,
  year = 	 1992,
  volume =	 92,
  number =	 85,
  pages =	 "79--86",
  month =	 oct,
  note =	 "(92-PRG-9)",
  organization = IPSJ,
  abstract = 	 {自己反映計算の機能を持つ並列オブジェクト指向言語ABCL/R2の実現、特にコンパイラと実行時システムに関して述べる。従来の自己反映的言語の実現は、解釈実行に基づくものがほとんどであったが、本実現では、スクリプトを部分コンパイルすることで、並列オブジェクト指向計算に関する自己反映計算の機能を保ちつつ、他の部分は効率的に実行される。また、システムオブジェクトの自己具体化や軽量オブジェクトなどによって、システムのオーバーヘッドを低減している。ベンチマークの結果、今回の実現では、自己反映計算をする部分は従来のものに比べて約二桁の速度の向上が、また、自己反映計算をおこなわない部分では自己反映計算の機能のない言語に匹敵する性能が示された。 },
  pdf = 	 {prg1992.pdf}
}

@Article{matsuoka93jssst-topic,
  author = 	 "松岡 聡 and  " # jmasuhara ,
  title = 	 "{IMSA'92} 国際リフレクションワークショップ",
  journal = 	 CompSoft,
  year = 	 1993,
  volume =	 10,
  number =	 4,
  pages =	 "76--82",
  month =	 jul
}

@InProceedings{masuhara93wooc,
  author = 	 jmasuhara # " and 松岡 聡 and " # jyonezawa ,
  yomi = 	  masuhara # " and Satoshi Matsuoka and Akinori
		  Yonezawa",
  title = 	 "自己反映並列オブジェクト指向言語によるメタレベルでの
		  スケジューリング方式",
  booktitle =	 WOOC,
  year = 	 1993,
  organization = JSSST,
  address = 	 Hakone,
  month = 	 mar,
  note =         "近代科学社 レクチャーノート/ソフトウェア学シリーズ
		  第6巻 pp.31--45 として1994年4月出版\cite{masuhara94woocLN}"
}

@InCollection{masuhara94woocLN,
  author = 	 jmasuhara # " and 松岡 聡 and " # jyonezawa ,
  yomi = 	  masuhara # " and Satoshi Matsuoka and Akinori
		  Yonezawa",
  title = 	 "自己反映並列オブジェクト指向言語によるメタレベルでの
		  スケジューリング方式",
  booktitle = WOOC93LN,
  publisher = KindaiKagaku,
  year = 	 1994,
  editor = 	 "米澤明憲 and 松岡聡 and 加藤和彦",
  volume = 	 6,
  series = 	 "レクチャーノート/ソフトウェア学",
  pages = 	 "31--45",
  month = 	 apr
}

@Article{masuhara94compsoft,
  author = 	 jmasuhara # " and 松岡 聡 and 渡部 卓雄",
  yomi = 	  masuhara # " and Satoshi Matsuoka and Takuo
		  Watanabe",
  title = 	 "自己反映並列オブジェクト指向言語 {ABCL/R2} の設計と
		  実現",
  journal = 	 CompSoft,
  year = 	 1994,
  volume = 	 11,
  number = 	 3,
  pages = 	 "15--32",
  month = 	 may,
  abstract = 	 {並行オブジェクトの間で共有される計算資源の概念をとり入れた自己反映計算モデルであるHybrid Group Architectureと,その記述言語ABCL/R2を提案した.ABCL/R2では,オブジェクト単位の自己反映計算と,オブジェクトグループ単位での自己反映計算の両方が可能なため,スケジューリングのような,並列・分散システムにおける共有計算資源に関する制御を,本来の計算から隠蔽された形をとりつつ,言語の枠内から柔軟に記述できる.また,自己反映システムの効率的な処理系は,作成が困難とされていたが,部分コンパイル・段階的なメタレベル生成・軽量オブジェクトなどの技法による効率的な処理系の作成方法を示した.実際に共有記憶型並列計算機上に作成したABCL/R2処理系では,自己反映計算を行うことによる速度低下を,行わない場合の10倍以下に抑えられ,非自己反映計算の実行速度は,非自己反映処理系とほぼ同等であるというベンチマーク結果を得た.},
  pdf = 	 {compsoft1993.pdf}
}

@InProceedings{masuhara95wooc,
  author = 	 jmasuhara # " and 松岡 聡 and " # jyonezawa ,
  yomi = 	  masuhara # " and Satoshi Matsuoka and Akinori
		  Yonezawa",
  title = 	 "部分計算コンパイル: 自己反映並列オブジェクト指向言語
		  の効率的な実行方式",
  booktitle = 	 WOOC,
  year = 	 1995,
  organization = JSSST,
  address =	 "石川",
  month =	 mar
}


@InProceedings{masuhara95jspp,
  author = 	 jmasuhara # " and 松岡 聡 and " # jyonezawa,
  note = 	 {\cite{masuhara96trans-ipsj}として出版.} ,
  yomi =	  masuhara # " and Satoshi Matsuoka and Akinori
		  Yonezawa",
  title = 	 "並列自己反映システムの部分計算によるコンパイル技法",
  booktitle = 	 JSPP,
  year = 	 1995,
  pages =        "273--280",
  address =	 "福岡",
  month =	 may
}

@Article{masuhara95swopp,
  author = 	 jmasuhara # " and 松岡 聡 and " # jyonezawa ,
  yomi = 	  masuhara # " and Satoshi Matsuoka and Akinori
		  Yonezawa",
  title = 	 "並列オブジェクト指向言語 {ABCL/{\it f}} のメタレベルアー
		  キテクチャ",
  journal = 	 SWoPP95PRO,
  year = 	 1995,
  volume =	 95,
  number =	 82,
  pages =	 "65--72",
  month =	 aug
}

@Article{hosoya95swopp,
  author = 	 "細谷 晴夫 and " # jmasuhara # " and 田浦 健次朗 and " # jyonezawa ,
  yomi = 	 "Haruo Hosoya and " # masuhara # " and Kenjiro Taura
		  and Akinori Yonezawa",
  title = 	 "プロセスとチャネルに基づく並列言語のための部分計算",
  journal = 	 SWoPP95PRO,
  year = 	 1995,
  volume =	 95,
  number =	 82,
  pages =	 "73--80",
  month =	 aug
}

@Article{asai95pro,
  author = 	 "浅井 健一 and " # jmasuhara # AND # jyonezawa ,
  yomi = 	 "Kenichi Asai and " # masuhara # " and Akinori Yonezawa",
  title = 	 "副作用を含む関数型プログラムの部分評価に向けて",
  journal = 	 IPSJ-SIG,
  year = 	 1995,
  volume =	 95,
  number =	 114,
  pages =	 "51--56",
  month =	 dec,
  keywords =	 "Partial evaluation, side-effect, assignment, preaction",
  serialNo =	 "4-18",
  abstract = 	 {部分評価は、プログラムを既知の入力によって特化して効率化するプログラム変換の一種であり、理論、実際両面においてその有用性が注目されている。しかし、これまでの関数型言語の部分評価器は純粋な関数型言語を対象としており、副作用命令を扱うことはできない。一方、最近、C言語用の部分評価器が提案されているが、offlineの方式を取っているためわかりにくく、関数型言語との関連も見えにくい。本稿では、onlineの方式を用いて副作用命令を含む関数型言語の部分評価器を作成し、onlineの方式で何ができ、どのような問題が生じるのかを考察する。それを通して、より強力な部分評価器を作るにはどうしたらよいのかを考えていく。}
}

@InProceedings{masuhara96wooc,
  author = 	 jmasuhara # " and 松岡 聡 and " # jyonezawa ,
  yomi = 	  masuhara # " and Satoshi Matsuoka and Akinori
		  Yonezawa",
  title = 	 "自己反映並列オブジェクト指向言語によるメタレベルでのスケジューリング方式: ホットスポットの検出と解消に向けて",
  booktitle = 	 "オブジェクト指向計算ワークショプ ({WOOC'96})",
  year = 	 1996,
  editor =	 "石川裕",
  organization = JSSST,
  address =	 "石川",
  month =	 mar
}

@Article{masuhara96trans-ipsj,
  author = 	 jmasuhara # " and 松岡 聡 and " # jyonezawa ,
  yomi = 	  masuhara # " and Satoshi Matsuoka and Akinori
		  Yonezawa",
  pdf = 	 {ipsj-trans-1996.pdf},
  title = 	 "並列自己反映言語システムの部分計算によるコンパイル技法",
  journal = 	 Trans-IPSJ,
  year = 	 1996,
  volume =	 37,
  number =	 7,
  pages =	 "1290--1298",
  month =	 jul,
  note =	 "\cite{masuhara95jspp}として発表. 情報処理学会平成8年度論文賞受賞.",
  abstract = 	 {並列自己反映言語システムは 並列アプリケーションの最適化等を簡潔に記述するメタプログラミングの機能を持つ一方 解釈実行に基づくモデルから来る効率上の問題を持つ.本論文では部分計算を用いた並列自己反映言語のコンパイル技法を提案する.この技法では 副作用について拡張された部分計算やプログラム変換を適用することで基本的に解釈実行を除去し 直接実行のみとする.並列計算機上の実験では 並列アプリケーションのメタレベルに記述された最適化が 7--17\%のオーバヘッドで実行できるという結果が得られている.}
}

@InProceedings{masuhara97jssst,
  author = 	 jmasuhara # AND # jyonezawa ,
  yomi =          masuhara # " and Akinori Yonezawa",
  title = 	 "Reasoning
		  を容易にする並列自己反映言語のメタオブジェクトの設計",
  booktitle = 	 JSSSTConf97,
  year = 	 1997,
  pages =	 "433--436",
  organization = JSSST,
  address =	 Isikawa,
  month =	 oct,
  note =         "\cite{masuhara98compsoft}として出版."
}

@InProceedings{sugita98spa,
  author = 	 "杉田 祐也 and " # jmasuhara # " and 原田 賢一",
  yomi = 	 "Yuuya Sugita and " # masuhara # " and Ken'ichi Harada",
  title = 	 "動的コード生成を利用した自己反映言語の効率的な処理系の実装",
  booktitle = 	 SPA98,
  year = 	 1998,
  organization = JSSST,
  address =	 Kusatu,
  month =	 mar,
  OPTnote =	 "in Japanese"
}

@Article{masuhara98compsoft,
  author = 	 jmasuhara # AND # jyonezawa ,
  yomi =          masuhara # " and Akinori Yonezawa",
  pdf = 	 {compsoft1998.pdf},
  title = 	 "Reasoning
		  を容易にする並列自己反映言語のメタオブジェクトの設計",
  journal = 	 CompSoft,
  year = 	 1998,
  note = 	 {\cite{masuhara97jssst}として発表.},
  volume =	 15,
  number =	 4,
  pages =	 "62--66",
  month =	 jul,
  annote = 	 "小論文"
}

@InProceedings{masuhara98oo-tutorial,
  author = 	 jmasuhara ,
  yomi = 	  masuhara ,
  title = 	 "並列／分散環境上でのオブジェクト指向プログラミング技術",
  booktitle = 	 "オブジェクト指向最前線'98: 情報処理学会OO'98シンポジウム",
  year = 	 1998,
  editor =	 "上原 三八 and 鯵坂 恒夫",
  pages =	 "211--221",
  organization = "情報処理学会ソフトウェア工学研究会",
  publisher =	 "朝倉書店",
  month =	 sep,
  note =	 "チュートリアルノート",
  annote =	 "ISBN4-254-12137-7, 3200円"
}

@InProceedings{masuhara99spa,
  pdf = 	 {spa99.pdf},
  author = 	 jmasuhara # " and  " # jyonezawa ,
  yomi =          masuhara # " and Akinori Yonezawa",
  title = 	 "{Java}バイトコード上での実行時プログラム特化",
  booktitle = 	 "第2回
		  プログラミングおよび応用のシステムに関するワークショップ
		  (SPA'99)",
  year = 	 1999,
  OPTeditor = 	 "",
  OPTvolume = 	 "",
  OPTnumber = 	 "",
  OPTseries = 	 "",
  OPTpages = 	 "",
  organization = JSSST,
  OPTpublisher = "",
  OPTaddress = 	 "",
  month = 	 mar,
  OPTnote = 	 "",
  OPTaffil = 	 "",
  OPTkeywords =  "",
  OPTserialNo =  "",
  OPTannote = 	 ""
}

@InProceedings{masuhara99ptw,
  author = 	 jmasuhara # " and 杉田 祐也 and " # jyonezawa ,
  yomi = 	  masuhara # " and Yuuya Sugita and Akinori Yonezawa",
  title = 	 "部分計算を用いた自己反映言語の高速化",
  booktitle = 	 "プログラム変換札幌ワークショップ  (PTW99)",
  year = 	 1999,
  month = 	 mar
}

@InProceedings{maruyama2001spa,
  author = 	 "丸山 直也 and " # jmasuhara # " and 小川 宏高 and 丸山 冬彦 and 
		  松岡 聡", 
  title = 	 "{OpenJIT} コンパイラフレームワークにおける実行時特化システム",
  booktitle = 	 "第4回プログラミングおよび応用のシステムに関するワークショップ (SPA2001)", 
  year = 	 2001,
  editor =	 "中島 達夫",
  organization = JSSST,
  month =	 mar,
  url =	 "https://web.archive.org/web/20010807172308/http://www.dcl.info.waseda.ac.jp/SPA2001/spa2001-program2.html"
}

@InProceedings{kawauchi2003jssst,
  author = 	 "河内 一了 and " # jmasuhara ,
  yomi = 	 "Kazunori Kawauchi and " # masuhara ,
  title = 	 "アスペクト指向言語におけるデータフローポイントカットの提案",
  booktitle = 	 "日本ソフトウェア科学会第20回大会論文集",
  year = 	 2003,
  editor =	 "玉井 哲雄",
  pages =	 "411--415",
  organization = JSSST,
  address =	 "愛知",
  month =	 sep,
  note = "\cite{kawauchi2004compsoft}として出版."
}


@Article{kawauchi2004compsoft,
  author = 	 "河内 一了 and " # jmasuhara ,
  yomi = 	 "Kazunori Kawauchi and " # masuhara ,
  title = 	 "アスペクト指向言語におけるデータフローポイントカット",
  journal = 	 "コンピュータソフトウェア",
  year = 	 2004,
  volume =	 21,
  number =	 3,
  pages =	 "34--39",
  month =	 may,
  note =	 "\cite{kawauchi2003jssst}として発表.",
  abstract = 	 {AspectJをはじめとする多くのアスペクト指向言語はポイントカット+アドバイス機構を持つ．ポイントカットの表現力は，アスペクトの汎用性を高めるために重要である．本研究では，既存のアスペクト指向言語のポイントカット記述子に，データの依存関係に基づく条件を記述できる dflow を追加する．この dflow 言語はプロトタイプ処理系が作成されており，それに基づいた実際的な処理系が検討されている．dflow を用いることで，秘密のデータが漏洩する場合の対処などのセキュリティに関する機能をアスペクトとして定義することが容易となる． },
  pdf = 	 {compsoft2004.pdf}
}

@InProceedings{kamio2004pro,
  author = 	 "神尾 貴博 and " # jmasuhara ,
  yomi  = 	 "Takahiro Kamio" # and  # masuhara ,
  title = 	 "オブジェクト指向プログラムの高速化を支援するプロファイラ",
  booktitle = 	 "情報処理学会プログラミング研究会 発表資料",
  year = 	 2004,
  month =	 mar,
  note =	 "\cite{kamio2005sigpro}として出版."
}

@InProceedings{sakurai2004sigse,
  author = 	 jsakurai # AND # jmasuhara # " and 鵜林 尚靖 and 松浦 佐江子 
		  and 古宮 誠一",
  yomi = 	  sakurai # AND #  masuhara # AND # "Naoyasu Ubayashi" # AND # "Saeko Matsuura and Seiichi Komiya",
  title = 	 "連想アスペクト",
  booktitle = 	 "情報処理学会研究報告",
  year = 	 2004,
  series = 	 {ソフトウェア工学(SE)},
  OPTvolume = 	 2004,
  number =	 "30(2003-SE-144)",
  pages =	 "210--216",
  month =	 mar
}

@InProceedings{sakurai2004ipsj-conf,
  author = 	 jsakurai # AND # jmasuhara # " and 鵜林 尚靖 and 松浦 佐江子 
		  and 古宮 誠一",
  yomi = 	  sakurai # AND #  masuhara # AND # "Naoyasu Ubayashi" # AND # "Saeko Matsuura and Seiichi Komiya",
  title = 	 "Association Aspect: アスペクト指向プログラミングにおけるアスペクトのインスタンス化機構の拡張",
  booktitle = 	 "第66回情報処理学会全国大会講演論文集",
  year = 	 2004,
  OPTvolume =	 5,
  pages =	 "5G--03",
  month =	 mar
}

@InProceedings{endoh2004spasummer,
  author = 	 "遠藤 侑介 and " # jmasuhara ,
  yomi   = 	 "Yusuke Endo" # and # masuhara ,
  title = 	 "Pure {AspectJ} での dynamic weaving の実現手法",
  crossref = 	 "spa2004summer",
  annote =	 "http://www.csg.is.titech.ac.jp/~yoshiki/spa_aop_ws/paper/endoh.ppt"
}

@InProceedings{sakurai2004spasummer,
  author = 	 jsakurai # AND  # jmasuhara ,
  yomi   = 	  sakurai # AND  #  masuhara ,
  title = 	 "連想アスペクトによるアプリケーション連携の記述改善評価",
  crossref = 	 "spa2004summer",
  annote =	 "http://www.csg.is.titech.ac.jp/~yoshiki/spa_aop_ws/paper/sakurai.pdf"
}

@InProceedings{kawauchi2004spasummer,
  author = 	 "河内 一了 and " # jmasuhara ,
  yomi   = 	 kawauchi # and  #  masuhara ,
  title = 	 "アスペクト指向プログラミングにおけるデータフローポイントカット",
  crossref = 	 "spa2004summer",
  annote =	 "http://www.csg.is.titech.ac.jp/~yoshiki/spa_aop_ws/paper/kawauchi.ppt"
}

@InProceedings{sakurai2004jssst,
  author = 	 jsakurai # AND #  jmasuhara # " and 松浦佐江子 and 古宮誠一",
  yomi   = 	  sakurai # AND #   masuhara # " and Saeko Matsuura and Seiichi Komiya",
  title = 	 "連想アスペクトによるアプリケーション連携の記述改善",
  booktitle = 	 "日本ソフトウェア科学会第21回論文集",
  year = 	 2004,
  month =	 sep,
  note =	 "\cite{sakurai2005compsoft}として出版.",
  annote =	 "http://www.komiya.ise.shibaura-it.ac.jp/~sakurai/aa/jssst2004_aa.pdf"
}

@InProceedings{tatsuzawa2004jssst,
  author = 	 jtatsuzawa # AND # jmasuhara # AND # jyonezawa,
  yomi  = 	  tatsuzawa # AND #  masuhara # AND #  yonezawa,
  month = 	 sep ,
  title = 	 "関数型プログラミングのためのアスペクト指向言語",
  booktitle = 	 "日本ソフトウェア科学会第21回大会論文集",
  year = 	 2004
}

@Misc{masuhara2004aop-trends,
  OPTkey = 	 {},
  author =	 jmasuhara,
  yomi  =	  masuhara,
  title =	 {アスペクト指向プログラミングにおける最近の動向},
  howpublished = {東京理科大学理工学部情報科学科コロキウムにて発表},
  pdf = 	 {sut-colloquium2004aop.pdf},
  month =	 jun,
  year =	 2004,
  OPTnote = 	 {},
  OPTannote = 	 {}
}

@Misc{masuhara2004wakate,
  author =	 jmasuhara ,
  yomi   =	  masuhara ,
  title =	 "アスペクト指向プログラミングに関する十の神話",
  pdf = 	 {aop-myth.pdf},
  howpublished = "第37回情報科学若手の会",
  year =	 2004,
  note = 	 {招待講演},
  month =	 sep,
  location = "愛知県瀬戸市"
}

@InProceedings{masuhara2004fose,
  author = 	 jmasuhara,
  yomi   = 	  masuhara,
  title = 	 {アスペクト指向プログラミング言語のモデル化},
  booktitle = 	 {ソフトウェア工学の基礎XI: 日本ソフトウェア科学会FOSE2004},
  pages =	 {239--240},
  year =	 2004,
  editor =	 {野呂 昌満 and 山本 晋一郎},
  volume =	 30,
  series =	 {レクチャーノート/ソフトウェア学},
  publisher =	 {近代科学社}
}

@Article{kamio2005sigpro,
  author = 	 "神尾 貴博 and " # jmasuhara ,
  yomi = 	 "Takahiro Kamio and " # masuhara ,
  title = 	 "オブジェクト指向プログラムの高速化を支援するプロファイラ",
  journal = 	 "情報処理学論文誌: プログラミング",
  year = 	 2005,
  volume =	 46,
  number =	 "SIG 1 (PRO 24)",
  pages =	 "1--9",
  month =	 jan,
  note =	 "\cite{kamio2004pro}として発表.",
  abstract = 	 {オブジェクト指向プログラムの実行時に，各メソッドが同じ値の引数で何回呼び出されたかを調べるプロファイラを作成した．このプロファイラの情報を利用することでメモ化や部分計算のようなプログラム変換を適用する対象の決定が容易になる．変更可能な状態を持つオブジェクトの同値性を正確に判定するために，プロファイラは各メソッドが参照するフィールドが変化した時刻を記録し，その値によって同値性を判定する．実際に64,602 行からなるプログラムを人手によるメモ化で高速化した際の経験を基にプロファイル情報の有用性を見積もったところ，検討すべきメソッドの数が20\%以上減るという予測を得た．}
}

@Proceedings{ppl2005,
  title = 	 {第7回プログラミングおよびプログラミング言語ワークショップ(PPL2005)予稿集},
  booktitle = 	 {第7回プログラミングおよびプログラミング言語ワークショップ(PPL2005)予稿集},
  year = 	 2005,
  editor =	 {関 浩之       and } # jmasuhara,
  yomi   =	 {Hiroyuki Seki and } #  masuhara,
  address =	 {水上},
  month =	 mar,
  organization = {日本ソフトウェア科学会プログラミング論研究会}
}

@InProceedings{oneda2005spa,
  author = 	 joneda # AND # jmasuhara # AND # jyonezawa,
  yomi   = 	  oneda # AND #  masuhara # AND #  yonezawa,
  title = 	 {値間依存性に基づくポイントカット記述のためのバイトコード変換},
  booktitle = 	 {第8回プログラミングおよび応用のシステムに関するワークショップ (SPA 2005)},
  year =	 2005,
  address =	 {伊香保},
  month =	 mar,
  note =	 {オンライン論文集}
}

@Article{sakurai2005compsoft,
  pdf = 	 {compsoft2005.pdf},
  author = 	 jsakurai # AND # jmasuhara # { and 松浦 佐江子 and 古宮 誠一},
  yomi = 	 sakurai # AND # masuhara # " and Saeko Matsuura and Seiichi Komiya",
  title = 	 {連想アスペクトによるアプリケーション連携の記述改善評価},
  doi = 	 {10.11309/jssst.22.3_222},
  month = 	 aug,
  journal = 	 CompSoft,
  year = 	 2005,
  volume =	 22,
  number =	 3,
  pages =	 {222--228},
  note =	 {\cite{sakurai2004jssst}として発表.},
  abstract = 	 {本研究では連想アスペクトと呼ぶ言語機構の評価を行う. 連想アスペクトはAspectJのようなアスペクト指向プログラミング言語を拡張し, オブジェクトのグループにアスペクトのインスタンスを関連づける機構として提案されている. 連想アスペクトはオブジェクト間の協調動作のような関心事をモジュール化するのに有用であると予想されるが, 実際のアプリケーション記述でそれを確かめた例はまだない. そこで本研究では, オブジェクト指向言語で記述された複数のアプリケーションを連携させて1つのシステムを構築する際に連想アスペクトを利用し, その有用性を他のプログラミング手法と比較する. 具体的にはテキストエディタ, コンパイラ, 開発プロジェクト管理システムを連携させて統合開発環境を構築する例を用いる.}
}

@inproceedings{watanabe2005spa-summer,
  author = 	 jwatanabe # AND # jmasuhara,
  yomi =          watanabe # AND # masuhara ,
  title = 	 {類似プログラムの提示によるコード再利用支援},
  crossref =	 {spa-summer2005},
  note =	 {ポスター発表},
}

@InProceedings{aotani2005jssst,
  author = 	 jaotani # AND # jmasuhara,
  note = 	 {\cite{aotani2006compsoft}として出版.} ,
  yomi =  aotani # { and } # masuhara ,
  title = 	 {ユーザー定義されたプログラム解析を利用するアスペクト指向プログラムのコンパイル手法},
  crossref =	 {jssst2005},
  pages =	 {.}
}

@InProceedings{endo2005jssst,
  author = 	 {遠藤 侑介 and } # jmasuhara # AND # jyonezawa,
  yomi = 	 {Yusuke Endoh and } # masuhara # { and Akinori Yonezawa},
  title = 	 {継続の適用をジョインポイントとするアスペクト指向プログラミングモデル},
  crossref =  {jssst2005},
  pages =	 {.}
}

@inproceedings{watanabe2006ppl,
  author = 	 jwatanabe # AND # jmasuhara,
  yomi =          watanabe # AND # masuhara ,
  title = 	 {類似プログラムの提示ツール：{Selene}},
  crossref =	 {ppl2006},
  note =	 {ポスター発表},
}

@Article{masuhara2006compsoft,
  pdf = 	 {compsoft2006tutorial.pdf},
  author = 	 jmasuhara ,
  yomi =          masuhara ,
  title = 	 "チュートリアル: アスペクト指向プログラミング",
  journal = 	 CompSoft,
  year = 	 2006,
  volume =	 23,
  number =	 2,
  pages =	 "4--28",
  month =	 apr,
  doi = 	 {10.11309/jssst.23.2_4},
  note = "\href{http://www.jssst.or.jp/award/detail/kaisetsu_ronbunsho_list.html}{日本ソフトウェア科学会第2回解説論文賞}",
  OPTurl = 	 {https://www.jstage.jst.go.jp/article/jssst/23/2/23_2_2_4/_pdf},
  abstract = 	 {本稿ではアスペクト指向プログラミングについて，その基本となる概念と研究・開発動向を解説する．アスペクト指向プログラミングとは横断的関心事をモジュール化するプログラミングパラダイムであり， AspectJ をはじめとするいくつかの言語が開発・利用されている．これらの言語には，ポイントカット・アドバイス機構や型間宣言などのように従来のプログラミング言語には見られない新しい機能があり，表現力の向上・実現方式・開発環境・基礎理論・実証などの面について多くの研究が行われている．}
}

@Article{aotani2006compsoft,
  author = 	 jaotani # AND # jmasuhara,
  yomi =  aotani # { and } # masuhara ,
  title = 	 {ユーザー定義されたプログラム解析を利用するアスペクト指向プログラムのコンパイル手法},
  doi = 	 {10.11309/jssst.23.2_157},
  pdf = 	 {compsoft2006scope.pdf},
  journal = 	 CompSoft,
  year = 	 2006,
  volume =	 23,
  number =	 2,
  pages =	 {157--167},
  note = {\cite{aotani2005jssst}の改訂版},
  abstract = 	 {本研究では，AspectJ言語に対するコンパイルの枠組であるSCoPEの改良を提案する．SCoPEは静的な条件ポイントカットを自動的に見つけ出し，静的に評価することができる．改良は束縛時検査の高速化と，Javaバイトコード操作ライブラリとSCoPEとの連携から成る．これによって，ユーザーがJavaバイトコードの複雑な静的解析を行う静的なポイントカットを記述できるようになり，これを実用的な時間でコンパイルすることが可能となった．}
}

@Article{oneda2007compsoft,
  title = 	 {値間依存性に基づくポイントカット記述のためのバイトコード変換},
  author =	 joneda #AND# jmasuhara #AND# jyonezawa,
  yomi =         oneda #AND# masuhara #AND# yonezawa,
  journal = 	 CompSoft,
  year = 	 2007,
  volume =	 24,
  number =	 2,
  pages =	 {27--40},
  month =	 apr,
  note =	 {\cite{oneda2005spa}として発表.}
}

@Misc{masuhara2006sea-forum,
  pdf = 	 {sea2006.pdf},
  author =	 jmasuhara,
  yomi = 	 masuhara,
  title =	 {{AOP}入門},
  howpublished = {ソフトウェア技術者協会フォーラム「アスペクト指向技術は実用に使えるか」},
  note = {招待講演},
  month =	 {May/June},
  year =	 2006
}

@InProceedings{sakurai2006jssst,
  author = 	 jsakurai # AND  # jmasuhara ,
  yomi = 	 sakurai # AND  # masuhara ,
  title = 	 "アスペクト指向プログラミングにおけるテストに基づいたポイントカットの提案",
  crossref = 	 "jssst2006",
  note = "改訂版が\cite{sakurai2007compsoft}として掲載",
}

@Misc{masuhara2006jssst-tutorial,
  pdf = 	 {jssst-tutorial2006.pdf},
  author =	 jmasuhara ,
  yomi = 	 masuhara,
  title =	 "Javaによるアスペクト指向プログラミング",
  howpublished = "日本ソフトウェア科学会チュートリアル 「Java言語の最新事情」スライド",
  year =	 2006,
  month =	 oct
}



@Book{kawai2006joho,
  author = 	 {川合 慧(編) and 植田 一博 and 金子 知適 and 高橋 成雄 and 玉井 哲雄 and 中谷 多哉子 and 開 一夫 and 藤垣 裕子 and 増原 英彦 and 山口 和紀 and 山口 泰},
  url = 	 {http://www.utp.or.jp/book/b305424.html},
  isbn = 	 {978-4-13-062451-0},
  pages = 	 {288},
  month = 	 jan,
  ed = 	 {川合 慧},
  title = 	 {情報},
  publisher = 	 {東京大学出版会},
  year = 	 {2006},
  OPTkey = 	 {},
  OPTvolume = 	 {},
  OPTnumber = 	 {},
  OPTseries = 	 {},
  OPTaddress = 	 {},
  OPTedition = 	 {},
  OPTmonth = 	 jan,
  OPTnote = 	 {},
  OPTannote = 	 {}
}

@Article{sakurai2007compsoft,
  author = 	 jsakurai # AND # jmasuhara ,
  yomi = 	 sakurai  # AND # masuhara ,
  title = 	 "アスペクト指向プログラミングにおけるテストに基づいたポイントカットの提案",
  pdf = 	 {compsoft2007.pdf},
  journal = 	 CompSoft,
  year = 	 2007,
  volume = 	 24,
  number = 	 3,
  pages = 	 "141--152",
  month = 	 sep,
  note = 	 "\cite{sakurai2006jssst}の改訂版",
  abstract = 	 {本研究はアスペクト指向プログラミング(AOP)の新たなポイントカット機構として，テストに基づいたポイントカットを提案する．AOP言語はアスペクトを適用する時点を指示しなければならない．既存のAOP言語のポイントカットは，アスペクトが適用されるプログラム中の型名やメソッド名により指示を行うため，プログラムの些細な変更に応じてアスペクトの変更が必要であった．テストに基づいたポイントカットでは，テストを通じて間接的にアスペクトが適用される時点を指示する．そのため，プログラムの変更時にテストも修正される前提の下では，ポイントカット記述の変更が必要なくなる．またテストに基づいたポイントカットは，テストごとに異なる実行履歴を利用して，プログラムの実行時の実行履歴に依存したアスペクトの適用を指示することができる．そのため，適用するプログラムの特定の分岐などの時点を詳細に指示する必要がなくなり，簡潔な記述を得ることができる．実際にいくつかの事例に対してテストに基づいたポイントカットを利用し，ほとんどの場合に既存のAspectJによる記述よりも変更に強く簡潔な記述が可能であることを確認した． },
}

@inproceedings{watanabe2007ppl,
  author = 	 jwatanabe # AND # jmasuhara,
  yomi =          watanabe # AND # masuhara ,
  title = 	 {類似プログラムの提示ツール：{Selene}},
  crossref =	 {ppl2007},
  note =	 {ポスター発表},
}

@Misc{masuhara2007rakuten-tech-talk,
  pdf = 	 {rakuten-tech-talk2007.pdf},
  author =	 jmasuhara ,
  yomi = 	 masuhara,
  title =	 "今そこにあるアスペクト指向プログラミング",
  howpublished = "楽天技術研究所",
  note = "招待講演",
  year =	 2007,
  month =	 apr
}

@InProceedings{aotani2007jssst,
  author = 	 jaotani # AND # jmasuhara ,
  yomi = 	  aotani # { and } # masuhara ,
  title = 	 "アドバイスの安全な実行のためのアスペクト指向プログラミング言語の型システム",
  crossref = 	 "jssst2007",
  pages = {7C--3},
  date = {2007-9-14}
}

@InProceedings{watanabe2007jssst,
  author = 	 jwatanabe # AND # jmasuhara,
  note = 	 {\href{https://www.jssst.or.jp/award/detail/takahashi_list.html}{日本ソフトウェア科学会高橋奨励賞}(受賞者:}#jwatanabe#{)},
  yomi =          watanabe # AND #  masuhara ,
  title = 	 "類似プログラムの提示ツール{Selene}",
  crossref = 	 "jssst2007",
  pages = {3B--2},
  date = {2007-9-13}
}

@Misc{watanabe2008ppl-short,
  author = 	 jwatanabe # AND # jmasuhara,
  yomi =          watanabe # AND # masuhara ,
  howpublished = {PPL2008 ショートプレゼンテーション},
  crossref =     {ppl2008},
}

@Misc{aotani2008ppl-poster,
  author = 	 jaotani # AND # jmasuhara ,
  yomi = 	  aotani # { and } # masuhara ,
  title =	 {プログラム解析に新たな活躍の場を提供する{AspectJ}のコンパイラ{SCoPE}},
  howpublished = {PPL2008 ポスター発表},
  crossref =     {ppl2008}
}

@Misc{muroi2008ppl-poster,
  author =	 jmuroi # AND # jmasuhara,
  yomi = 	  muroi # AND # masuhara ,
  title =	 {アスペクト指向関数型言語{Aspectual Haskell}の設計と実装},
  howpublished = {PPL2008 ポスター発表},
  crossref =     {ppl2008}
}

@Misc{kawauchi2008ppl-poster,
  title = 	 {データ依存関係を利用するアスペクト指向プログラミング言語の拡張dflowとその実現方式},
  howpublished = {PPL2008 ポスター発表},
  crossref =     {ppl2008},
  author = 	 jkawauchi # AND # jmasuhara ,
  yomi = 	  kawauchi # AND # masuhara 
}

@Misc{watanabe2008ppl-poster,
  title = 	 {大規模貯蔵庫からの高速な類似プログラム検索},
  howpublished = {PPL2008 ポスター発表},
  crossref =     {ppl2008},
  author = 	 jwatanabe # AND # jmasuhara ,
  yomi = 	  watanabe # AND #  masuhara 
}

@Article{aotani2008compsoft,
  author = 	 jaotani # AND # jmasuhara ,
  yomi = 	  aotani # AND # masuhara ,
  title = 	 "アドバイスの安全な実行のためのアスペクト指向プログラミング言語の型システム",
  journal = 	 CompSoft,
  year = 	 2009,
  volume = 	 26,
  note = 	 {\cite{aotani2007jssst}の改訂版},
  number = 	 2,
  pdf = 	 {compsoft2009.pdf},
  pages = 	 {170--182},
  month = 	 may,
  abstract = 	 {AspectJをはじめとする多くのアスペクト指向プログラミング言語では，ポイントカット定義を誤った結果，アドバイスが実行されなかったり，想定と異なるジョインポイントの上で実行されることがある．本稿では型システムによってこれら問題の解決を目指す．この型システムはポイントカット内の矛盾と複数のポイントカットの間の矛盾の両方を発見する点が特徴である．本稿では型定義と型規則を示し，いくつかの基本的な誤りを発見できることを確認した．}},


 @Misc{masuhara2008ruby-kaigi,
  author = 	 jmasuhara,
  yomi   = 	  masuhara,
  title = 	 {{Ruby}《を》教えてるんじゃない、{Ruby}《で》教えてるんだってば},
  howpublished = {日本Ruby会議 (RubyKaigi'08)},
  location = 	 {茨城県つくば市},
  month = 	 jun,
  year = 	 2008,
  pdf = 	 {ruby-kaigi2008.pdf}}


@InProceedings{touyama2009ppl,
  author = 	 jtouyama # AND # jmasuhara,
  pdf = 	 {ppl2009.pdf},
  yomi =	 touyama # AND # masuhara,
  title = 	 {異なる型の値を返すアドバイスを許すアスペクト指向言語の織込機構},
  booktitle = {第11回} # PPL # {(PPL2009)},
  pages = 	 {185--199},
  year = 	 2009,
  editor = 	 {千代 英一郎 and 長谷川 真人},
  location = 	 {岐阜県高山市},
  month = 	 mar,
  organization = SIGPPL,
  acceptanceRatio = {9/16 (full paper)},
  abstract = 	 {AspectJ をはじめとする多くのアスペクト指向言語では, 型安全性のため around アドバイスを同じ型の式にしか適用できない. そのため, 例えばラッパーオブジェクトを挿入したり, 無名クラスのインスタンスを置き換えたりするような around アドバイスが記述できない. そこで我々は, 異なる型の値を返すアドバイスを許す型緩和織込機構を提案する. この機構は, アドバイスが置き換える値がどのような静的型で使われているかを局所的に解析し, アドバイスにはそれ以下の型の値に置き換えることを許す. これによって, 型安全性を保ちつつ前述のようなアドバイスが適用可能になる. 本研究では, AspectJ に対して解析のための規則を定義し, その規則に基づく織込機構を組み込んだ処理系を, 既存の AspectJ コンパイラを拡張することで作成した.},
}


                  
@Misc{toyama2010ppl-poster,
  author = 	 jtouyama # AND # jaotani # AND # jmasuhara,
  yomi = 	  touyama # AND #  aotani # AND #  masuhara,
  title = 	 {表現力の高いアドバイスを安全に記述できるアスペクト指向言語{StrongRelaxAJ}},
  howpublished = {第12回プログラミングおよびプログラミング言語ワークショップ(PPL2010)ポスター発表},
  month = 	 {4 }#mar,
  year = 	 2010}


@Book{masuhara2010is,
  author = 	 {増原 英彦 and {東京大学情報教育連絡会}},
  yomi = 	 masuhara # {and {Liaison Committee on Information Education, the University of Tokyo}},
  title = 	 {情報科学入門: {Ruby}を使って学ぶ},
  isbn = 	 {978-4-13-062452-7},
  pages = 	 {254},
  url = 	 {http://www.utp.or.jp/book/b306087.html},
  publisher = 	 {東京大学出版会},
  year = 	 2010,
  month = 	 jun
}

@Article{sakurai2010ipsj-trans-pro,
  pdf = 	 {ipsj-trans-pro-2010.pdf},
  author = 	 jsakurai # AND # jmasuhara # AND # jkomiya,
  yomi = 	  sakurai # AND #  masuhara # AND #  komiya,
  title = 	 {Traceglasses: 効率のよい欠陥の発見手法を実現するトレースに基づくデバッガ},
  journal = 	 ipsj-trans-pro,
  year = 	 2010,
  volume = 	 3,
  number = 	 3,
  pages = 	 {1--17},
  month = 	 jun,
  note = 	 {2011年度 情報処理学会論文誌プログラミング 優秀論文賞},
  annote = 	 {accepted on 24 March 2010},
  abstract = 	 {現状のデバッグはプログラムの不正な動作を理解するために多くの時間とコストを必要とする．本研究は実行トレースを使った新たな欠陥の発見手法を提案することでデバッグの効率化を図り，トレースに基づく Java のためのデバッガである Traceglasses として実装する． Traceglasses は，プログラムの実行中のイベントを記録したトレースの対話的な表示と検索が可能で，利用者がプログラムの動作を遡って欠陥を発見することを支援する． Traceglasses は，トレースをメソッド呼び出し関係により木構造に変換し，ブレークポイントデバッガに見られるようなステップ操作を行わずに，トレースの表示を行う．また，指定されたオブジェクトに対する操作のみを抽出したトレースを表示できる．これらの特徴により，利用者は，実行順に並んだ膨大なトレースに対して局所的および大域的に，必要な部分だけを理解し，効率良く欠陥を発見できる． Traceglasses の実装は，木構造を持つ膨大なトレースを効率良く探索し表示するために，専用のデータ構造を構築する．本発表では， Traceglasses の実装により実際のテキスト整形プログラムの欠陥をプログラムの出力から遡り発見する事例を説明し，提案した欠陥の発見手法と実装について実用上の有用性を示す．}}


@InProceedings{touyama2010jssst,
  author = 	 jtouyama # AND # jaotani # AND # jmasuhara,
  yomi = 	  touyama # AND #  aotani # AND #  masuhara,
  title = 	 {表現力の高いアドバイスを型安全に記述できるアスペクト指向言語{StrongRelaxAJ}},
  crossref =  {jssst2010},
  pages = 	 {4A-2},
  date = 	 {2010-9-14}}

@Article{masuhara2010ipsj,
  author = 	 jmasuhara,
  pdf = 	 {masuhara2010ipsj.pdf},
  yomi = 	 masuhara,
  title = 	 {プログラミング，何をどう教えているか: プログラミングを教える・プログラミングで教える},
  journal = 	 ipsj-mag,
  year = 	 2010,
  volume = 	 51,
  number = 	 12,
  pages = 	 {1627--1629},
  month = 	 dec,
  url = 	 {https://ci.nii.ac.jp/naid/40017431963/},
  OPTurl = {http://fw8.bookpark.ne.jp/cm/ipsj/search.asp?flag=6&keyword=IPSJ-MGN511216&mode=PRT}
}

@Misc{toyama2011ppl-poster,
  author = 	 jtouyama #and# jaotani #and# jmasuhara,
  yomi   = 	  touyama #and#  aotani #and#  masuhara,
  title = 	 {総称型に対応した拡張型緩和織込機構の提案},
  crossref = 	 {ppl2011},
  note = 	 {ポスター発表.}}

@InProceedings{kamina2011ses,
  author = 	 jkamina #AND# jaotani #AND# jmasuhara #AND# jtamai,
  yomi = 	 kamina #AND# aotani #AND# masuhara #AND# tamai,
  pdf = 	 {ses2011.pdf},
  title = 	 {ユースケースを用いた文脈指向ソフトウェア開発},
  booktitle = {ソフトウェアエンジニアリングシンポジウム2011論文集},
  pages = 	 {1--8},
  year = 	 2011,
  location = 	 {東京女子大学},
  month = 	 sep,
  abstract = 	 {近年，実行時文脈に依存した実行を行うシステムへの要求が高まっており，文脈指向プログラミング（Context-Oriented Programming: COP）が提案されている．本研究は，ユースケースから， COP 言語の一つである EventCJ へと変換する手法について提案する．本手法により，特定の文脈で実行されるユースケースや，文脈がいつどのように変化するかに関する仕様を，設計や実装を通して分離したままシステムの開発を行うことが可能になる．},
}

@InProceedings{aotani2011jssst,
  pdf = 	 {jssst2011-aotani.pdf},
  author = 	 jaotani #AND# jkamina #AND# jmasuhara #AND# jtamai, 
  yomi = 	 aotani #AND# kamina #AND# masuhara #AND# tamai, 
  title = 	 {オブジェクト毎の層遷移を宣言的に記述できる文脈指向言語{EventCJ}},
  crossref =  {jssst2011},
  pages = 	 {4A-4},
  date = 	 {2011-09-28},
  abstract = 	 {文脈指向言語 EventCJ を提案する。文脈指向プログラミングは文脈に依存する振る舞いを部分メソッドで定義し、それらをまとめた層として文脈をモジュール化するプログラミング手法である。文脈の変化は層の活性状態を実行時に変更することで実現する。 EventCJ は Java を拡張した文脈指向言語で、 ContextJ をはじめとする既存の文脈指向言語と同様に、部分メソッドと層を持つ。またイベントと活性層の遷移規則を持ち、オブジェクト毎の層の活性状態の変更を宣言的に記述できる特徴がある。本論文では EventCJ の言語設計を説明し、 Featherweight Java を拡張した小さな計算体系 Featherweight EventCJ を定義して、 EventCJ の意味論を与える。}}

@InProceedings{nishiguchi2011jssst,
  author = 	 jnishiguchi #AND# jmasuhara,
  pdf = 	 {jssst2011-nishiguchi.pdf},
  yomi = 	 nishiguchi #AND# masuhara,
  title = 	 {{GPU}汎用計算を配列イテレータとして記述する{Ruby}言語処理系の提案},
  crossref =  {jssst2011},
  pages = 	 {1D-2},
  date = 	 {2011-09-27},
  abstract = 	 {本研究は GPU 汎用計算記述のための Ruby 言語処理系 Ikra を提案する． Ikra は GPU のメモリに実体がある配列を Ruby の 1 クラスとして提供し，配列に対する map や inject のなどのイテレータを GPU 上で並列実行する．処理系はイテレータに対するブロック引数の Ruby コードを CUDA のカーネル関数へとあらかじめ変換しておき，イテレータ呼出時に CPU/GPU 間のデータ転送を行った後に CUDA コードを実行する．簡単な計算プログラムのプロトタイプ処理系による計算部分 ( カーネル ) の実行速度は，同等の CUDA プログラムの 0.9〜1 倍， Ruby インタプリタによる実行の 2000〜8000 倍であった．}}

@Misc{murakami2012ppl-poster,
  author = 	 jmurakami #AND# jmasuhara,
  yomi = 	 murakami #AND# masuhara,
  title = 	 {コード推薦システムの既存プログラムを用いた最適化 },
  crossref = {ppl2012},
  note = 	 {ポスター発表}}

@Misc{nishiguchi2012ppl-demo,
  author = 	 jnishiguchi #AND# jmasuhara,
  yomi = 	 nishiguchi #AND# masuhara,
  title = 	 {{GPU}向けプログラムを{Ruby}で記述できる言語処理系{Ikra}},
  crossref = {ppl2012},
  note = 	 {ポスター・デモ発表}}

@Misc{kamina2012pro,
  author = 	 jkamina #and# jaotani #and# jmasuhara,
  pdf = 	 {kamina2012pro.pdf},
  yomi = 	 kamina #and# aotani #and# masuhara,
  title = 	 {文脈指向言語{EventCJ}への合成層の導入},
  howpublished = IPSJ-PRO-PRE # {89} # IPSJ-PRO-POST # {2012-1-(3)},
  month = 	 jun,
  year = 	 2012,
  day = 	 {2012-06-21},
  note = 	 {英語版が情報処理学会論文誌:プログラミング6(1)1--8に採録\cite{kamina2013ipsj-trpro}},
  abstract = 	 {多くの文脈指向言語は，文脈依存の振舞の集まりを層と呼ばれる単位にまとめ，実行時文脈に応じてそれらを動的に活性化／非活性化するための言語機構を持つ．しかし振舞は一つの文脈に依存するとは限らず，特定の文脈の組み合わせでのみ実行される振舞が存在する．そのため，従来の文脈指向言語では，いつ，どの層を活性化させるかに関する指定が複雑になり，文脈に関する複数の関心事が層活性を行うコード中に混在してしまう．本論文では，新たに合成層の機構を提案し，それによってこれらの問題が解決されることを示す．合成層は他の層の活性状態に依存した層で，他の層の名前を基礎項（活性のときに真）とした論理式を宣言する．合成層は，その論理式が真であるとき，またそのときのみに活性となる．そして，文脈指向言語の一つである EventCJ に合成層を導入し，ツイッタクライアントとプログラムエディタの二つの事例研究を通して合成層の有効性を検証する．結果，合成層を用いた場合では，合成層を用いない場合と比較して層活性のコードが単純になり，層活性を行うコード中に文脈に関する複数の関心事が混ざり合わないことが分かった．また，合成層を持つEventCJ の実現方法を提案する．}}

@Misc{aotani2012pro,
  pdf = 	 {aotani2012pro.pdf},
  author = 	 jaotani #and# jkamina #and# jmasuhara,
  yomi = 	 aotani #and# kamina #and# masuhara,
  title = 	 {文脈指向プログラムの資源利用解析に基づく層活性解析法},
  howpublished = IPSJ-PRO-PRE # {89} # IPSJ-PRO-POST # {2012-1-(4)},
  month = 	 jun,
  year = 	 2012,
  day = 	 {2012-06-21},
  abstract = 	 {Context-oriented programming (COP) languages help programmers to modularize behavioral variations that depend on contexts such execution environments and internal states of the program. The programmer specifies when and which variations get activated explicitly. This paper addresses the following two issues in context-oriented programs. First, it is hard to check whether each variation is activated according to the specification of the program. Second, programs written in COP languages are generally not eﬃcient from the view point of runtime performance, because there is an overhead to check whether each variation is activated at runtime. All these issues fall into the problem to find a sound order of activation with respect to the specification of the program. As a foundation to address the problem, this paper proposes a type-based analysis to check whether or not the program activates each behavioral variation correctly, i.e., the inferred order is a subset of the one described in the specification. The analysis is based on the resource usage analysis proposed by Igarashi and Kobayashi. It models a value that records a set of active variations as a resource, and an operation that activates a variation as use.}}

@Misc{masuhara2012tsukuba-talk,
  author = 	 jmasuhara,
  yomi = 	 masuhara,
  title = 	 {Rubyは理想の教育用言語か?},
  howpublished = {招待講演},
  month = 	 nov,
  year = 	 2012,
  date = 	 {2012-11-21},
  note = 	 {筑波大学情報学群情報科学類 第一回情報科学シンポジウム「国際化する日本発プログラミング言語Ruby」}}


@Article{aotani2013compsoft,
  author = 	 jaotani #and# jkamina #and# jmasuhara,
  yomi = 	 aotani #and# kamina #and# masuhara,
  OPTurl = 	 {https://www.jstage.jst.go.jp/article/jssst/30/3/30_3_130/_pdf},
  title = 	 {オブジェクト毎の層遷移を宣言的に記述できる文脈指向言語{EventCJ}},
  journal = 	 compsoft,
  year = 	 2013,
  volume = 	 30,
  number = 	 3,
  pages = 	 {130--147},
  month = 	 jul,
  doi = 	 {10.11309/jssst.30.3_130},
  annote = 	 {accepted on February 17, 2013},
  abstract = 	 {文脈指向言語EventCJを提案する．文脈指向プログラミングは文脈に依存する振舞を部分メソッドで定義し，それらをまとめた層として文脈をモジュール化するプログラミング手法である．文脈の変化は層の活性状態を実行時に変更することで実現する．EventCJはJavaを拡張した文脈指向言語で，層という単位で振舞を文脈ごとにモジュール化する．またEventCJはイベント宣言と活性層の遷移規則を持つ．これらの機構によって，オブジェクトごとの層の活性制御の宣言的な指定と，呼出し文脈を跨った層の活性制御が可能となった．本稿ではEventCJの言語設計を説明し，ContextFJを拡張した計算体系Featherweight EventCJを定義して，EventCJの意味論を与える．またAspectJプログラムへの変換によるコンパイル方法と最適化手法のアイデアを示す． }
}

@Misc{kamina2013ppl-poster,
  author = 	 jkamina #and# jaotani #and# jmasuhara,
  yomi = 	 kamina #and# aotani #and# masuhara,
  title = 	 {{JavaCat}: Realizing Context as Fluent},
  month = 	 mar,
  year = 	 2013,
  crossref = 	 {ppl2013},
  note = 	 {ポスター発表}
}

@Misc{inoue2013ppl-poster,
  author = 	 "井上 裕昭" #and# jigarashi #and# hirschfeld #and# jmasuhara,
  yomi = 	 "Hiroaki Inoue" #and# igarashi #and# hirschfeld #and# masuhara,
  title = 	 {動的レイヤー合成のための型システム},
  month = 	 mar,
  year = 	 2013,
  crossref = 	 {ppl2013},
  note = 	 {ポスター発表}
}

@InProceedings{murakami2013jssst,
  author = 	 jmurakami #and# jmasuhara #and# jaotani,
  yomi   = 	  murakami #and#  masuhara #and#  aotani,
  pdf = 	 {jssst2013.pdf},
  title = 	 {関心度に基づいたソースコード推薦システム},
  crossref =  {jssst2013},
  note = 	 {(萌芽2-4)1--10},
  date = 	 {2013-09-11},
  abstract = 	 {コード推薦システムの多くは，開発者が編集中の行の周辺行に類似したプログラムを大規模コードリポジトリから検索し，開発者が次に書くと予測されるコードとして類似部分の後続行を提示する．検索の際に周辺行だけでなくその背景情報---これから記述しようとしている内容やそれが使われている場所---も用いればより精度の高い予測が出来ると予想されるが，そのような情報をコードから抽出することは容易でない．そこで我々は，統合開発環境の編集操作履歴からコードの背景情報を抽出し，それを背景情報として用いた検索を行うコード推薦システムを提案する．システムは既存のコード推薦システムSelene を拡張し，コード編集操作履歴から開発者が最近に閲覧・編集したコード中の単語を抽出し，それらを重み付けして編集中の行の周辺行の単語情報と共に検索コード推薦を行う．単語重みは，複数の開発者の開発記録を基に機械学習し決定する．}}


                  
@Misc{kamina2013fose-poster,
  author = 	 jkamina #and# jaotani #and# jmasuhara #and# jtamai,
  yomi   = 	  kamina #and#  aotani #and#  masuhara #and#  tamai,
  title = 	 {{COSE}: 文脈に依存した振る舞いをモジュール化するソフトウェア開発手法},
  howpublished = {第20回ソフトウェア工学の基礎ワークショップ(FOSE2013)},
  month = 	 nov,
  dates = 	 {November 28--30, 2013},
  year = 	 2013,
  location = 	 {石川県加賀市}}



@Misc{toyama2014ppl-poster,
  author = 	 jtouyama #and# jaotani #and# bodden #and# jmasuhara #and# tanter,
  yomi   = 	  touyama #and#  aotani #and# bodden #and#  masuhara #and# tanter,
  title = 	 {Interfaces for Separate Compilation of Aspect-Oriented Programs with Inter-Type Declarations},
  crossref = 	 {ppl2014},
  note = 	 {ポスター発表}}

@Misc{shao2014ppl-poster,
  author = 	 jshao #and# jaotani #and# jmasuhara #and# jtouyama,
  yomi = 	  shao #and#  aotani #and#  masuhara #and#  touyama,
  title = 	 {アスペクト指向アルゴリズムアニメーションフレームワーク},
  crossref = 	 {ppl2014},
  note = 	 {ポスター発表}}

@Misc{asakura2014ppl-poster,
  author = 	 jasakura #and# jmasuhara #and# jaotani,
  yomi = 	  asakura #and#  masuhara #and#  aotani,
  title = 	 {型安全なシェルプログラミングのための領域特化言語の提案},
  crossref = 	 {ppl2014},
  note = 	 {ポスター発表}}

@Article{murakami2014ipsj-sigse,
  author = 	 jmurakami #and# jmasuhara #and# jaotani,
  yomi = 	  murakami #and#  masuhara #and#  aotani,
  title = 	 {関心度に基づいたソースコード推薦システム},
  booktitle = {情報処理学会ソフトウェア工学研究会報告},
  journal = {情報処理学会ソフトウェア工学研究会報告},
  pages = 	 {1 - 8 },
  year = 	 2014,
  volume = 	 {2014-SE-183 },
  number = 	 14 ,
  month = 	 mar,
  organization = ipsj,
  date = 	 {2014-03-20},
	annote = 				 {unrefereed}}


@Article{asakura2014ipsj-pro,
  author = 	 jasakura #and# jmasuhara #and# jaotani,
  yomi = 	  asakura #and#  masuhara #and#  aotani,
  title = 	 {{OCommand} : {OCaml}上の型安全なシェルプログラミングのための領域特化言語の提案},
  journal = 	   IPSJ-PRO-PRE # {99} # IPSJ-PRO-POST,

  year = 	 2014,
  location = 	 {旭川市民文化会館},
  pages = 	 {2014-1-(3)},
  month = 	 jun,
  date = 	 {2014-06-20},
  annote = 	 {発表のみ},
  abstract = 	 {OCamlプログラム中からシェルコマンドを型安全に実行するための領域特化言語OCommandを提案する．OCommandはコマンドの仕様である，出力行の各欄の型とコマンドオプションによって起きる変化の記述を受け取り，コマンド起動関数とコマンドオプションを表す値定義を持つOCamlモジュールを生成する．生成された起動関数は，複数のオプション値を受け取りコマンドを実行し，オプションに応じてコマンド出力行をパースして型付きのフィールドからなるレコードを返す．出力行レコードにおけるフィールドの型や存在の変化を静的に検査するため，一般化代数的データ型を用いた．Camlp4を用いて実現した処理系を用いて，これまでにlsやpsなどのコマンドを扱えることを確めている．}
}


                  
@Misc{imai2014jssst,
  author = 	 jimaitomoki #and# jmasuhara #and# jaotani,
  yomi = 	  imai       #and#  masuhara #and#  aotani,
  title = 	 {{Shiranui}: テストフレンドリーなライブプログラミング言語環境},
  crossref = 	 {jssst2014},
  date = 	 {2014-09-09},
  note = 	 {ポスター発表}}

@Misc{asakura2014jssst,
  author = 	 jasakura #and# jmasuhara #and# jaotani,
  yomi = 	  asakura #and#  masuhara #and#  aotani,
  title = 	 {シェルコマンドを型安全に利用するための領域特化言語{OCommand}},
  date = 	 {2014-09-09},
  crossref = 	 {jssst2014},
  note = 	 {ポスター発表}}

@Misc{huang2015-ppl-poster,
  author = 	 jhuang #and# jmasuhara #and# jaotani,
  yomi = 	  huang #and#  masuhara #and#  aotani,
  title = 	 {{Pyrlang}: {RPython}を用いた高性能{Erlang} {BEAM}仮想マシン},
  crossref = 	 {ppl2015},
  date = 	 {2015-03-04},
  note = 	 {ポスター発表},
  abstract = 	 {我々はPyrlangというErlangのBEAMバイトコードインタープリタを開発している。このインタープリタは、PyPy言語処理系のために開発されたRPythonで記述しているため、JITヒント関数を挿入するだけで、RPythonに内蔵されたmeta-tracing just-in-time (JIT) コンパイラによる機械語生成が行われる。小さなベンチマークプログラムに対しては、既存のBEAMインタープリタより1.5倍の高速化を達成している。本ポスターでは、meta-tracing JIT コンパイルがどの程度容易に行えるかを報告する。}}

@Misc{asakura2015-ppl-poster,
  author = 	 jasakura #and# jmasuhara #and# jaotani,
  yomi = 	  asakura #and#  masuhara #and#  aotani,
  title = 	 {{GPGPU}カーネル検証のための分離論理の{Coq}による形式化},
  crossref = 	 {ppl2015},
  date = 	 {2015-03-05},
  note = 	 {ポスター発表},
  abstract = 	 {本研究の目標はGPGPUのための並行分離論理(CSL)をCoqで形式化することである．BlomらはGPGPUカーネルを検証するためのバリア付きCSLと，barrier divergenceが起こらないための十分条件(lock-step safety)を提案し，証明の概略を与えた．また，Vafeiadisはバリアの無いCSLの健全性の簡潔な証明を提案した．本研究ではCoqを用いてBlomらのバリア付きCSLを再形式化し，健全性をVafeiadisの証明法を応用して示す．またlock-step safetyの健全性の証明を，任意の2スレッド間のnon-interferenceを示すことで与える．}}

@Misc{fujita2015-ppl-poster,
  author = 	 jfujita     #and# jmasuhara #and# jaotani,
  yomi = 	 fujita      #and#  masuhara #and#  aotani,
  title = 	 {例外処理を分離する{Chop\&Graft}アドバイス機構の提案},
  crossref = 	 {ppl2015},
  date = 	 {2015-03-05},
  note = 	 {ポスター発表},
  abstract = 	 {処理の中断や再開といった大域的な実行制御を伴う例外処理をアスペクト指向言語を用いて分離する場合、複数のアドバイス定義をthrow-catchによって接続するような複雑なものとなる。我々は大域的な実行制御を可能にするChop&Graftアドバイス機構を提案する。このアドバイスはプログラム2つの結合点を指定し、1つの結合点からもう1つの結合点までの実行を疑関数として制御できるため、実行の中断や再開といった処理を簡潔に記述できる。本ポスターでは機構の定義と、AspectSchemeと限定継続を用いた実現、AspectJ とスレッドを用いた実現方針の検討を紹介する。}}

@Misc{imai2015-ppl-poster,
  author = 	 jimaitomoki #and# jmasuhara #and# jaotani,
  yomi = 	  imai       #and#  masuhara #and#  aotani,
  title = 	 {ライブプログラミングにユニットテストを統合する機能の提案},
  crossref = 	 {ppl2015},
  date = 	 {2015-03-05},
  note = 	 {ポスター発表},
  abstract = 	 {ライブプログラミングは，プログラムを記述している最中にその実行結果や，実行履歴の情報が随時表示されるため，試行錯誤や誤りの早期発見に優れている．しかしプログラムの正しさは表示結果を目視で確認するだけなので，本格的なソフトウェア開発で用いられているようなユニットテストを作成することは二度手間となってしまっていた． そこで本研究はライブプログラミング言語 Shiranui にユニットテストを統合するための機能を提案する．正しさが確認できた結果や，確認のための計算中に出現した(関数オブジェクトを含む)値からのテストケース作成を支援する機能によってこれまでよりも容易かつ細かな単位でテストを行えることを可能にする．本発表では，提案機能を実装したプロトタイプのデモを行う．}}

@Misc{kiriyama2015-ppl-poster,
  author = 	 jkiriyama #and# jaotani #and# jmasuhara,
  yomi = 	  kiriyama #and#  aotani #and#  masuhara,
  title = 	 {{Haskell}のモジュラリティと効率の両立のためのコンパイル時データ合成},
  crossref = 	 {ppl2015},
  date = 	 {2015-03-05},
  note = 	 {ポスター発表},
  abstract = 	 {Data Types a la Carte(以下DTCと略す)は，HaskellにおけるThe Expression Problemの解決の1つである．DTCでは，多重定義された関数を使って関数を多重定義しているため，プログラムの実行効率が悪い．本研究ではDTCに基づいて記述されたプログラムを，多重定義ではない関数を用いる同等のプログラムに変換することで実行効率を改善する．マイクロベンチマークで比較した結果，変換後のプログラムの実行時間はDTCで書かれたプログラムの実行時間の約33\%であった．}}

@Article{asakura2015ipsj-pro,
  author = 	 jasakura #and# jmasuhara #and# jaotani,
  yomi = 	 asakura  #and#  masuhara #and#  aotani,
  title = 	 {{GPGPU}のための並行分離論理の{Coq}による健全性証明},
  journal = 	   IPSJ-PRO-PRE # {104} # IPSJ-PRO-POST,
  year = 	 2015,
  pages = 	 {2015-1-(4)},
  month = 	 jun,
  location = 	 {富山県教育文化会館},
  date = 	 {2014-06-04},
  annote = 	 {同時投稿論文が採録\cite{asakura2015jip}}
}

@Article{matsumoto2015ipsj-mag,
  author = 	 {松本 行弘 and 加藤 和彦 and 千葉 滋}#and# jmasuhara
		 #and# {小野寺 民也 and 笹田 耕一 and 高橋 征義},
  yomi = 	 {Yukihiro Matsumoto and Kazuhiko Kato and Shigeru Chiba}#and# masuhara
		 #and# {Tamiya Onodera and Koichi Sasada and Masayoshi Takahashi},
  title = 	 {{Ruby}の20年, {Ruby}のこれから},

  journal = 	 IPSJ-mag,
  etitle = 	 {20 Years of {Ruby}, The Future of {Ruby}},
  year = 	 2015,
  volume = 	 56,
  number = 	 12,
  pages = 	 {1192-1197},
  month = 	 dec}


@InProceedings{asakura2016ppl,
  author = 	 jasakura #and# jmasuhara #and# jaotani,
  yomi = 	  asakura #and#  masuhara #and#  aotani,
  pdf = 	 {ppl2016.pdf},
  title = 	 {{GPGPU}向けデータ並列コードテンプレートの形式検証},
  month = 	 mar,
  year = 	 2016,
  crossref =  {ppl2016},
  abstract = 	 {GPGPU向けデータ並列DSL (GPUDSL) はmapやreduceといったよく知られた並列スケルトンを用いて高性能なGPGPUプログラムを容易に記述するための言語である．GPUDSLのコンパイラは処理する配列の型などでパラメタライズされたGPGPUコード (コードテンプレート) を用いてコード生成を行うが，そのようなコード生成の正しさを保証することは容易ではない．その要因として (i) GPGPUの並列実行モデルや，(ii) テンプレートの引数に対して生成コードや生成コードの満たすべき仕様が変化する点が挙げられる．本研究ではコードテンプレートをGPGPUコードを生成するCoqの関数としてモデル化し，その正しさをGPGPU向け並行分離論理を用いてCoq上で検証する手法を提案する．さらにこの手法の適用例としてmapやreduceスケルトンに対応するコードテンプレートの検証も示す．}}


@Misc{okugawa2016-ppl-poster,
  author = 	 jokugawa #and# jaotani #and# jmasuhara,
  yomi = 	  okugawa #and#  aotani #and#  masuhara,
  title = 	 {{Featherweight Java}の{Meta-Theory a la Carte}を利用した拡張可能な形式化フレームワーク},
  crossref = 	 {ppl2016},
  note = 	 {ポスター発表},
  abstract = 	 {本研究ではFeatherweight Java(以降FJと略す)のCoqにおける拡張可能な形式化に取り組む．FJはクラスのあるオブジェクト指向言語を形式化した小さな計算体系であり，例えばFetherweight Generic Javaのような拡張が存在する．これらの拡張をCoqなどの定理証明支援系で形式化する際，FJからの差分として形式化できるのが望ましい．本研究ではthe expression problemの型クラスを用いた解決法であるdatatypes a la carteに基づいた，Delawareらによる発表可能な形式化のための枠組みmeta-theory a la carte(MTC)を応用する．発表では構文と操作的意味，型付け規則のMTCに基づく形式的定義を紹介する．}}

@Misc{huang2016-ppl-poster,
  author = 	 jhuang #and# jmasuhara #and# jaotani,
  yomi = 	  huang #and#  masuhara #and#  aotani,
  title = 	 {{RPython}を用いた{Erlang}仮想機械{Pyrlang}における{JIT}コンパイル方針の改良},
  crossref = 	 {ppl2016},
  note = 	 {ポスター発表},
  abstract = 	 {我々はPyrlangというErlang仮想機械を開発している。この仮想機械は、言語処理系開発向けのRPythonで記述されたインタープリタにJITヒント関数を挿入することで、RPythonに内蔵されたmeta-tracing just-in-time (JIT) コンパイラが機械語生成を行う。本研究ではこの仮想機械に、Erlang言語に特化したhot spot検出方針とメモリオーバーヘッドの削減方法を追加した。これによって既存のインタープリタ方式仮想機械より2.03倍、静的コンパイラより1.13倍の高速化を達成した。ポスターではPyrlangの仕組みとErlang向けの最適化手法を報告する。 }}

@Misc{watanabe2016-ppl-poster,
  author = 	 jwatanabekeita #and# jmasuhara #and# jaotani,
  yomi = 	  watanabekeita #and#  masuhara #and#  aotani,
  title = 	 {多次元的文脈指向言語{Korz}のメソッドディスパッチの改善},
  crossref = 	 {ppl2016},
  note = 	 {ポスター発表},
  abstract = 	 {本研究では文脈指向言語Korzの表現力の改善を行う。文脈指向プログラミングとは、文脈に依存した振る舞いを分離して記述するプログラミング手法である。 Korzは他の文脈指向言語と異なり多次元的文脈システムを備えている。表現力に関する予備的な調査として、既存の文脈指向言語で書かれたプログラムをKorzで再記述した。その結果Korzではメソッドディスパッチの非決定性や、文脈の変更なしでより一般的なメソッドを呼び出せないことから、記述できない場合があることを確認した。そこで本研究は、新しいメソッドディスパッチの仕組み、軸の優先順位、call-next-methodを提案する。さらにCommonLisp上のインタープリタとしてKorz処理系を作り、改善案を実装することでその有用性を確認した。}}

@Article{imai2016pro,
  pdf = 	 {pro-2016-3-7.pdf},
  author = 	 jimai #and# jmasuhara #and# jaotani,
  yomi = 	  imai #and#  masuhara #and#  aotani,
  title = 	 {ライブプログラミング環境におけるユニットテスト機能の設計と実現方法},
  volume = 	 {},
  journal = 	   IPSJ-PRO-PRE # {111} # IPSJ-PRO-POST,
  year = 	 2016,
  pages = 	 {2016-3-(7)},
  month = 	 oct,
  date = 	 {2016-10-27},
  review = 	 {false},
  abstract = 	 {ライブプログラミング環境はプログラム中の式をコード編集中に実行し，即座にその結果を表示する．この即時のフィードバックにより，プログラマは一時な式をプログラム中に書き，引数や定義を変更することで試行錯誤的なプログラミングを容易に行える．我々は試行錯誤的なプログラミング過程とテスト駆動開発の類似性に注目し，ライブプログラミングのためのユニットテスト機能を提案する．この機能は，(1)一時的な式とユニットテストケースを簡単な相互変換し，(2)実行途中に得られた値を式に変換し，ユニットテストの期待値として利用可能にする．我々はこのテスト機能をShiranuiライブプログラミング環境中に作成した．本発表では，このテスト機能の設計とインタプリタによる実現方式を紹介する．}}

@Article{oka2017ipsj-pro,
  author = 	 joka #and# jmasuhara #and# jaotani,
  yomi = 	 oka #and# masuhara #and# aotani,
  title = 	 {ライブプログラミングのためのデータ構造の可視化と対話機能},
  journal = 	   IPSJ-PRO-PRE # {113} # IPSJ-PRO-POST,
  year = 	 2017,
  pages = 	 {2016-5-(8)},
  month = 	 mar,
  location = 	 {東京大学},
  date = 	 {2017-03-03},
  review = 	 {false},
  abstract = 	 {ライブプログラミング環境はプログラムを編集すると即座にプログラムを実行し，その結果を出力する．これまで，画像や音を出力するプログラムに対して特に有効だと考えられていた．一方，データ構造の定義や操作を行う際，プログラマはオブジェクト間の参照関係を思い浮かべながらプログラムを書くことが多い．そこで我々は，データ構造のためのライブプログラミング環境Kanonを提案する．具体的には，プログラムが編集されるたびに，プログラムを実行し，その途中で生成されたオブジェクトおよび参照関係（以下，グラフ構造と呼ぶ）を図表現として可視化する．プログラマによる試行錯誤を容易にするため，以下のような機能を設計・実現した．(1)カーソル位置に連動して実行途中のグラフ構造やその変化を表示する機能，特に複数回実行された命令上にカーソルがある場合は，個別の状態を表示したり，すべての回で起きた変化をいっせいに表示したりする機能，(2)図表現上のオブジェクトや参照関係をクリックすることで，それらが作られたときのグラフ構造を表示し，コード位置を教えてくれる機能，(3)プログラムの編集によってグラフ構造が変化した際にも，図表現の概形を保つ機能である．JavaScript言語を対象に，Kanonの処理系をKhan Academyのlive-editorを拡張して作成した．}
}

@Article{kani2017ipsj-pro,
  author = 	 jkani #and# jasakura #and# jmasuhara #and# jaotani,
  yomi = 	 kani #and# asakura #and# masuhara #and# aotani,
  title = 	 {バリア同期と共有メモリを備えた{GPGPU}プログラム合成器{Kani-CUDA}},
  journal = 	   IPSJ-PRO-PRE # {113} # IPSJ-PRO-POST,
  year = 	 2017,
  pages = 	 {2016-5-(6)},
  month = 	 mar,
  location = 	 {東京大学},
  date = 	 {2017-03-04},
  review = 	 {false},
  abstract = 	 {GPGPUとはGPUを汎用計算のために用いる技術であり，高い並列性によって大規模な計算を高速に行うことができる．しかし，GPGPUプログラミングは一般的なプログラミングよりも記述が複雑であり正しさを確信することが難しい．たとえば，共有メモリを用いたブロッキング最適化におけるメモリアドレスの計算式が複雑になることや，非同期的に実行されるスレッド間でメモリ競合が起きないことの確認などである．このような難しさに対してGPGPUプログラミングを支援するためのプログラム合成器が考案されている．しかし，これらの合成器はバリア同期や共有メモリがない単純な実行モデルを採用しているため，高度な最適化がなされたプログラムを扱うことができなかった．そこで我々はバリア同期と共有メモリを備えたよりCUDAに近い意味論を持ったプログラム合成器Kani-CUDAを提案する．Kani-CUDAは既存のGPGPUプログラム合成器SynthCLをもとに設計されているが，その実行方式はSynthCLがインタリーブ実行であるのに対し，Kani-CUDAではバリア同期を扱うためにロックステップ実行を採用している．応用例として熱拡散ステンシル計算に共有メモリ最適化を施したプログラムにおいて，配列の添え字計算式やバリア同期命令の配置の合成を達成した．}
}

@Misc{asakura2017ppl-poster,
  author = 	 jasakura #and# jmasuhara #and# jaotani,
  yomi = 	  asakura #and#  masuhara #and#  aotani,
  title = 	 {検証済みコンパイラ{CertSkel}による{GPGPU}プログラム開発},
  crossref = 	 {ppl2017},
  note = 	 {ポスター発表}}

@Misc{imai2017ppl-poster,
  author = 	 jimai #and# jmasuhara #and# jaotani,
  yomi = 	  imai #and#  masuhara #and#  aotani,
  title = 	 {ライブプログラミング環境によるプログラマの行動と生産性への影響に関する実証研究},
  crossref = 	 {ppl2017},
  note = 	 {ポスター発表}
}

@Misc{oka2017ppl-poster,
  author = 	 joka #and# jmasuhara #and# jimai #and# jaotani,
  yomi = 	  oka #and#  masuhara #and#  imai #and#  aotani,
  title = 	 {Kanonライブプログラミング環境を用いたデータ構造のプログラミング},
  crossref = 	 {ppl2017},
  note = 	 {ポスター発表}}

@Misc{kani2017ppl-poster,
  yomi = 	  kani #and#  asakura #and#  masuhara #and#  aotani,
  author = 	 jkani #and# jasakura #and# jmasuhara #and# jaotani,
  title = 	 {{Kani-CUDA}による{GPGPU}プログラムの合成},
  crossref = 	 {ppl2017},
  note = 	 {ポスター発表}}

@Article{asakura2017ipsj-pro,
  yomi   = 	  asakura #and#  masuhara #and# {Takuya Matsumoto and Kiminori Matsuzaki},
  author = 	 jasakura #and# jmasuhara #and# {松本 拓也 and 松崎 公紀},
  title = 	 {超解像処理における{Accelerate}プログラムのオーバーヘッドとその解消},
  journal = 	 IPSJ-PRO-PRE # {114} #IPSJ-PRO-POST,
  year = 	 2017,
  key = 	 {2017-1-(3)},
  month = 	 jun,
  location = 	 {静岡県静岡市},
  note = 	 {論文誌論文\cite{asakura2017jip}として採録},
  date = 	 {2017-06-08},
  
}

2017-09-21
@Misc{asakura2017jssst-poster,
  yomi = 	  asakura #and#  masuhara #and#  aotani,
  author = 	 jasakura #and# jmasuhara #and# jaotani,
  title = 	 {{CertSkel}: 高水準{GPGPU}言語のための形式検証済みコンパイラ},
  booktitle = JSSST #{第34回大会},
  month = 	 sep,
  year = 	 2017,
  note = 	 {ポスター発表},
  date = 	 {2017-09-21},
  location = 	 {慶應義塾大学日吉キャンパス}}

@Article{masuhara2017ipsj-mag,
  yomi   = 	  masuhara,
  author = 	 jmasuhara,
  title = 	 {会議レポート: {〈Programming〉} 2017報告},
  journal = 	 IPSJ-mag,
  year = 	 2017,
  volume = 	 58,
  number = 	 9,
  url = 	 {http://id.nii.ac.jp/1001/00182834/},
  pages = 	 {844--845},
  month = 	 sep,
  OPTnote = 	 {},
  review = 	 {false}}

                  
@Misc{masuhara2107jhes-invited,
  yomi = 	  masuhara,
  author = 	 jmasuhara,
  title = 	 {実用的なライブプログラミングに向けて},
  slides = 	 {jhes2017.pdf},
  note = {電気関係学会北陸支部連合大会: 招待講演},
  month = 	 sep,
  year = 	 2017,
  date = 	 {2017-09-11},
  location = 	 {富山大学}}

@Article{kato2017ipsj-mag,
  yomi = 	 {Jun Kato} #and# masuhara,
  author = 	 {加藤 淳} #and# jmasuhara,
  title = 	 {プログラミング・エクスペリエンスの新潮流 -言語設計から産業応用まで: 編集にあたって},
  journal = 	 ipsj-mag,
  year = 	 2017,
  volume = 	 58,
  number = 	 11,
  pages = 	 {1006--1009},
  month = 	 nov,
  date = 	 {2017-10-15},
  review = 	 {false}
}

@Misc{izawa2018ppl-poster,
  yomi   = 	  izawa #and #  masuhara #and #  aotani,
  author = 	 jizawa #and # jmasuhara #and # jaotani,
  title = 	 {メタ混合{JIT}コンパイラの提案},
  crossref = 	 {ppl2018},
  note = 	 {ポスター発表}}

@Misc{tanabe2018ppl-poster,
  yomi   = 	  tanabe #and #  aotani #and #  masuhara,
  author = 	 jtanabe #and # jaotani #and # jmasuhara,
  title = 	 {プログラミング言語へのバージョンの導入の研究},
  crossref = 	 {ppl2018},
  note = 	 {ポスター発表}}

@Misc{okugawa2018ppl-poster,
  yomi   = 	  okugawa #and #  aotani #and #  masuhara,
  author = 	 jokugawa #and # jaotani #and # jmasuhara,
  title = 	 {証明支援器{Coq}を使ったプログラミング言語の操作的意味論に基づく型安全性の拡張可能な形式化の研究},
  crossref = 	 {ppl2018},
  note = 	 {ポスター発表}}

@Article{masuhara2018compsoft,
  yomi = 	 masuhara,
  author = 	 jmasuhara,
  title = 	 {(少し)反転してみた},
  journal = 	 compsoft,
  pages = 	 {85--86},
  year = 	 2018,
  volume = 	 35,
  number = 	 2,
  month = 	 may,
  note = 	 {コラム}}

2018-05-29
@InProceedings{kani2018xsig,
  yomi = 	 kani    #and#  asakura #and#  masuhara #and#  aotani,
  author = 	 {蟹 暁} #and# jasakura #and# jmasuhara #and# jaotani,
  title = 	 {{GPGPU}プログラム最適化のためのプログラム合成器とその適用手法},
  booktitle = {The 3rd cross-disciplinary Workshop on Computing Systems, Infrastructures, and Programming (xSIG 2018)},
  month = 	 may,
  year = 	 2018,
  date = 	 {2018-05-29},
  note = 	 {口頭発表},
  location = 	 {一橋講堂},
  review = 	 {true}}

2018-09-19
@Misc{masuhara2018fit-invited,
  yomi   = 	 Khatchadourian #and#  masuhara,
  author = 	 Khatchadourian #and# jmasuhara,
  title = 	 {Automated Refactoring of Legacy {Java} Software to Default Methods},
  howpublished = {第17回情報科学技術フォーラム (FIT 2017)},
  organization = IPSJ,
  location = 	 {福岡工業大学},
  month = 	 sep,
  year = 	 2018,
  note = 	 {ICSE 2017既発表論文の紹介},
  page = 	 {IB-002},
  date = 	 {2018-09-19}}

2019-03-06
@InProceedings{kani2019ppl,
  yomi   = 	  kani #and#  masuhara #and#  aotani,
  author = 	 jkani #and# jmasuhara #and# jaotani,
  title = 	 {プロファイル型プログラム合成による{GPGPU}プログラムの半自動最適化},
  crossref =  {ppl2019},
  abstract = 	 {GPGPU プログラムの最適化の一つに共有メモリを用いるものがある。この最適化ではメモリアクセス式を複雑な条件式や添え字式を使って書き換える必要があるが、その書き換えをプログラム合成器を使って行う研究がある。ユーザは最適化したい式を指定するだけで最適化できる一方で、合成器が汎用的であるため、小さな数値計算プログラムの最適化でも数分以上の時間を要していた。我々は共有メモリ最適化に特化した合成器を提案する。最適化前のプログラムの実行時情報を収集し、共有メモリアクセス式が満たすべき制約を生成することで、より小さな合成問題に帰着させる。それを独自に作成したソルバに解かせることで合成を完了する。これにより従来手法よりも10 倍以上の高速化を達成し、より現実的なプログラムに対しても適用可能となった。}}

2019-03-06
@misc{tanabe2019ppl-poster,
  yomi = 	  tanabe #and #  aotani #and #  masuhara,
  author = 	 jtanabe #and # jaotani #and # jmasuhara,
  title = 	 {バージョン付きモジュールシステムの提案},
  crossref = 	 {ppl2019},
  note = 	 {ポスター発表}}
                  
2019-06-06
@Article{tanabe2019ipsj-pro,
  yomi = 	 tanabe #and# luthfan #and# aotani #and# masuhara,
  author = 	 jtanabe #and# luthfan #and# jaotani #and# jmasuhara,
  title = 	 {コエフェクト計算に基づく量化型の再形式化},
  journal = 	 IPSJ-PRO-PRE # {124} #IPSJ-PRO-POST,
  year = 	 2019,
  key = 	 {2019-1-(2)},
  month = 	 jun,
  location = 	 {名古屋大学},
  note = 	 {},
  date = 	 {2017-06-06},
  abstract = 	 {全称型と存在型はプログラミング言語研究において重要な役割を占めている．全称型は多相関数の型の表現方法として，存在型はモジュールやオブジェクトの表現方法として広く用いられており，これらはともに多くのプログラミング言語の理論的基礎である．量化型のある型システムには型変数が現れるため，型規則に型変数のスコープに起因する制約が入る．他の言語要素を追加する際に，この制約が各言語要素由来の制約と複雑に絡むため，量化型を既存言語に導入するのは難しい．この問題を解決するため，我々はF-productを提案する．F-productはコエフェクト計算lRPCFに基づく，総称型と存在型を持つ計算体系である．本研究では我々は型変数のスコープをコエフェクトで表すことで，量化型に起因する困難さを回避した．これにより，型変数のスコープと他の言語特有の制約を独立に扱うことが可能になり，量化型と他の言語要素を混ぜ合わせることが容易になる．事例研究としてコエフェクトで表される性質の1つである線形性をF-productに導入した．この型システムは互いのコエフェクトが干渉しないように構成でき，自然な型付けが可能である．},
  
}
@Article{masuhara2019compsoft,
  yomi = 	 masuhara,
  author = 	 jmasuhara,
  title = 	 {お前まだアレやってるの?},
  journal = 	 compsoft,
  year = 	 2019,
  volume=36,
  number=3,
  pages=1,
  month = 	 aug,
  doi={10.11309/jssst.36.3_1}
}

2020-01-16
@Misc{niimi2020ipsj-pro,
  yomi = 	 niimi #and# masuhara,
  author = 	 jniimi #and# jmasuhara,
  title = 	 {Lift中間言語における動的長配列の追加},
  howpublished = IPSJ-PRO-PRE # {127} #IPSJ-PRO-POST # {2019-4-(8)},
  year = 	 2020,
  month = 	 jan,
  location = 	 {医療イノベーション推進センター第2研修室(神戸市)},
  date = 	 {2020-01-15}
}


2020-03-02
@Misc{tanabe2020ppl-poster,
  yomi = 	 tanabe #and# luthfan #and# aotani  #and# masuhara,
  author = 	 jtanabe #and# luthfan #and# jaotani  #and# jmasuhara,
  title = 	 {コエフェクト多相性に基づいた版多相性の実現},
  crossref = 	 {ppl2020},
  note = 	 {ポスター発表},
  pdf = 	 {ppl2020-tanabe.pdf}}

2020-03-02
@Misc{nose2020ppl-poster,
  yomi =         nose #and# cong  #and# masuhara,
  author = 	 jnose #and# jcong  #and# jmasuhara,
  title = 	 {デザインレシピに沿ったプログラミング環境の実装},
  crossref = 	 {ppl2020},
  note = 	 {ポスター発表},
  pdf = 	 {ppl2020-nose.pdf}}

2020-03-02
@Misc{niimi2020ppl-poster,
  yomi = 	 niimi #and# masuhara,
  author = 	 jniimi #and# jmasuhara,
  title = 	 {Lift中間言語における動的長配列の追加},
  crossref = 	 {ppl2020},
  note = 	 {ポスター・デモ発表},
  pdf = 	 {ppl2020-niimi.pdf}}

2020-03-20
@Article{niimi2020ipsj-trans-pro,
  yomi = 	 niimi #and# masuhara,
  author = 	 jniimi #and# jmasuhara,
  title = 	 {Lift中間言語における動的長配列の追加 },
  journal = 	 ipsj-trans-pro,
  year = 	 2020,
  note = 	 {\cite{niimi2020ipsj-pro}にて発表},
  volume = 	 13,
  number = 	 3,
  url = 	 {http://id.nii.ac.jp/1001/00204824/},
  month = 	 jun,
  submitted = 	 {2019-11-17},
  accepted = 	 {2020-03-20},
  pdf = 	 {ipsj-trans-pro-2020.pdf},
  published = 	 {2020-06-17},
  pages = 	 {1--12},
  abstract = 	 {LIFT ILはGPGPUプログラムのための配列指向の中間言語である．LIFT コンパイラは高級言語プログラムをOpenCLプログラムに変換する際に，中間言語であるLIFT IL上でハードウェア依存の最適化を行う．一方，LIFT ILには動的に長さが決まる配列を表現できないという問題がある．なぜならばLIFT ILは静的に型付けされる関数型言語で，配列の長さをシンボルとして推論する依存型システムを備えており，静的にすべての配列長のシンボルが決定しているからである．本論文では，LIFT ILを存在型で拡張することで動的長配列を扱う方法を提案する．その際，型から配列長を隠蔽・展開する操作を適切な場所に挿入する必要があるが，それらの自動挿入方法を提案する．この提案に基づいて，LIFT ILのコンパイラを作成し，そのうえでフィルター関数を実装した．さらに，Project Euler問題集を用いて，拡張したLIFT ILコンパイラで動的長配列を扱うプログラムが記述・コンパイル・実行できることを確かめた．},
  
}

2021-03-09
@Misc{ogushi2021ppl-poster,
  author = 	 jogushi #and# jmasuhara,
  yomi = 	  ogushi #and#  masuhara,
  title = 	 {ライブデータ構造プログラミングの大規模データ利用のための改善},
  crossref = 	 {ppl2021},
  note = 	 {ポスター・デモ発表},
  abstract = 	 {グラフ描画アルゴリズムを用いてデータ構造を図示するライブプログラミング環境で大規模データ構造をプログラムするとき、２つの問題点がある。図が画面に収まるように縮小表示されるのでプログラマが注目している箇所の発見・認識が困難になる点と、プログラマがデータの参照関係を把握する上で不要なノードやエッジが増えてしまう点である。
これらの問題点を解決するため、プログラマの注目点を自動推定し、注目点からの参照距離やクラス・フィールドの重要度を使ってグラフ内のそれぞれの箇所の拡大率を変更・決定する手法を提案する。
この提案手法によりプログラマはコードを編集するだけで、注目したい箇所付近のグラフが拡大表示・注目されていない不要な箇所が縮小表示あるいは抽象化され、データ構造の変化を観察しやすくなる。
我々はライブデータ構造プログラミング環境Kanonのユーザーインターフェースを拡張し、新たなレイアウトアルゴリズムを実装・導入することで提案手法を実現した。
また、この提案手法の有用性を示すためにプログラミング経験者数名を対象としたユーザー実験を実施する。}}

2021-03-09
@Misc{niimi2021ppl-poster,
  author = 	 jniimi #and# jcong #and# jmasuhara,
  yomi = 	  niimi #and#  cong #and#  masuhara,
  title = 	 {Effekt言語の双方向エフェクトによる拡張},
  crossref = 	 {ppl2021},
  note = 	 {ポスター・デモ発表},
  abstract = 	 {代数的エフェクトとハンドラは、例外や副作用などの様々な計算効果を統一的かつ安全に実装することを可能にする。しかし、一般の代数的エフェクトで表現できるのは例外処理などの単方向フローを含むプログラムに限られており、ジェネレータや通信などの双方向フローを含むプログラムは表現できない。その問題を解決するために双方向性代数的エフェクトが提案された。
一方、Effektは代数的エフェクトを持つ言語である。Effektは代数的エフェクトをcapability渡しという独自の技法によって実現することで、型システムを簡素化している。
本研究ではEffektで双方向フローを含むプログラムを記述できるようにするためにEffektを双方向性代数的エフェクトで拡張する。具体的にはその実装、および形式化を行う。}}

2021-03-09
@Misc{nose2021ppl-poster,
  author = 	 jnose #and# jcong #and# jmasuhara,
  yomi = 	  nose #and#  cong #and#  masuhara,
  title = 	 {デザインレシピに基づいたプログラミングための開発環境の構築に向けて},
  crossref = 	 {ppl2021},
  note = 	 {ポスター・デモ発表},
  abstract = 	 {デザインレシピは、関数を定義する際に考えるべきことや書くべきことを6つのステップにまとめたものである。デザインレシピを使うことで、プログラミング初学者は各ステップで何をすべきかが明確になる。しかし、途中のステップの結果は、実行可能なコードでないこともあり、それらが適切かどうかは判断できないこともしばしばある。 本研究の目標は、デザインレシピに基づいたプログラミングに特化したプログラミング環境を作ることである。 そのために、デザインレシピの各ステップでフィードバックを生成するためのDSLを実装する。}}

2021-03-09
@Misc{ikemori2021ppl-poster,
  author = 	 jikemori #and# jcong #and# jmasuhara,
  yomi = 	  ikemori #and#  cong #and#  masuhara,
  title = 	 {代数的エフェクトを特徴に持つ計算体系へのエフェクト強制の導入と健全性の証明},
  crossref = 	 {ppl2021},
  note = 	 {ポスター・デモ発表},
  abstract = 	 {代数的エフェクトとは，例外や状態などの計算エフェクトを表すための機構である．代数的エフェクトを特徴に持つプログラミング言語としてKoka言語がある．Koka言語のコンパイラでは高階の多相型と代数的エフェクト，エフェクト強制を特徴に持つ明示的型付けの中間言語が用いられている．この中間言語の形式化である System Fe には，エフェクト強制が含まれていなかった．本研究では，System Fe にエフェクト強制を導入した計算体系 System Fe+openを定義し，健全性を証明する．System Fe+open では，System Fe の健全性を示す上で必要な補題が成り立たないため，証明全体を一から再構成する．}}

2021-03-09
@Misc{furudono2021ppl-poster,
  author = 	 jfurudono #and# jcong #and# jmasuhara,
  yomi = 	  furudono #and#  cong #and#  masuhara,
  title = 	 {Koka言語に対するエフェクト割り当て最適化},
  crossref = 	 {ppl2021},
  note = 	 {ポスター・デモ発表},
  abstract = 	 {本研究ではKoka言語のためのコンパイラ最適化として open floating を提案する。
Koka言語は代数的エフェクトとそれを解析するエフェクトシステムを備えた関数型言語である。
それらを備えることで例外や非決定計算などの計算エフェクトを使ったプログラムを安全かつ柔軟に書くことができる。
代数的エフェクトを効率よく実現するためには、言語の意味論やコンパイラの実装方式を工夫する必要があり、
Koka言語ではエフェクト割り当てに基づいた変換であるエビデンス変換をコンパイラに採用している。
本研究では、エビデンス変換を施す前の中間表現のエフェクト割り当てを最適化することで、コンパイラの生成コードの実行速度を向上させる。}}
                  
2021-03-09
@Misc{takahashi2021ppl-poster,
  author = 	 jtakahashi #and# jizawa #and# jmasuhara #and# jcong,
  yomi = 	 takahashi #and# izawa #and# masuhara #and# cong,
  title = 	 {汎言語的ライブプログラミング環境のためのデータ構造解析手法},
  crossref = 	 {ppl2021},
  note = 	 {ポスター・デモ発表},
  abstract = 	 {ライブプログラミング環境は，編集中のプログラムを継続的に実行し，プログラムの変更を即座にプログラマへフィードバックする機構である。特に我々が開発するKanonは，オブジェクトの参照関係をグラフとして表示する，データ構造に特化した実用的なライブプログラミング環境である。現在数多くのプログラミング言語が実用される一方，既存のライブプログラミング環境の多くは，特定のプログラミング言語に特化して実装されてきた。本研究では，汎言語的なデータ構造特化ライブプログラミング環境実現のための，メタJITコンパイラフレームワークであるGraal/Truffleを用いた汎言語的なデータ構造解析手法を提案する。}}

2021-07-21
@Misc{takahashi2021ipsj-pro,
  author = 	 jtakahashi #and# jizawa #and# jmasuhara #and# jcong,
  yomi = 	 takahashi #and# izawa #and# masuhara #and# cong,
  title = 	 {言語実現フレームワークに基づく汎言語的オブジェクトグラフ収集手法},
  howpublished = IPSJ-PRO-PRE # {135} #IPSJ-PRO-POST # {2021-2-(7)},
  pdf = 	 {pro2021-2-7.pdf},
  month = 	 jul,
  url = 	 {https://sigpro.ipsj.or.jp/pro2021-2/},
  date = 	 {2021-07-21},
  abstract = 	 {ライブプログラミング環境は，プログラム実行中の値や実行結果をプログラムが編集されると即座に再実行して表示する．既存のライブプログラミング環境は，この機構を専用のインタプリタやプログラム変換器といった，対象言語に大きく依存した実現をしている．本研究は，ライブプログラミング環境を汎言語的，すなわち実現の大部分は対象言語に依存しない共通のものとすることを目標として，言語実現フレームワークを用いた設計・実現方法を提案する．この目標に向けた第一歩として，本論文では，データ構造ライブプログラミング環境Kanon の実現で必要となる，JavaScript プログラムが実行中に生成するオブジェクトグラフを収集する機構を，言語実現フレームワークGraal/Truffle に基づいて実現する．提案手法はオブジェクトグラフ収集機能を持ったJavaScript 仮想機械を作るものであり，その実現はGraal/Truffle に対するオブジェクト操作を監視するAPI の追加と，JavaScript 言語定義からのAPI 呼び出しからなる．実験では，オブジェクトグラフを可視化するためにKanon が必要とする情報をKanon 仮想機械で収集できることを確認した．作成した仮想機械に対しては，既存のKanon 処理系のオブジェクト収集機構との性能比較を行った．},
  year = 	 2021}

2021-09-01 
@InProceedings{arai2021jssst,
  author = 	 jarai #and# jmasuhara #and# jcong,
  yomi = 	 arai #and# masuhara #and# cong,
  title = 	 {{WebAssembly}を対象にした{Scheme}コンパイラの作成に向けて},
  OPTdate = 	 {2021-09-01},
  OPTurl = 	 {http://jssst.or.jp/files/user/taikai/2021/proceedings.html},
  OPTbooktitle =    JSSSTConf #{第38回大会論文集},
  OPTyear = 	 2021,
  pages = 	 {22-S},
  OPTmonth = 	 sep,
  OPTorganization = JSSST,
  pdf = 	 {jssst2021.pdf},
  crossref = 	 {jssst2021},
  abstract = 	 {WebAssembly はスタックベースの仮想機械語であり， Java バイトコードや CIL のような仮想機械語と比較してより機械語に近い抽象度を持つ． Scheme のように第一級継続を有する言語からそのような対象言語へのコンパイルに対する取り組みが行われていないため，本論文では第一級継続をサポートする Scheme から高速な WebAssemblyへのコンパイル手法を検討する準備として，簡単なコンパイラと基本的な最適化のいくつかを実現し，その効果を測定した．今後の展望として，コンパイラの対象言語を WebAssembly に限定継続を導入した wasm/k に変更し，call-with-current-continuation をその限定継続を用いて実装することで，今回作成したコンパイラとどのような性能差が生じるかについて議論する．}
}

2021-09-02
@Misc{tsuyama2021jssst,
  author = 	 jtsuyama #and# jcong #and# jmasuhara,
  yomi = 	 tsuyama #and# cong #and# masuhara,
  title = 	 {型安全性の証明付きインタプリタのための汎用ライブラリの実装へ向けて},
  note = 	 {ポスター発表},
                  crossref = {jssst2021},
}

2021-09-02
@Misc{tsunoda2021jssst,
  author = 	 jtsunoda #and# jmasuhara #and# jcong,
  yomi = 	 tsunoda #and# masuhara #and# cong,
  title = 	 {エラーを起こさせる初学者向けプログラミングドリルの提案},
  note = 	 {ポスター発表},
                  crossref = {jssst2021},
}

2021-11-01
@Misc{takahashi2021ipsj-pro136,
  author = 	 jtakahashi #and# jizawa #and# jmasuhara #and# jcong,
  yomi = 	 takahashi #and# izawa #and# masuhara #and# cong,
  title = 	 {データ構造ライブプログラミングのための言語実現フレームワークに基づくオブジェクトグラフ収集手法},
  howpublished = IPSJ-PRO-PRE # {136} #IPSJ-PRO-POST # {2021-3-(5)},
  OPTpdf = 	 {pro2021-3-5.pdf},
  month = 	 nov,
  url = 	 {https://sigpro.ipsj.or.jp/pro2021-3/},
  date = 	 {2021-11-01},
  OPTabstract = 	 {},
  year = 	 2021}
